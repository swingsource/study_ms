{
  "name": "Node.js 教程",
  "author": "admin",
  "type": "前端进阶",
  "introduction": "Node.js 是运行在服务端的 JavaScript。",
  "data": [{
    "teach_name": "Node.js 教程",
    "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
    "sort_index": 1,
    "parent_sort_index": 1,
    "chapter_level_one_id": "5116f21e061867ab762063579329e921",
    "chapter_level_one_parent_id": "0",
    "chapter_level_one_name": "Node.js 教程",
    "chapter_level_one_url": "",
    "chapter_level_two_id": "cb380bc3878e4d572fb9091154ef1580",
    "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
    "chapter_level_two_name": "Node.js 教程",
    "chapter_level_two_url": "/nodejs/nodejs-tutorial.html",
    "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2><span class=\"color_h1\">Node.js</span> 教程</h2> <div class=\"tutintro\"> <img src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/nodejs.jpg\" alt=\"nodejs\" class=\"alignnone size-full wp-image-6521\" width=\"201\" height=\"135\"> <p>Node.js是运行在服务端的JavaScript。</p> <p>Node.js是一个基于Chrome JavaScript运行时建立的一个平台。</p> <p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p><p><br></p> </div> <hr> <h2>Node.js教程适用人群</h2> <p>对于不会运用Python、PHP以及Java等动态编程语言的前端程序员来说，选择Node.js作为一个创建自己的服务的工具是非常明智的。</p> <p>Node.js是运行在服务端的JavaScript，因此，熟悉Javascript的使用将有助于学习Node.js。</p><p>同时，学习该Node.js教程也可以帮助后端程序员部署一些高性能的服务。</p> <hr> <h2> 学习本教程前你需要了解</h2><p> 在继续本教程之前，你应该了解一些基本的计算机编程术语。如果你学习过Javascript，PHP，Java等编程语言，将有助于你更快的了解Node.js编程。 </p> <hr> <h2>第一个Node.js程序：Hello World！</h2> <h3>脚本模式</h3> <p>以下是我们的第一个Node.js程序：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log(\"Hello World\");</code></pre> <p> 保存该文件，文件名为helloworld.js，并通过node命令来执行：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">node helloworld.js</code></pre> <p>程序执行后，正常的话，就会在终端输出Hello World。</p> <h3>交互模式</h3> <p> 打开终端，键入node进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">$ node\n&gt; console.log('Hello World!');\nHello World!</code></pre><h2>相关教程</h2><p><a href=\"https://www.w3cschool.cn/javascript/js-tutorial.html\" target=\"_blank\">JavaScript教程</a></p><p><a href=\"https://www.w3cschool.cn/php/php-tutorial.html\" target=\"_blank\">PHP教程</a></p><p><a href=\"https://www.w3cschool.cn/java/java-tutorial.html\" target=\"_blank\">Java教程</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
  },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 19,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "94d29a1d944aa97417d3d50376483392",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js Express 框架",
      "chapter_level_two_url": "/nodejs/nodejs-express-framework.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js Express 框架</h2><p>Express 是一个为Node.js设计的web开发框架，它基于nodejs平台。</p>\n<hr>\n<h2>Express 简介</h2>\n<p>Express是一个简洁而灵活的node.js Web应用框架, 提供了一系列强大特性帮助你创建各种Web应用，和丰富的HTTP工具。</p>\n<p>使用Express可以快速地搭建一个完整功能的网站。</p>\n<p>Express 框架核心特性包括：</p>\n<ul>\n<li><p>可以设置中间件来响应HTTP请求。</p></li>\n<li><p>定义了路由表用于执行不同的HTTP请求动作。 </p></li>\n<li><p>可以通过向模板传递参数来动态渲染HTML页面。</p></li>\n</ul>\n<hr>\n<h2>安装 Express</h2>\n<p>安装Express并将其保存到依赖列表中：</p>\n<pre>$ npm install express --save</pre>\n<p>以上命令会将Express框架安装在当期目录的<b>node_modules</b>目录中， <b>node_modules</b>目录下会自动创建express目录。以下几个重要的模块是需要与express框架一起安装的：</p>\n<ul>\n<li><p><b>body-parser</b> -  node.js中间件，用于处理JSON, Raw, Text和URL编码的数据。</p></li>\n<li><p><b>cookie-parser</b> -  这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</p></li>\n<li><p><b>multer</b> -   node.js中间件，用于处理enctype=\"multipart/form-data\"（设置表单的MIME编码）的表单数据。</p></li>\n</ul>\n<pre>$ npm install body-parser --save\n$ npm install cookie-parser --save\n$ npm install multer --save\n</pre>\n<hr>\n<h2>第一个 Express 框架实例</h2>\n<p>接下来我们使用Express框架来输出\"Hello World\"。</p>\n<p>以下实例中我们引入了express模块，并在客户端发起请求后，响应\"Hello World\"字符串。</p>\n<p>创建express_demo.js文件，代码如下所示：</p>\n<pre>//express_demo.js 文件\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n   res.send('Hello World');\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n\n<p>执行以上代码：</p>\n<pre>$ node express_demo.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre>\n<p>在浏览器中访问http://127.0.0.1:8081，结果如下图所示：</p>\n\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs_sample.jpg\">\n\n\n<hr>\n<h2>请求和响应</h2>\n<p>Express应用使用回调函数的参数： <b>request</b>和<b>response</b>对象来处理请求和响应的数据。\n</p><pre>app.get('/', function (req, res) {\n   // --\n})\n</pre>\n<p><b>request</b>和<b>response</b>对象的具体介绍：</p>\n\n<p><b>Request 对象</b> -  request对象表示HTTP请求，包含了请求查询字符串，参数，内容，HTTP头部等属性。常见属性有： </p>\n<ol>\n<li>req.app：当callback为外部文件时，用req.app访问express的实例</li>\n<li>req.baseUrl：获取路由当前安装的URL路径</li>\n<li>req.body / req.cookies：获得「请求主体」/ Cookies</li>\n<li>req.fresh / req.stale：判断请求是否还「新鲜」</li>\n<li>req.hostname / req.ip：获取主机名和IP地址</li>\n<li>req.originalUrl：获取原始请求URL</li>\n<li>req.params：获取路由的parameters</li>\n<li>req.path：获取请求路径</li>\n<li>req.protocol：获取协议类型</li>\n<li>req.query：获取URL的查询参数串</li>\n<li>req.route：获取当前匹配的路由</li>\n<li>req.subdomains：获取子域名</li>\n<li>req.accpets（）：检查请求的Accept头的请求类型</li>\n<li>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages</li>\n<li>req.get（）：获取指定的HTTP请求头</li>\n<li>req.is（）：判断请求头Content-Type的MIME类型</li>\n</ol>\n\n<p><strong>Response 对象</strong>  - response对象表示HTTP响应，即在接收到请求时向客户端发送的HTTP响应数据。常见属性有：</p>\n<ol>\n<li>res.app：同req.app一样</li>\n<li>res.append（）：追加指定HTTP头</li>\n<li>res.set（）在res.append（）后将重置之前设置的头</li>\n<li>res.cookie（name，value [，option]）：设置Cookie</li>\n<li>opition: domain / expires / httpOnly / maxAge / path / secure / signed</li>\n<li>res.clearCookie（）：清除Cookie</li>\n<li>res.download（）：传送指定路径的文件</li>\n<li>res.get（）：返回指定的HTTP头</li>\n<li>res.json（）：传送JSON响应</li>\n<li>res.jsonp（）：传送JSONP响应</li>\n<li>res.location（）：只设置响应的Location HTTP头，不设置状态码或者close response</li>\n<li>res.redirect（）：设置响应的Location HTTP头，并且设置状态码302</li>\n<li>res.send（）：传送HTTP响应</li>\n<li>res.sendFile（path [，options] [，fn]）：传送指定路径的文件\n-会自动根据文件extension设定Content-Type</li>\n<li>res.set（）：设置HTTP头，传入object可以一次设置多个头</li>\n<li>res.status（）：设置HTTP状态码</li>\n<li>res.type（）：设置Content-Type的MIME类型</li>\n</ol>\n\n<hr>\n<h2>路由</h2>\n<p>\n\n我们已经了解了HTTP请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。</p>\n<p>在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。</p>\n<p>\n接下来我们扩展Hello World，添加一些功能来处理更多类型的HTTP请求。</p>\n<p>创建express_demo2.js文件，代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\n\n//  主页输出 \"Hello World\"\napp.get('/', function (req, res) {\n   console.log(\"主页 GET 请求\");\n   res.send('Hello GET');\n})\n\n\n//  POST 请求\napp.post('/', function (req, res) {\n   console.log(\"主页 POST 请求\");\n   res.send('Hello POST');\n})\n\n//  /del_user 页面响应\napp.delete('/del_user', function (req, res) {\n   console.log(\"/del_user 响应 DELETE 请求\");\n   res.send('删除页面');\n})\n\n//  /list_user 页面 GET 请求\napp.get('/list_user', function (req, res) {\n   console.log(\"/list_user GET 请求\");\n   res.send('用户列表页面');\n})\n\n// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求\napp.get('/ab*cd', function(req, res) {   \n   console.log(\"/ab*cd GET 请求\");\n   res.send('正则匹配');\n})\n\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n\n<p>执行以上代码：</p>\n<pre>$ node express_demo2.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre>\n<p>接下来你可以尝试访问http://127.0.0.1:8081不同的地址，查看效果。</p>\n\n<p>在浏览器中访问http://127.0.0.1:8081/list_user，结果如下图所示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/express1.jpg\">\n<p>在浏览器中访问http://127.0.0.1:8081/abcd，结果如下图所示：</p><img src=\"https://atts.w3cschool.cn/attachments/image/express2.jpg\">\n<p>在浏览器中访问http://127.0.0.1:8081/abcdefg，结果如下图所示：</p><img src=\"https://atts.w3cschool.cn/attachments/image/express3.jpg\">\n<hr>\n<h2>静态文件</h2>\n\n<p>\nExpress提供了内置的中间件<b>express.static</b>来设置静态文件如：图片，CSS, JavaScript等。</p>\n<p>你可以使用<b>express.static</b>中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript文件放在public目录下，你可以这么写：</p>\n<pre>app.use(express.static('public'));\n</pre>\n<p>我们可以到public/images目录下放些图片,如下所示：</p>\n<pre>node_modules\nserver.js\npublic/\npublic/images\npublic/images/logo.png\n</pre>\n<p>\n让我们再修改下\"Hello Word\"应用添加处理静态文件的功能。</p>\n<p>创建express_demo3.js文件，代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\n\napp.use(express.static('public'));\n\napp.get('/', function (req, res) {\n   res.send('Hello World');\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>执行以上代码：</p>\n<pre>$ node express_demo3.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre><p>执行以上代码：</p>\n<p>在浏览器中访问 http://127.0.0.1:8081/images/logo.png（本实例采用了W3Cschool教程的logo），结果如下图所示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/youj-logo.png\">\n<hr><h2>GET 方法</h2>\n<p>\n以下实例演示了在表单中通过GET方法提交两个参数，我们可以使用server.js文件内的<b>process_get</b>路由器来处理输入：</p>\n\n<p> index.htm文件代码如下： </p>\n<pre>&lt;html&gt;\n&lt;body&gt;\n&lt;form action=\"http://127.0.0.1:8081/process_get\" method=\"GET\"&gt;\nFirst Name: &lt;input type=\"text\" name=\"first_name\"&gt;  &lt;br&gt;\n\nLast Name: &lt;input type=\"text\" name=\"last_name\"&gt;\n&lt;input type=\"submit\" value=\"Submit\"&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p>server.js文件代码如下:</p>\n<pre>var express = require('express');\nvar app = express();\n\napp.use(express.static('public'));\n\napp.get('/index.htm', function (req, res) {\n   res.sendFile( __dirname + \"/\" + \"index.htm\" );\n})\n\napp.get('/process_get', function (req, res) {\n\n   // 输出 JSON 格式\n   response = {\n       first_name:req.query.first_name,\n       last_name:req.query.last_name\n   };\n   console.log(response);\n   res.end(JSON.stringify(response));\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre><p>执行以上代码：</p>\n<pre>node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre>\n<p>浏览器访问 http://127.0.0.1:8081/index.htm，如图所示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/express5.jpg\">\n<p>现在你可以向表单输入数据，并提交，如下演示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif6.gif\">\n<hr>\n<h2>POST 方法</h2>\n<p>\n以下实例演示了在表单中通过POST方法提交两个参数，我们可以使用server.js文件内的<b>process_post</b>路由器来处理输入：</p>\n\n<p> index.htm文件代码修改如下： </p>\n<pre>&lt;html&gt;\n&lt;body&gt;\n&lt;form action=\"http://127.0.0.1:8081/process_post\" method=\"POST\"&gt;\nFirst Name: &lt;input type=\"text\" name=\"first_name\"&gt;  &lt;br&gt;\n\nLast Name: &lt;input type=\"text\" name=\"last_name\"&gt;\n&lt;input type=\"submit\" value=\"Submit\"&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre><p>server.js文件代码修改如下:</p>\n<pre>var express = require('express');\nvar app = express();\nvar bodyParser = require('body-parser');\n\n// 创建 application/x-www-form-urlencoded 编码解析\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\n\napp.use(express.static('public'));\n\napp.get('/index.htm', function (req, res) {\n   res.sendFile( __dirname + \"/\" + \"index.htm\" );\n})\n\napp.post('/process_post', urlencodedParser, function (req, res) {\n\n   // 输出 JSON 格式\n   response = {\n       first_name:req.body.first_name,\n       last_name:req.body.last_name\n   };\n   console.log(response);\n   res.end(JSON.stringify(response));\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>执行以上代码：</p>\n<pre>$ node server.js\n应用实例，访问地址为 http://0.0.0.0:8081\n</pre>\n<p>浏览器访问http://127.0.0.1:8081/index.htm，如图所示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/express5.jpg\">\n<p>现在你可以向表单输入数据，并提交，如下演示：</p>\n\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif7.gif\">\n<hr>\n<h2>文件上传</h2>\n<p>以下我们创建一个用于上传文件的表单，使用POST方法，表单enctype属性设置为multipart/form-data。</p><p>index.htm文件代码修改如下：</p>\n<pre>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;文件上传表单&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h3&gt;文件上传：&lt;/h3&gt;\n选择一个文件上传: &lt;br /&gt;\n&lt;form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n&lt;input type=\"file\" name=\"image\" size=\"50\" /&gt;\n&lt;br /&gt;\n&lt;input type=\"submit\" value=\"上传文件\" /&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre><p>server.js文件代码修改如下:</p>\n<pre>var express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n\nvar bodyParser = require('body-parser');\nvar multer  = require('multer');\n\napp.use(express.static('public'));\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(multer({ dest: '/tmp/'}).array('image'));\n\napp.get('/index.htm', function (req, res) {\n   res.sendFile( __dirname + \"/\" + \"index.htm\" );\n})\n\napp.post('/file_upload', function (req, res) {\n\n   console.log(req.files[0]);  // 上传的文件信息\n\n   var des_file = __dirname + \"/\" + req.files[0].originalname;\n   fs.readFile( req.files[0].path, function (err, data) {\n        fs.writeFile(des_file, data, function (err) {\n         if( err ){\n              console.log( err );\n         }else{\n               response = {\n                   message:'File uploaded successfully', \n                   filename:req.files[0].originalname\n              };\n          }\n          console.log( response );\n          res.end( JSON.stringify( response ) );\n       });\n   });\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>执行以上代码：</p>\n<pre>$ node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre>\n<p>浏览器访问http://127.0.0.1:8081/index.htm，如图所示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/express6.jpg\">\n<p>现在你可以向表单输入数据，并提交，如下演示：</p>\n\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif8.gif\">\n\n\n<hr>\n<h2>Cookie 管理</h2>\n\n<p>我们可以使用中间件向Node.js服务器发送cookie信息，以下代码输出了客户端发送的cookie信息：</p>\n\n<pre>// express_cookie.js 文件\nvar express      = require('express')\nvar cookieParser = require('cookie-parser')\n\nvar app = express()\napp.use(cookieParser())\n\napp.get('/', function(req, res) {\n  console.log(\"Cookies: \", req.cookies)\n})\n\napp.listen(8081)\n</pre>\n<p>执行以上代码：</p>\n<pre>$ node express_cookie.js \n</pre><p>现在你可以访问 http://127.0.0.1:8081 并查看终端信息的输出，如下演示：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif9.gif\"></div></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 18,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "4a6fa0d4b98a60d5f1a6cc09d0f7c828",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js Web 模块",
      "chapter_level_two_url": "/nodejs/nodejs-web-module.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js Web 模块</h2><p>本节介绍Node.js Web模块，首先，你应该先了解什么是Web服务器。</p>\n<hr>\n<h2>什么是 Web 服务器？</h2>\n<p>Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序。</p><p>Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。</p>\n<p>大多数web服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。</p>\n<p>目前最主流的三个Web服务器是Apache、Nginx、IIS。</p>\n<hr>\n<h2>Web 应用架构</h2>\n<img title=\"Web 应用架构\" src=\"https://atts.w3cschool.cn/attachments/image/web_architecture.jpg\">\n\n<ul>\n<li><p><b>Client</b> - 客户端，一般指浏览器，浏览器可以通过HTTP协议向服务器请求数据。 </p></li>\n<li><p><b>Server</b> - 服务端，一般指Web服务器，可以接收客户端请求，并向客户端发送响应数据。</p></li>\n<li><p><b>Business</b> - 业务层， 通过Web服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</p></li>\n<li><p><b>Data</b> - 数据层，一般由数据库组成。</p></li>\n</ul>\n<hr>\n<h2>使用 Node 创建 Web 服务器</h2>\n<p>\nNode.js提供了http模块，http模块主要用于搭建HTTP服务端和客户端，如果要使用HTTP服务器或客户端功能，则必须调用http模块，代码如下：</p>\n<pre>var http = require('http');</pre>\n<p>\n以下是演示一个最基本的HTTP服务器架构(使用8081端口)，创建server.js文件，代码如下所示：</p>\n<pre>var http = require('http');\nvar fs = require('fs');\nvar url = require('url');\n\n\n// 创建服务器\nhttp.createServer( function (request, response) {  \n   // 解析请求，包括文件名\n   var pathname = url.parse(request.url).pathname;\n   \n   // 输出请求的文件名\n   console.log(\"Request for \" + pathname + \" received.\");\n   \n   // 从文件系统中读取请求的文件内容\n   fs.readFile(pathname.substr(1), function (err, data) {\n      if (err) {\n         console.log(err);\n         // HTTP 状态码: 404 : NOT FOUND\n         // Content Type: text/plain\n         response.writeHead(404, {'Content-Type': 'text/html'});\n      }else{\t         \n         // HTTP 状态码: 200 : OK\n         // Content Type: text/plain\n         response.writeHead(200, {'Content-Type': 'text/html'});\t\n         \n         // 响应文件内容\n         response.write(data.toString());\t\t\n      }\n      //  发送响应数据\n      response.end();\n   });   \n}).listen(8081);\n\n// 控制台会输出以下信息\nconsole.log('Server running at http://127.0.0.1:8081/');\n</pre>\n<p>接下来我们在该目录下创建一个index.htm文件，代码如下：</p>\n\n<pre>&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Sample Page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello World!\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p>执行server.js文件：</p>\n\n<pre>$ node server.js\nServer running at http://127.0.0.1:8081/\n</pre>\n\n<p>接着我们在浏览器中输入并打开地址：http://127.0.0.1:8081/index.htm，显示如下图所示:</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs_sample1.jpg\">\n<p>执行server.js的控制台输出信息如下：</p>\n<pre>Server running at http://127.0.0.1:8081/\nRequest for /index.htm received.     #  客户端请求信息\n</pre>\n<h3>Gif 实例演示</h3>\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif4.gif\">\n<hr>\n<h2>使用 Node 创建 Web 客户端</h2>\n\n<p>使用Node创建Web客户端需要引入http模块，创建client.js文件，代码如下所示：</p>\n<pre>var http = require('http');\n\n// 用于请求的选项\nvar options = {\n   host: 'localhost',\n   port: '8081',\n   path: '/index.htm'  \n};\n\n// 处理响应的回调函数\nvar callback = function(response){\n   // 不断更新数据\n   var body = '';\n   response.on('data', function(data) {\n      body += data;\n   });\n   \n   response.on('end', function() {\n      // 数据接收完成\n      console.log(body);\n   });\n}\n// 向服务端发送请求\nvar req = http.request(options, callback);\nreq.end();\n</pre>\n\n<p>新开一个终端，执行client.js文件，输出结果如下：\n</p>\n<pre>$ node client.js\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Sample Page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello World!\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p>执行server.js的控制台输出信息如下：</p>\n<pre>Server running at http://127.0.0.1:8081/\nRequest for /index.htm received.   # 客户端请求信息\n</pre>\n<h3>Gif 实例演示</h3>\n<img src=\"https://atts.w3cschool.cn/attachments/image/nodejs-gif5.gif\"></div></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 17,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "4cb22e0ec24de1dfe0a3b3b525905027",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 工具模块",
      "chapter_level_two_url": "/nodejs/nodejs-utitlity-module.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 工具模块</h2><p>在 Node.js 模块库中有很多好用的模块。这些模块都是很常见的，并同时开发基于任何节点的应用程序频繁使用。接下来我们为大家介绍几种常用模块的使用：</p>\n<table class=\"reference\">\n<tbody><tr><th>序号</th><th>模块名 &amp; 描述</th></tr>\n<tr><td>1</td><td><a href=\"/nodejs/nodejs-os-module.html\" alt=\"OS 模块\"><b>OS 模块</b></a><br> 提供基本的系统操作函数。</td></tr>\n<tr><td>2</td><td><a href=\"/nodejs/nodejs-path-module.html\" alt=\"Path 模块\"><b>Path 模块</b></a><br>提供了处理和转换文件路的工具。</td></tr>\n<tr><td>3</td><td><a href=\"/nodejs/nodejs-net-module.html\" alt=\"Net 模块\"><b>Net 模块</b></a><br> 用于底层的网络通信。提供了服务端和客户端的的操作。</td></tr>\n<tr><td>4</td><td><a href=\"/nodejs/nodejs-dns-module.html\" alt=\"DNS 模块\"><b>DNS 模块</b></a><br> 用于解析域名。</td></tr>\n<tr><td>5</td><td><a href=\"/nodejs/nodejs-domain-module.html\" alt=\"Domain 模块\"><b>Domain 模块</b></a><br> 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</td></tr></tbody></table><p>以上就是常用的Node.js工具模块，点击表格中的链接能够得到更多内容。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 16,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "8964848155fea52299c8780907048117",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 文件系统",
      "chapter_level_two_url": "/nodejs/nodejs-fs.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 文件系统</h2> <p> Node.js文件系统被封装在fs模块中，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。</p> <p>与其他模块不同的是，fs模块中所有的操作都提供了异步的和同步的两个版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。我们以几个函数为代表，介绍fs常用的功能，并列出fs所有函数的定义和功能。 </p> <hr> <h2> fs.readFile</h2> <p> Node.js读取文件函数语法如下： </p> <pre>fs.readFile(filename,[encoding],[callback(err,data)])\n</pre> <ul> <li>filename（必选），表示要读取的文件名。 </li><li>encoding（可选），表示文件的字符编码。 </li><li>callback 是回调函数，用于接收文件的内容。</li></ul> <p>如果不指定encoding，则callback就是第二个参数。回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。如果指定了encoding，data是一个解析后的字符串，否则data将会是以Buffer形式表示的二进制数据。</p> <p> 例如以下程序，我们从content.txt中读取数据，但不指定编码：</p> <pre>var fs = require('fs'); \nfs.readFile('content.txt', function(err, data) { \n    if(err) { \n        console.error(err); \n  } else{ \n      console.log(data); \n   } \n}); \n</pre> <p>假设content.txt中的内容是<a href=\"https://www.w3cschool.cn/charsets/ref-html-utf8.html\" target=\"_blank\">UTF-8</a>编码的Text文本文件示例，运行结果如下：</p> <pre>&lt;Buffer 54 65 78 74 20 e6 96 87 e6 9c ac e6 96 87 e4 bb b6 e7 a4 ba e4 be 8b&gt; \n</pre> <p> 这个程序以二进制的模式读取了文件的内容，data的值是Buffer对象。如果我们给fs.readFile的encoding指定编码：</p> <pre>var fs = require('fs'); \n    fs.readFile('content.txt', 'utf-8', function(err, data) { \n    if (err) { \n       console.error(err); \n  } else { \n     console.log(data); \n   } \n}); \n</pre> <p> 那么运行结果则是： </p> <pre>Text 文本文件示例\n</pre> <p> 当读取文件出现错误时，err将会是Error对象。如果content.txt不存在，运行前面的代码则会出现以下结果：</p> <pre>{ [Error: ENOENT, no such file or directory 'content.txt'] errno: 34, code: 'ENOENT', \npath: 'content.txt' } \n</pre> <hr> <h2>fs.readFileSync</h2> <p> <strong> fs.readFileSync(filename, [encoding])</strong>是fs.readFile同步的版本。它接受和 fs.readFile 相同的参数，而读取到的文件内容会以函数返回值的形式返回。如果有错 误发生，fs将会抛出异常，你需要使用try和catch捕捉并处理异常。</p> <p><strong>注意：</strong>与同步I/O函数不同，Node.js中异步函数大多没有返回值。</p> <hr> <h2>fs.open</h2> <p>fs.open(path, flags, [mode], [callback(err, fd)])是POSIX open函数的封装，类似于C语言标准库中的fopen函数。它接受两个必选参数，path为文件的路径， flags 可以是以下值：</p> <ul> <li>r ：以读取模式打开文件。</li> <li>r+ ：以读写模式打开文件。</li> <li>w ：以写入模式打开文件，如果文件不存在则创建。</li> <li>w+ ：以读写模式打开文件，如果文件不存在则创建。</li> <li>a ：以追加模式打开文件，如果文件不存在则创建。</li> <li>a+ ：以读取追加模式打开文件，如果文件不存在则创建</li> </ul> <hr> <h2> fs.read</h2> <p>fs.read语法格式如下：</p> <pre>fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead, buffer)])\n</pre> <p>参数说明：</p> <ul> <li>fd: 读取数据并写入buffer指向的缓冲区对象。</li> <li>offset: 是buffer的写入偏移量。</li> <li>length: 是要从文件中读取的字节数。</li> <li>position: 是文件读取的起始位置，如果position的值为null，则会从当前文件指针的位置读取。</li> <li>callback:回调函数传递bytesRead和buffer，分别表示读取的字节数和缓冲区对象。</li> </ul> <p> 以下是一个使用fs.open和fs.read的示例。 </p> <pre>var fs = require('fs'); \nfs.open('content.txt', 'r', function(err, fd) { \n    if(err) { \n        console.error(err); \n      return; \n  } \n    var buf = new Buffer(8); \n  fs.read(fd, buf, 0, 8, null, function(err, bytesRead, buffer) { \n      if(err) { \n            console.error(err); \n          return; \n      } \n        console.log('bytesRead: ' + bytesRead); \n        console.log(buffer); \n }) \n}); \n</pre><p> 运行结果是：</p> <pre>bytesRead: 8 \n&lt;Buffer 54 65 78 74 20 e6 96 87&gt; \n</pre> <p>一般来说，除非必要，否则不要使用这种方式读取文件，因为它要求你手动管理缓冲区和文件指针，尤其是在你不知道文件大小的时候，这将会是一件很麻烦的事情。 </p> <hr><h2> fs 模块函数表</h2> <p><img src=\"https://atts.w3cschool.cn/attachments/image/20170628/1498641141996813.png\" alt=\"nodejs-file1\" class=\"\"><br></p> <p><br></p> <p>更多详情可点击查看：<a href=\"//nodejs.org/api/fs.html\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/api/fs.html</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 15,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "5754e2a2cb2a285f837464e9eae6b63d",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 常用工具util",
      "chapter_level_two_url": "/nodejs/nodejs-util.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 常用工具 util</h2> <p>本节介绍Node.js常用工具util。</p><p> util作为Node.js的一个核心模块，能够提供常用函数的集合，弥补核心JavaScript的功能过于精简的不足。 </p> <hr> <h2>util.inherits</h2> <p> util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 </p> <p>与常见的基于类的不同，JavaScript的面向对象特性是基于原型的。JavaScript没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p> <p> 在这里我们只介绍util.inherits的用法，示例如下： </p> <pre>var util = require('util'); \nfunction Base() { \n  this.name = 'base'; \n    this.base = 1991; \n    this.sayHello = function() { \n      console.log('Hello ' + this.name); \n    }; \n} \nBase.prototype.showName = function() { \n  console.log(this.name);\n}; \nfunction Sub() { \n    this.name = 'sub'; \n} \nutil.inherits(Sub, Base); \nvar objBase = new Base(); \nobjBase.showName(); \nobjBase.sayHello(); \nconsole.log(objBase); \nvar objSub = new Sub(); \nobjSub.showName(); \n//objSub.sayHello(); \nconsole.log(objSub); \n</pre> <p> 我们定义了一个基础对象Base和一个继承自Base的Sub，Base有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits实现继承。运行结果如下：</p> <pre>base \nHello base \n{ name: 'base', base: 1991, sayHello: [Function] } \nsub \n{ name: 'sub' }\n</pre> <p><strong> 注意：</strong>Sub仅仅继承了Base在原型中定义的函数，而构造函数内部创造的base属性和sayHello函数都没有被Sub继承。</p><p>同时，在原型中定义的属性不会被console.log作为对象的属性输出。如果我们去掉objSub.sayHello(); 这行的注释，将会看到：</p> <pre>node.js:201 \nthrow e; // process.nextTick error, or 'error' event on first tick \n^ \nTypeError: Object #&lt;Sub&gt; has no method 'sayHello' \nat Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40) \n</pre> <hr> <h2>util.inspect</h2> <p> util.inspect(object,[showHidden],[depth],[colors])方法可以将任意对象转换为字符串，通常用于调试和错误输出。它至少接受一个object参数，即要转换的对象。</p> <p> showHidden是一个可选参数，如果值为true，将会输出更多隐藏信息。</p><p> depth表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多少。如果不指定depth，则默认递归2层，指定为null时表示将不限递归层数完整遍历对象。 如果color值为true，则输出格式将会以ANSI颜色编码，通常用于在终端显示更漂亮的效果。</p><p> 特别要指出的是，util.inspect并不会简单地直接把对象转换为字符串，即使该对象定义了toString方法也不会调用。</p> <pre>var util = require('util'); \nfunction Person() { \n  this.name = 'byvoid'; \n  this.toString = function() { \n return this.name; \n    }; \n} \nvar obj = new Person(); \nconsole.log(util.inspect(obj)); \nconsole.log(util.inspect(obj, true)); \n</pre> <p> 运行结果是： </p> <pre>{ name: 'byvoid', toString: [Function] } \n{ toString: \n{ [Function] \n[prototype]: { [constructor]: [Circular] }, \n[caller]: null, \n[length]: 0, \n[name]: '', \n[arguments]: null }, \nname: 'byvoid' } \n</pre> <hr> <h2> util.isArray(object)</h2> <p> 如果给定的参数 \"object\" 是一个数组返回true，否则返回false。</p> <pre>var util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false\n</pre> <hr> <h2> util.isRegExp(object)</h2> <p> 如果给定的参数\"object\"是一个正则表达式返回true，否则返回false。</p> <pre>var util = require('util');\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp('another regexp'))\n  // true\nutil.isRegExp({})\n  // false\n</pre> <hr> <h2> util.isDate(object)</h2> <p> 如果给定的参数 \"object\" 是一个日期返回true，否则返回false。</p> <pre>var util = require('util');\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without 'new' returns a String)\nutil.isDate({})\n  // false\n</pre> <hr> <h2> util.isError(object)</h2> <p> 如果给定的参数 \"object\" 是一个错误对象返回true，否则返回false。</p> <pre>var util = require('util');\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: 'Error', message: 'an error occurred' })\n  // false\n</pre> <p> 更多详情可以访问 <a href=\"//nodejs.org/api/util.html\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/api/util.html</a> 了解详细内容。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 14,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "f4575ac086198bd2f39ede996e460772",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 全局对象",
      "chapter_level_two_url": "/nodejs/nodejs-global-object.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 全局对象</h2> <p>本节介绍 Node.js 全局对象，global 全局对象无需引用就可以直接使用。</p><p> JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p> <p> 在浏览器 JavaScript 中，通常window 是全局对象， 而Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p> 我们在Node.js 中能够直接访问到对象通常都是 global 的属性，如 console、process 等，下面逐一介绍。</p> <hr> <h2>全局对象与全局变量</h2> <p> global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量是全局变量： </p> <ul> <li>在最外层定义的变量；</li><li> 全局对象的属性；</li><li> 隐式定义的变量（未定义直接赋值的变量）。</li></ul> <p> 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p> <p><strong>注意：</strong> 永远使用var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p> <hr> <h2>process</h2> <p> process 是一个全局变量，即 global 对象的属性。</p> <p>它用于描述当前Node.js 进程状态 的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍process 对象的一些最常用的成员方法。</p> <p> process.argv是命令行参数数组，第一个元素是 node，第二个元素是脚本文件名， 从第三个元素开始每个元素是一个运行参数。</p> <pre>console.log(process.argv); \n</pre> <p> 将以上代码存储为argv.js，通过以下命令运行： </p> <pre>$ node argv.js 1991 name=byvoid --v \"Carbo Kuo\" \n[ 'node', \n'/home/byvoid/argv.js', \n'1991', \n'name=byvoid', \n'--v', \n'Carbo Kuo' ]\n</pre> <ul> <li><strong>process.stdout</strong>是标准输出流，通常我们使用的 console.log() 向标准输出打印 字符，而 process.stdout.write() 函数提供了更底层的接口。</li><li> <strong>process.stdin</strong>是标准输入流，初始时它是被暂停的，要想从标准输入读取数据， 你必须恢复流，并手动编写流的事件响应函数。</li> </ul><pre>process.stdin.resume(); \nprocess.stdin.on('data', function(data) { \nprocess.stdout.write('read from console: ' + data.toString()); \n}); \n</pre> <li><strong>process.nextTick(callback)</strong>的功能是为事件循环设置一项任务，Node.js 会在 下次事件循环调响应时调用 callback。 </li>  <p> 初学者很可能不理解这个函数的作用，有什么任务不能在当下执行完，需要交给下次事 件循环响应来做呢？</p> <p>我们讨论过，Node.js 适合I/O 密集型的应用，而不是计算密集型的应用， 因为一个Node.js 进程只有一个线程，因此在任何时刻都只有一个事件在执行。</p> <p>如果这个事 件占用大量的CPU 时间，执行事件循环中的下一个事件就需要等待很久，因此Node.js 的一 个编程原则就是尽量缩短每个事件的执行时间。process.nextTick() 提供了一个这样的 工具，可以把复杂的工作拆散，变成一个个较小的事件。</p> <pre>functiondoSomething(args, callback) { \n  somethingComplicated(args); \n  callback(); \n} \ndoSomething(functiononEnd() { \n  compute(); \n}); \n</pre> <p> 我们假设compute() 和somethingComplicated() 是两个较为耗时的函数，以上 的程序在调用 doSomething() 时会先执行somethingComplicated()，然后立即调用 回调函数，在 onEnd() 中又会执行 compute()。下面用process.nextTick() 改写上 面的程序： </p> <pre>functiondoSomething(args, callback) { \n   somethingComplicated(args); \n  process.nextTick(callback); \n} \ndoSomething(functiononEnd() { \n  compute(); \n}); \n</pre> <p> 改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行时间，提高事 件响应速度。 </p> <p><strong>注意：</strong> 不要使用setTimeout(fn,0)代替process.nextTick(callback)， 前者比后者效率要低得多。</p> <p> 我们探讨了process对象常用的几个成员，除此之外process还展示了process.platform、 process.pid、process.execPath、process.memoryUsage() 等方法，以及POSIX 进程信号响应机制。有兴趣的读者可以访问http://nodejs.org/api/process.html 了解详细 内容。 </p><hr> <h2>console</h2> <p> console 用于提供控制台标准输出，它是由Internet Explorer 的JScript 引擎提供的调试 工具，后来逐渐成为浏览器的事实标准。</p><p>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。  console.log()：向标准输出流打印字符并以换行符结束。</p><p>console.log 接受若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</p><p>第一个参数是一个字符串，如果没有 参数，只打印一个换行。</p> <pre>console.log('Hello world'); \nconsole.log('byvoid%diovyb'); \nconsole.log('byvoid%diovyb', 1991); \n</pre> <p> 运行结果为： </p> <pre>Hello world \nbyvoid%diovyb \nbyvoid1991iovyb \n</pre> <ul> <li>console.error()：与console.log() 用法相同，只是向标准错误流输出。</li> <li>console.trace()：向标准错误流输出当前的调用栈。</li> </ul> <pre>console.trace();\n</pre> <p> 运行结果为：</p> <pre>Trace: \nat Object.&lt;anonymous&gt; (/home/byvoid/consoletrace.js:1:71) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)\n</pre><h2>相关教程</h2><p><a href=\"https://www.w3cschool.cn/ecmascript/\" target=\"_blank\">ECMAScript教程</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 13,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "9c2dd8aeebe5b1844fb78dbe9a377ed7",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 路由",
      "chapter_level_two_url": "/nodejs/nodejs-router.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 路由</h2> <p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。</p> <p> 因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。 </p> <p> 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 </p> <pre>                   url.parse(string).query\n                                           |\n           url.parse(string).pathname      |\n                       |                   |\n                       |                   |\n                     ------ -------------------\nhttp://localhost:8888/start?foo=bar&amp;hello=world\n                                ---       -----\n                                 |          |\n                                 |          |\n              querystring(string)[\"foo\"]    |\n                                            |\n                         querystring(string)[\"hello\"]\n</pre> <p> 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 </p> <p> 现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径： </p> <pre>var http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n</pre> <p> 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了--这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。 </p> <p> 在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。 </p> <p> 现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容： </p> <pre>function route(pathname) {\n  console.log(\"About to route a request for \" + pathname);\n}\n\nexports.route = route;\n</pre> <p> 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 </p><p> 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p> <p> 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去： </p> <pre>var http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(pathname);\n\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n</pre> <p> 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中： </p> <pre>var server = require(\"./server\");\nvar router = require(\"./router\");\n\nserver.start(router.route);\n</pre> <p> 在这里，我们传递的函数依旧什么也没做。  </p><p> 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： </p> <pre>bash$ node index.js\nRequest for /foo received.\nAbout to route a request for /foo\n</pre> <p> 以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分。 </p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 12,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "8b5080dbc1a9e360ad15fd5aa2735f82",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 函数",
      "chapter_level_two_url": "/nodejs/nodejs-function.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 函数</h2> <p>在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p> <p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做： </p> <pre>function say(word) {\n  console.log(word);\n}\n\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(say, \"Hello\");\n</pre> <p> 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！ </p> <p> 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 </p> <p> 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 </p> <hr> <h2>匿名函数</h2> <p> 我们可以把一个函数作为变量传递。但是我们不一定要绕这个\"先定义，再传递\"的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： </p> <pre>function execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(function(word){ console.log(word) }, \"Hello\");\n</pre> <p> 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 </p> <p> 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 </p> <hr> <h2> 函数传递是如何让HTTP服务器工作的 </h2> <p> 带着这些知识，我们再来看看我们简约而不简单的<a href=\"https://www.w3cschool.cn/http/u9ktefmo.html\" target=\"_blank\">HTTP</a>服务器： </p> <pre>var http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n</pre> <p> 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。 </p> <p> 用这样的代码也可以达到同样的目的： </p> <pre>var http = require(\"http\");\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);</pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 11,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "5458588522f7169f19a31550b034ea08",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 模块系统",
      "chapter_level_two_url": "/nodejs/nodejs-module-system.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js模块系统</h2> <p> 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p> <p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是<a href=\"https://www.w3cschool.cn/javascript/js-tutorial.html\" target=\"_blank\">JavaScript</a> 代码、<a href=\"https://www.w3cschool.cn/json/json-tutorial.html\" target=\"_blank\">JSON</a> 或者编译过的C/C++ 扩展。</p> <h2>创建模块</h2> <p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 'main.js' 文件，代码如下:</p> <pre>var hello = require('./hello');\nhello.world();\n</pre> <p>以上实例中，代码 require('./hello') 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。</p> <p> Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 </p> <p>接下来我们就来创建hello.js文件，代码如下：</p> <pre>exports.world = function() {\n  console.log('Hello World');\n}\n</pre> <p> 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访 问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访 问main.js 中 exports 对象的成员函数了。</p> <p>有时候我们只是想把一个对象封装到模块中，格式如下： </p> <pre>module.exports = function() {\n  // ...\n}\n</pre> <p>例如: </p> <pre>//hello.js \nfunction Hello() { \n var name; \n    this.setName = function(thyName) { \n       name = thyName; \n  }; \n   this.sayHello = function() { \n     console.log('Hello ' + name); \n  }; \n}; \nmodule.exports = Hello;\n</pre> <p>这样就可以直接获得这个对象了：</p> <pre>//main.js \nvar Hello = require('./hello'); \nhello = new Hello(); \nhello.setName('BYVoid'); \nhello.sayHello(); \n</pre> <p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 </p> <hr> <h2>服务端的模块放在哪里</h2> <p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p> <pre>var http = require(\"http\");\n\n...\n\nhttp.createServer(...);\n</pre> <p> Node.js中自带了一个叫做\"http\"的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 </p> <p> 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p> <p>Node.js 的 require方法中的文件查找策略如下：</p> <p> 由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p> <p><img src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/nodejs-require.jpg\" alt=\"nodejs-require\" width=\"479\" height=\"601\" class=\"alignnone size-full wp-image-6555\"></p> <h3>从文件模块缓存中加载</h3> <p> 尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 </p> <p> 从原生模块加载</p> <p> 原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(\"http\")都不会从这些文件中加载，而是从原生模块中加载。 </p> <p> 原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p> <h3> 从文件加载</h3> <p> 当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。 </p> <p> require方法接受以下几种参数的传递：</p> <ul> <li>http、fs、path等，原生模块。</li> <li>./mod或../mod，相对路径的文件模块。</li> <li>/pathtomodule/mod，绝对路径的文件模块。</li> <li>mod，非原生模块的文件模块。</li></ul></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 10,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "0bbd45af16ec775da81af8afc641f890",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js Stream(流)",
      "chapter_level_two_url": "/nodejs/nodejs-stream.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js Stream(流)</h2>\n<p>Stream 是 Node.js 中非常重要的一个模块，应用广泛。</p><p>\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\n</p><p>该抽象接口是可读、可写或是既可读又可写的，通过这些接口，我们可以和磁盘文件、套接字、HTTP请求来交互，实现数据从一个地方流动到另一个地方的功能。<br></p>\n<p>Node.js，Stream 有四种流类型：</p>\n\n<ul>\n<li><p><b>Readable</b> - 可读操作。</p></li>\n<li><p><b>Writable</b> - 可写操作。</p></li>\n<li><p><b>Duplex</b> - 可读可写操作.</p></li>\n<li><p><b>Transform</b> - 操作被写入数据，然后读出结果。</p></li>\n</ul>\n<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>\n<ul>\n<li><p><b>data</b> - 当有数据可读时触发。</p></li>\n<li><p><b>end</b> - 没有更多的数据可读时触发。</p></li>\n<li><p><b>error</b> - 在接收和写入过程中发生错误时触发。</p></li>\n<li><p><b>finish</b> - 所有数据已被写入到底层系统时触发。</p></li>\n</ul>\n<p>本教程会为大家介绍常用的流操作。</p>\n<hr>\n<h2>从流中读取数据</h2>\n<p>创建 input.txt  文件，内容如下：</p>\n<pre>W3Cschool教程官网地址：www.w3cschool.cn\n</pre>\n<p>创建 main.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\nvar data = '';\n\n// 创建可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 设置编码为 utf8。\nreaderStream.setEncoding('UTF8');\n\n// 处理流事件 --&gt; data, end, and error\nreaderStream.on('data', function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on('end',function(){\n   console.log(data);\n});\n\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n</pre>\n<p>以上代码执行结果如下：</p>\n<pre>程序执行完毕\nW3Cschool教程官网地址：www.w3cschool.cn\n</pre>\n<hr>\n<h2>写入流</h2>\n<p>创建 main.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\nvar data = 'W3Cschool教程官网地址：www.w3cschool.cn';\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data,'UTF8');\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --&gt; data, end, and error\nwriterStream.on('finish', function() {\n    console.log(\"写入完成。\");\n});\n\nwriterStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n</pre>\n<p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>\n<pre>$ node main.js \n程序执行完毕\n写入完成。\n</pre>\n<p>查看 output.txt  文件的内容：</p>\n<pre>$ cat output.txt \nW3Cschool教程官网地址：www.w3cschool.cn\n</pre>\n\n<hr><h2>管道流</h2>\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\n<p><img src=\"https://atts.w3cschool.cn/attachments/image/bVcla61\">\n</p><p>\n如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。\n</p>\n<p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p>\n<p>\n设置 input.txt 文件内容如下：</p>\n<pre>W3Cschool教程官网地址：www.w3cschool.cn\n管道流操作实例\n</pre>\n<p>创建 main.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n</pre>\n<p>代码执行结果如下：</p>\n<pre>$ node main.js \n程序执行完毕\n</pre>\n<p>查看 output.txt  文件的内容：</p>\n<pre>$ cat output.txt \nW3Cschool教程官网地址：www.w3cschool.cn\n管道流操作实例\n</pre>\n<hr>\n<h2>链式流</h2>\n<p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。</p>\n<p>接下来我们就是用管道和链式来压缩和解压文件。</p>\n<p>创建 compress.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n  \nconsole.log(\"文件压缩完成。\");\n</pre>\n\n<p>代码执行结果如下：</p>\n<pre>$ node compress.js \n文件压缩完成。\n</pre>\n<p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>\n<p>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>\n<pre>var fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n  \nconsole.log(\"文件解压完成。\");\n</pre>\n<p>代码执行结果如下：</p>\n<pre>$ node decompress.js \n文件解压完成。</pre></div></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 9,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "8f2e29c55c34193c7c3b53afbf3adb75",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js Buffer(缓冲区)",
      "chapter_level_two_url": "/nodejs/nodejs-buffer.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\"><h2>Node.js Buffer(缓冲区)</h2><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p><p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><hr><h2>创建 Buffer 类</h2><p>Node Buffer 类可以通过多种方式来创建。</p><h3>方法 1</h3><p>创建长度为 10 字节的 Buffer 实例：</p><pre>var buf = new Buffer(10);\n</pre><h3>方法 2</h3><p>通过给定的数组创建 Buffer 实例：</p><pre>var buf = new Buffer([10, 20, 30, 40, 50]);\n</pre><h3>方法 3</h3><p>通过一个字符串来创建 Buffer 实例：</p><pre>var buf = new Buffer(\"www.w3cschool.cn\", \"utf-8\");\n</pre><p>utf-8 是默认的编码方式，此外它同样支持以下编码：\"ascii\", \"utf8\", \"utf16le\", \"ucs2\", \"base64\" 和 \"hex\"。</p><hr><h2>写入缓冲区</h2><h3>语法</h3><p>写入 Node 缓冲区的语法如下所示：</p><pre><strong>buf.write(string[, offset[, length]][, encoding])</strong>\n</pre><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>string</strong> - 写入缓冲区的字符串。</p></li><li><p><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</p></li><li><p><strong>length</strong> - 写入的字节数，默认为 buffer.length</p></li><li><p><strong>encoding</strong> - 使用的编码。默认为 'utf8' 。</p></li></ul><h3>返回值</h3><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p><h3>实例</h3><pre>buf = new Buffer(256);\nlen = buf.write(\"www.w3cschool.cn\");\n\nconsole.log(\"写入字节数 : \"+  len);\n</pre><p>执行以上代码，输出结果为：</p><pre>$node main.js\n写入字节数 : 16\n</pre><hr><h2>从缓冲区读取数据</h2><h3>语法</h3><p>读取 Node 缓冲区数据的语法如下所示：</p><pre>buf.toString([encoding[,start[,end]]])\n</pre><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>encoding</strong> - 使用的编码。默认为 'utf8' 。</p></li><li><p><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</p></li><li><p><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</p></li></ul><h3>返回值</h3><p>解码缓冲区数据并使用指定的编码返回字符串。</p><h3>实例</h3><pre>buf = new Buffer(26);\nfor (var i = 0 ; i &lt; 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   // 输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n</pre><p>执行以上代码，输出结果为：</p><pre>$ node main.js\nabcdefghijklmnopqrstuvwxyz\nabcde\nabcde\nabcde\n</pre><hr><h2>将 Buffer 转换为 JSON 对象</h2><h3>语法</h3><p>将 Node Buffer 转换为 <a href=\"https://www.w3cschool.cn/javascript_guide/javascript_guide-l1232690.html\" target=\"_blank\">JSON 对象</a>的函数语法格式如下：</p><pre>buf.toJSON()\n</pre><h3>返回值</h3><p>返回 JSON 对象。</p><h3>实例</h3><pre>var buf = new Buffer('www.w3cschool.cn');\nvar json = buf.toJSON(buf);\n\nconsole.log(json);\n</pre><p>执行以上代码，输出结果为：</p><pre>{ type: 'Buffer',\n  data: [ 119, 119, 119, 46, 119, 51, 99, 115, 99, 104, 111, 111, 108, 46, 99, 110 ] }\n</pre><hr><h2>缓冲区合并</h2><h3>语法</h3><p>Node 缓冲区合并的语法如下所示：</p><pre>Buffer.concat(list[, totalLength])\n</pre><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</p></li><li><p><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</p></li></ul><h3>返回值</h3><p>返回一个多个成员合并的新 Buffer 对象。</p><h3>实例</h3><pre>var buffer1 = new Buffer('W3Cschool教程 ');\nvar buffer2 = new Buffer('www.w3cschool.cn');\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\n</pre><p>执行以上代码，输出结果为：</p><pre>buffer3 内容: W3Cschool教程 www.w3cschool.cn\n</pre><hr><h2>缓冲区比较</h2><h3>语法</h3><p>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：</p><pre>buf.compare(otherBuffer);\n</pre><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</p></li></ul><h3>返回值</h3><p>返回一个数字，表示 <strong>buf</strong> 在 <strong>otherBuffer</strong> 之前，之后或相同。</p><h3>实例</h3><pre>var buffer1 = new Buffer('ABC');\nvar buffer2 = new Buffer('ABCD');\nvar result = buffer1.compare(buffer2);\n\nif(result &lt; 0) {\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\n}else if(result == 0){\n   console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\n}else {\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\n}\n</pre><p>执行以上代码，输出结果为：</p><pre>ABC在ABCD之前\n</pre><hr><h2>拷贝缓冲区</h2><h3>语法</h3><p>Node 缓冲区拷贝语法如下所示：</p><p></p><pre>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</pre><p></p><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</p></li><li><p><strong>targetStart</strong> - 数字, 可选, 默认: 0</p></li><li><p><strong>sourceStart</strong> - 数字, 可选, 默认: 0</p></li><li><p><strong>sourceEnd</strong> - 数字, 可选, 默认: buffer.length</p></li></ul><h3>返回值</h3><p>没有返回值。</p><h3>实例</h3><pre>var buffer1 = new Buffer('ABC');\n// 拷贝一个缓冲区\nvar buffer2 = new Buffer(3);\nbuffer1.copy(buffer2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());\n</pre><p>执行以上代码，输出结果为：</p><pre>buffer2 content: ABC\n</pre><hr><h2>缓冲区裁剪</h2><p>Node 缓冲区裁剪语法如下所示：</p><pre>buf.slice([start[, end]])</pre><h3>参数</h3><p>参数描述如下：</p><ul><li><p><strong>start</strong> - 数字, 可选, 默认: 0</p></li><li><p><strong>end</strong> - 数字, 可选, 默认: buffer.length</p></li></ul><h3>返回值</h3><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p><h3>实例</h3><pre>var buffer1 = new Buffer('youj');\n// 剪切缓冲区\nvar buffer2 = buffer1.slice(0,2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());</pre><p>执行以上代码，输出结果为：</p><pre>buffer2 content: yo\n</pre><hr><h2>缓冲区长度</h2><h3>语法</h3><p>Node 缓冲区长度计算语法如下所示：</p><pre>buf.length;\n</pre><h3>返回值</h3><p>返回 Buffer 对象所占据的内存长度。</p><h3>实例</h3><pre>var buffer = new Buffer('www.w3cschool.cn');\n//  缓冲区长度\nconsole.log(\"buffer length: \" + buffer.length);\n</pre><p>执行以上代码，输出结果为：</p><pre>buffer length: 16\n</pre><hr><h2>方法参考手册</h2><p>以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：</p><table class=\"\"><tbody><tr><th>序号</th><th>方法 &amp; 描述</th></tr><tr><td>1</td><td><strong>new Buffer(size)</strong> <br>分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。</td></tr><tr><td>2</td><td><strong>new Buffer(buffer)</strong> <br>拷贝参数 buffer 的数据到 Buffer 实例。</td></tr><tr><td>3</td><td><strong>new Buffer(str[, encoding])</strong><br>分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。</td></tr><tr><td>4</td><td><strong>buf.length</strong><br>返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td></tr><tr><td>5</td><td><strong>buf.write(string[, offset[, length]][, encoding])</strong><br>根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</td></tr><tr><td>6</td><td><strong>buf.writeUIntLE(value, offset, byteLength[, noAssert])</strong><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算，例如：<br><pre>var b = new Buffer(6);\nb.writeUIntBE(0x1234567890ab, 0, 6);\n// &lt;Buffer 12 34 56 78 90 ab&gt;\n</pre>noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td>7</td><td><strong>buf.writeUIntBE(value, offset, byteLength[, noAssert])</strong><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td>8</td><td><strong>buf.writeIntLE(value, offset, byteLength[, noAssert])</strong><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td>9</td><td><strong>buf.writeIntBE(value, offset, byteLength[, noAssert])</strong><br>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，支持 48 位计算。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td></tr><tr><td>10</td><td><strong>buf.readUIntLE(offset, byteLength[, noAssert])</strong><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td>11</td><td><strong>buf.readUIntBE(offset, byteLength[, noAssert])</strong><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td>12</td><td><strong>buf.readIntLE(offset, byteLength[, noAssert])</strong><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td>13</td><td><strong>buf.readIntBE(offset, byteLength[, noAssert])</strong><br>支持读取 48 位以下的数字。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td></tr><tr><td>14</td><td><strong>buf.toString([encoding[, start[, end]]])</strong><br>根据 encoding 参数（默认是 'utf8'）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</td></tr><tr><td>15</td><td><strong>buf.toJSON()</strong><br>将 Buffer 实例转换为 JSON 对象。</td></tr><tr><td>16</td><td><strong>buf[index]</strong><br>获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td></tr><tr><td>17</td><td><strong>buf.equals(otherBuffer)</strong><br>比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td></tr><tr><td>18</td><td><strong>buf.compare(otherBuffer)</strong><br>比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td></tr><tr><td>19</td><td><strong>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</strong><br>buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td></tr><tr><td>20</td><td><strong>buf.slice([start[, end]])</strong><br>剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td></tr><tr><td>21</td><td><strong>buf.readUInt8(offset[, noAssert])</strong><br>根据指定的偏移量，读取一个有符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>22</td><td><strong>buf.readUInt16LE(offset[, noAssert])</strong><br>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td>23</td><td><strong>buf.readUInt16BE(offset[, noAssert])</strong><br>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个有符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td>24</td><td><strong>buf.readUInt32LE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>25</td><td><strong>buf.readUInt32BE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>26</td><td><strong>buf.readInt8(offset[, noAssert])</strong><br>根据指定的偏移量，读取一个 signed 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td>27</td><td><strong>buf.readInt16LE(offset[, noAssert])</strong><br>根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td>28</td><td><strong>buf.readInt16BE(offset[, noAssert])</strong><br>根据指定的偏移量，使用特殊的 endian 格式读取一个 signed 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td></tr><tr><td>29</td><td><strong>buf.readInt32LE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>30</td><td><strong>buf.readInt32BE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 signed 32 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>31</td><td><strong>buf.readFloatLE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td>32</td><td><strong>buf.readFloatBE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位浮点数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</td></tr><tr><td>33</td><td><strong>buf.readDoubleLE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>34</td><td><strong>buf.readDoubleBE(offset[, noAssert])</strong><br>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位double。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</td></tr><tr><td>35</td><td><strong>buf.writeUInt8(value, offset[, noAssert])</strong><br>根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的有符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td></tr><tr><td>36</td><td><strong>buf.writeUInt16LE(value, offset[, noAssert])</strong><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的有符号 16 位整数。若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td>37</td><td><strong>buf.writeUInt16BE(value, offset[, noAssert])</strong><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的有符号 16 位整数。若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td>38</td><td><strong>buf.writeUInt32LE(value, offset[, noAssert])</strong><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td>39</td><td><strong>buf.writeUInt32BE(value, offset[, noAssert])</strong><br>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td></tr><tr><td>40</td><td><strong>buf.writeInt8(value, offset[, noAssert])</strong></td></tr></tbody></table></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 8,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "82ce625611ae4c417baff2ee69a9eb54",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 事件",
      "chapter_level_two_url": "/nodejs/nodejs-event.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 事件</h2> <p> Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p> <p>Node.js 里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 你可以通过require(\"events\");来访问该模块。</p> 下面我们用一个简单的例子说明 EventEmitter 的用法： <pre>//event.js \nvar EventEmitter = require('events').EventEmitter; \nvar event = new EventEmitter(); \nevent.on('some_event', function() { \n    console.log('some_event occured.'); \n}); \nsetTimeout(function() { \n    event.emit('some_event'); \n}, 1000); \n</pre> <p> 运行这段代码，1秒后控制台输出了 'some_event occured'。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在1000毫秒以后向 event 对象发送事件 some_event，此时会调用 some_event 的监听器。 </p> <hr> <h2>EventEmitter介绍</h2> <p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就 是事件发射与事件监听器功能的封装。</p> <p>EventEmitter 的每个事件由一个事件名和若干个参 数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p> <p>当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作 为回调函数参数传递。</p> <p> 让我们以下面的例子解释这个过程：</p> <pre>var events = require('events'); \nvar emitter = new events.EventEmitter(); \nemitter.on('someEvent', function(arg1, arg2) { \n    console.log('listener1', arg1, arg2); \n}); \nemitter.on('someEvent', function(arg1, arg2) { \n console.log('listener2', arg1, arg2); \n}); \nemitter.emit('someEvent', 'byvoid', 1991); \n</pre> <p> 运行的结果是：</p> <pre>listener1 byvoid 1991 \nlistener2 byvoid 1991 \n</pre> <p> 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后发射了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 </p> <h3>EventEmitter常用的API</h3> <p> EventEmitter.on(event, listener)、emitter.addListener(event, listener) 为指定事件注册一个监听器，接收一个字符串 event 和一个回调函数 listener。</p> <p> </p><pre>server.on('connection', function (stream) {\n  console.log('someone connected!');\n});\n</pre> EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传 递若干可选参数到事件监听器的参数表。 <p></p> <p> EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 </p> <pre>server.once('connection', function (stream) {\n  console.log('Ah, we have our first user!');\n});\n</pre> <p> EventEmitter.removeListener(event, listener) 移除指定事件的某个监听 器，listener 必须是该事件已经注册过的监听器。 </p> <pre>var callback = function(stream) {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n</pre> <p> EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定 event，则移除指定事件的所有监听器。 </p> <hr> <h2>error 事件</h2> <p> EventEmitter 定义了一个特殊的事件 error，它包含了\"错误\"的语义，我们在遇到 异常的时候通常会发射 error 事件。</p> <p>当 error 被发射时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈。</p> <p>我们一般要为会发射 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p> <pre>var events = require('events'); \nvar emitter = new events.EventEmitter(); \nemitter.emit('error'); \n</pre> <p> 运行时会显示以下错误：</p> <pre>node.js:201 \nthrow e; // process.nextTick error, or 'error' event on first tick \n^ \nError: Uncaught, unspecified 'error' event. \nat EventEmitter.emit (events.js:50:15) \nat Object. (/home/byvoid/error.js:5:9) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40) \n</pre> <hr> <h2>继承 EventEmitter</h2> <p> 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p> <p> 为什么要这样做呢？原因有两点：</p> <p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。</p> <p>其次JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 7,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "4cd16d4108dd582026f43816a84f367e",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 事件循环",
      "chapter_level_two_url": "/nodejs/nodejs-event-loop.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js 事件循环</h2>\n<p>Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</p>\n<p>Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</p>\n<p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>\n<p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>\n<hr>\n<h2>事件驱动程序</h2>\n<p>\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n</p><p>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）\n</p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。<p></p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/event_loop.jpg\">\n<p>\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。\n</p>\n<p>\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>\n<pre>// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n</pre>\n<p>以下程序绑定事件处理程序：</p>\n<pre>// 绑定事件及事件的处理程序\neventEmitter.on('eventName', eventHandler);\n</pre>\n<p>我们可以通过程序触发事件：</p>\n<pre>// 触发事件\neventEmitter.emit('eventName');</pre>\n<h3>实例</h3>\n创建 main.js 文件，代码如下所示：<p></p>\n<pre>// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n\n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log('连接成功。');\n  \n   // 触发 data_received 事件 \n   eventEmitter.emit('data_received');\n}\n\n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n \n// 使用匿名函数绑定 data_received 事件\neventEmitter.on('data_received', function(){\n   console.log('数据接收成功。');\n});\n\n// 触发 connection 事件 \neventEmitter.emit('connection');\n\nconsole.log(\"程序执行完毕。\");\n</pre>\n\n<p>接下来让我们执行以上代码：</p>\n<pre>$ node main.js\n连接成功。\n数据接收成功。\n程序执行完毕。\n</pre>\n\n<hr>\n<h2>Node 应用程序是如何工作的？</h2>\n<p>\n在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数，\n回调函数接收错误对象作为第一个参数。\n</p>\n<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p>\n<pre>W3Cschool教程官网地址：www.w3cschool.cn\n</pre>\n<p>创建 main.js 文件，代码如下：</p>\n<pre>var fs = require(\"fs\");\n\nfs.readFile('input.txt', function (err, data) {\n   if (err){\n      console.log(err.stack);\n      return;\n   }\n   console.log(data.toString());\n});\nconsole.log(\"程序执行完毕\");</pre>\n<p>\n以上程序中 fs.readFile() 是异步函数用于读取文件。\n如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>\n<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>\n<p>执行以上代码，执行结果如下：</p>\n<pre>程序执行完毕\nW3Cschool教程官网地址：www.w3cschool.cn\n\n</pre>\n<p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>\n<pre>程序执行完毕\nError: ENOENT, open 'input.txt'\n</pre>\n<p>因为文件 input.txt 不存在，所以输出了错误信息。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\n\t\t\t\n\t\t\t</div>\n\t\t</div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 6,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e8f4adba29db7fe7f0ac0b7a7b2a390f",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 回调函数",
      "chapter_level_two_url": "/nodejs/nodejs-callback.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js 回调函数</h2>\n<p>Node.js 异步编程的直接体现就是回调。</p>\n<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>\n<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>\n\n<p>\n例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>\n<hr>\n<h2>阻塞代码实例</h2>\n<p>创建一个文件 input.txt ，内容如下：</p>\n<pre>W3Cschool教程官网地址：www.w3cschool.cn</pre>\n<p>创建 main.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\n\nvar data = fs.readFileSync('input.txt');\n\nconsole.log(data.toString());\nconsole.log(\"程序执行结束!\");\n</pre>\n<p>以上代码执行结果如下：</p>\n<pre>$ node main.js\nW3Cschool教程官网地址：www.w3cschool.cn\n\n程序执行结束!\n</pre>\n<hr>\n<h2>非阻塞代码实例</h2>\n\n<p>创建一个文件 input.txt ，内容如下：</p>\n<pre>W3Cschool教程官网地址：www.w3cschool.cn</pre>\n<p>创建 main.js 文件, 代码如下：</p>\n<pre>var fs = require(\"fs\");\n\nfs.readFile('input.txt', function (err, data) {\n    if (err) return console.error(err);\n    console.log(data.toString());\n});\n\nconsole.log(\"程序执行结束!\");\n</pre>\n<p>以上代码执行结果如下：</p>\n<pre>$ node main.js\n程序执行结束!\nW3Cschool教程官网地址：www.w3cschool.cn\n\n</pre>\n<p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。\n第二个实例我们呢不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>\n<p>因此，阻塞按是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>\n\t\t\t\n\t\t\t\n\t\t\t</div>\n\t\t</div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 5,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "2e4da7af5ce77094fc5dd7860dd9fb17",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js REPL(交互式解释器)",
      "chapter_level_two_url": "/nodejs/nodejs-repl.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js REPL(交互式解释器)</h2>\n<p>Node.js REPL(Read Eval Print Loop:交互式解释器) \n表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p><p>REPL 的交互式的编程环境可以实时的验证你所编写的代码，非常适合于验证 Node.js 和 JavaScript 的相关 API。</p>\n<p>Node 自带了交互式解释器，可以执行以下任务：</p>\n<ul>\n<li><p><b>读取</b> - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</p></li>\n<li><p><b>执行</b> - 执行输入的数据结构</p></li>\n<li><p><b>打印</b> - 输出结果</p></li>\n<li><p><b>循环</b> - 循环操作以上步骤直到用户两次按下 <b>ctrl-c</b> 按钮退出。</p></li>\n</ul>\n<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>\n<p>开始学习 REPL</p>\n<p>我们可以输入以下命令来启动 Node 的终端：</p>\n<pre>$ node\n&gt; \n</pre>\n<p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>\n<h3>简单的表达式运算</h3>\n<p>接下来让我们在 Node.js REPL 的命令行窗口中执行简单的数学运算：</p>\n<pre>$ node\n&gt; 1 +4\n5\n&gt; 5 / 2\n2.5\n&gt; 3 * 6\n18\n&gt; 4 - 1\n3\n&gt; 1 + ( 2 * 3 ) - 4\n3\n&gt;\n</pre>\n<h3>使用变量</h3>\n<p>你可以将数据存储在变量中，并在你需要的使用它。</p>\n<p>变量声明需要使用 <b>var</b> 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>\n<p>使用 <b>var</b> 关键字的变量可以使用 console.log() 来输出变量。</p>\n<pre>$ node\n&gt; x = 10\n10\n&gt; var y = 10\nundefined\n&gt; x + y\n20\n&gt; console.log(\"Hello World\")\nHello World\nundefined\n&gt; console.log(\"www.w3cschool.cn\")\nwww.w3cschool.cn\nundefined\n</pre>\n<h3>多行表达式</h3>\n<p>\nNode REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>\n\n<pre>$ node\n&gt; var x = 0\nundefined\n&gt; do {\n... x++;\n... console.log(\"x: \" + x);\n... } while ( x &lt; 5 );\nx: 1\nx: 2\nx: 3\nx: 4\nx: 5\nundefined\n&gt;\n</pre>\n<p><b>...</b> 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>\n<h3>下划线(_)变量</h3>\n<p>你可以使用下划线(_)获取表达式的运算结果：</p>\n<pre>$ node\n&gt; var x = 10\nundefined\n&gt; var y = 20\nundefined\n&gt; x + y\n30\n&gt; var sum = _\nundefined\n&gt; console.log(sum)\n30\nundefined\n&gt;\n</pre>\n<hr>\n<h2>REPL 命令</h2>\n<ul>\n<li><p><b>ctrl + c</b> - 退出当前终端。</p></li>\n<li><p><b>ctrl + c 按下两次</b> - 退出 Node REPL。</p></li>\n<li><p><b>ctrl + d</b> - 退出 Node REPL.</p></li>\n<li><p><b>向上/向下 键</b> - 查看输入的历史命令</p></li>\n<li><p><b>tab 键</b> - 列出当前命令</p></li>\n<li><p><b>.help</b> - 列出使用命令</p></li>\n<li><p><b>.break</b> - 退出多行表达式</p></li>\n<li><p><b>.clear</b> - 退出多行表达式</p></li>\n<li><p><b>.save <i>filename</i></b> - 保存当前的 Node REPL 会话到指定文件</p></li>\n<li><p><b>.load <i>filename</i></b> - 载入当前 Node REPL 会话的文件内容。</p></li>\n</ul>\n<hr>\n<h2>停止 REPL</h2>\n<p>前面我们已经提到按下两次 <b>ctrl + c</b> 建就能退出 REPL:</p>\n<pre>$ node\n&gt;\n(^C again to quit)\n&gt;\n</pre>\n<hr><h2>Gif 实例演示</h2>\n<p>\n接下来我们通过 Gif 图为大家演示实例操作：</p>\n<img src=\"https://atts.w3cschool.cn/attachments/image/20170904/1504511414179845.gif\" alt=\"REPL\" style=\"max-width:100%;\">\t\t\t\n\t\t\t\n\t\t\t</div>\n\t\t</div><h2>相关阅读</h2><p><a href=\"https://www.w3cschool.cn/javascript_guide/javascript_guide-9hey2691.html\" target=\"_blank\">JavaScript console对象</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 10,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "26189b9593c3c5b6166862348c652ab2",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "2021年web前端工资一般多少？哪类人适合做web前端?",
      "chapter_level_two_url": "/article/84092447.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 9,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "56e3b5d255f73baca1c47b3559435975",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "web前端开发的三大主流框架是什么？",
      "chapter_level_two_url": "/article/8122821.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 8,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "db2b8779917799478dda92011a2e1388",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "web前后端交互方式有哪些?",
      "chapter_level_two_url": "/article/16219373.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 7,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "02ff1b81cd6c96500cf678d390c6a920",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "WEB 前端开发工程师是什么？",
      "chapter_level_two_url": "/article/97846991.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 6,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "a2530779bc68195d9af794a306f4e433",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "HTML编辑器有哪些，HTML编辑器推荐",
      "chapter_level_two_url": "/article/5a8aca22a0c87d.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 5,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "79af3bf5e73cafa41cc28a9b966a84bf",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "初学者必看的web前端开发学习路线,干货满满！",
      "chapter_level_two_url": "/article/49146914.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 4,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "c93437e8faf4e8eb20a92caa7c9bf7cf",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "零基础自学前端到达到什么水平才能找工作？",
      "chapter_level_two_url": "/article/51125035.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 3,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "3498e1ada6749a1b62f279ee1a965d3d",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "Web 前端开发的就业前景好吗？适合的学习人群有哪些？",
      "chapter_level_two_url": "/article/65882301.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 2,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "2daf7fc885ddefd45799e18d43c0e152",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "2021年快速成为前端工程师，各个阶段必须掌握的基本技能汇总",
      "chapter_level_two_url": "/article/6537430.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 7,
      "chapter_level_one_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关文章",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "02ca7f24f53e68c48f831bf9e6ecd5ab",
      "chapter_level_two_parent_id": "9d36daea6c984d4939c4419a1f6bcefa",
      "chapter_level_two_name": "W3Cschool前端开发入门学习路线2021",
      "chapter_level_two_url": "/article/63914971.html",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 5,
      "parent_sort_index": 6,
      "chapter_level_one_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关课程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "444f38531802f05cf4407ceae9f68696",
      "chapter_level_two_parent_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_two_name": "Canvas入门到项目实战",
      "chapter_level_two_url": "/minicourse/play/hzjed?fcode=tutorial-nodejs",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 4,
      "parent_sort_index": 6,
      "chapter_level_one_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关课程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "6d0a0e224c97bbd5e01c770743683339",
      "chapter_level_two_parent_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_two_name": "小白学前端：通俗易懂的Ajax教程",
      "chapter_level_two_url": "/minicourse/play/ajax_txy?fcode=tutorial-nodejs",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 3,
      "parent_sort_index": 6,
      "chapter_level_one_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关课程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "fadef83868d2d499ab12497a7b4bf8cb",
      "chapter_level_two_parent_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_two_name": "小白学前端：Vue.js 2.0进阶",
      "chapter_level_two_url": "/minicourse/play/vuejs_txy_base?fcode=tutorial-nodejs",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 2,
      "parent_sort_index": 6,
      "chapter_level_one_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关课程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e40482e1d17a85955377c8ca8b35901e",
      "chapter_level_two_parent_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_two_name": "jQuery从入门到精通",
      "chapter_level_two_url": "/minicourse/play/jquery2_my?fcode=tutorial-nodejs",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 6,
      "chapter_level_one_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关课程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "f3c7186b3b44abeeb4b9bd2abdb7b613",
      "chapter_level_two_parent_id": "f9c3cdf0269ab285b5d83b86cecc8373",
      "chapter_level_two_name": "JavaScript零基础入门",
      "chapter_level_two_url": "/minicourse/play/javascript_vip_my?fcode=tutorial-nodejs",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 5,
      "parent_sort_index": 5,
      "chapter_level_one_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "44439c3b2bf0f0cdff4d270b8eaf849b",
      "chapter_level_two_parent_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_two_name": "CoffeeScript 教程",
      "chapter_level_two_url": "/coffeescript/",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 4,
      "parent_sort_index": 5,
      "chapter_level_one_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "95b66f29b8b3a0207d4343e7f11cdc4b",
      "chapter_level_two_parent_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_two_name": "jQuery EasyUI 教程",
      "chapter_level_two_url": "/jqueryeasyui/",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 3,
      "parent_sort_index": 5,
      "chapter_level_one_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "d81c038df01b0e52c33032528fd45952",
      "chapter_level_two_parent_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_two_name": "Meteor 教程",
      "chapter_level_two_url": "/discovermeteor/",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 2,
      "parent_sort_index": 5,
      "chapter_level_one_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "ca08480e2526f1e97e75dfab94eda9cb",
      "chapter_level_two_parent_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_two_name": "Ember.js 参考文档",
      "chapter_level_two_url": "/emberjs_guide/",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 5,
      "chapter_level_one_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "318dff0fbda5560877cb052afdf25d0b",
      "chapter_level_two_parent_id": "d9e0bc6fb0580d43866364c06954f0cc",
      "chapter_level_two_name": "Node.js 教程",
      "chapter_level_two_url": "/nodejs/",
      "book_content": ""
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 4,
      "chapter_level_one_id": "551004dd13b4ef25a3346c3d7e4e2b1a",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 版本更新",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "aa0b51cc681579a3f616e56692f42347",
      "chapter_level_two_parent_id": "551004dd13b4ef25a3346c3d7e4e2b1a",
      "chapter_level_two_name": "Node.js v8.3.0 发布，升级 V8 引擎至 6.0 版本",
      "chapter_level_two_url": "/nodejs/nodejs-1fvz28ij.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><p><b>Node.js v8.3.0</b>已发布，在该版本中，已将V8引擎升级到6.0版本，性能有了大幅度的改进。有关性能差异的更多详细信息，<a href=\"https://medium.com/the-node-js-collection/get-ready-a-new-v8-is-coming-node-js-performance-is-changing-46a63d6da4de\" rel=\"external nofollow\" target=\"_blank\">点击查看详情</a>。</p><p>除此之外，还带来了循环遍历对象，删除对象键，函数绑定和对象创建等实用的功能。下面W3C小编就给大家带来此次更新的一些主要内容。</p><ul><li>DNS</li><li>现在支持独立的 DNS 解析程序实例, 并支持取消相应的请求。<a href=\"https://github.com/nodejs/node/pull/14518\" rel=\"external nofollow\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">#14518</a><br></li><li>N-API</li><li>错误处理的多个N-API函数已更改为支持分配错误代码。<a href=\"https://github.com/nodejs/node/pull/13988\" rel=\"external nofollow\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">#13988</a><br></li><li>REPL</li><li>对require()的自动完成支持已经改进。<a href=\"https://github.com/nodejs/node/pull/14409\" rel=\"external nofollow\" target=\"_blank\">#14409</a></li><li>Utilities</li><li>WHATWG编码标准 (TextDecoder 和 TextEncoder) 作为一个实验性的特点被实现。<a href=\"https://github.com/nodejs/node/pull/13644\" rel=\"external nofollow\" target=\"_blank\">#13644</a></li><li>增加了新collaborators</li><li><a href=\"https://github.com/XadillaX\" rel=\"external nofollow\" target=\"_blank\">XadillaX</a> – Khaidi Chu<a href=\"https://github.com/gabrielschulhof\" rel=\"external nofollow\" target=\"_blank\">gabrielschulhof</a> – Gabriel Schulhof</li></ul><p>相关下载地址：</p><ul><li><a href=\"https://github.com/nodejs/node/archive/v8.3.0.zip\" rel=\"external nofollow\" target=\"_blank\">Source code (zip)</a></li><li><a href=\"https://github.com/nodejs/node/archive/v8.3.0.tar.gz\" rel=\"external nofollow\" target=\"_blank\">Source code (tar.gz)</a></li><li><a target=\"_blank\" href=\"https://nodejs.org/en/download/\" rel=\"external nofollow\">https://nodejs.org/en/download/</a></li></ul><p>Node.js是一个基于 <a href=\"https://developers.google.com/v8/\" rel=\"external nofollow\" target=\"_blank\">Chrome V8 引擎</a>的JavaScript运行时。Node.js使用高效、轻量级的事件驱动、非阻塞I/O模型。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 3,
      "chapter_level_one_id": "f0ae7574ff0483b8c849f37dda06a9af",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 相关教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "8eb41eab93eeb59e7763f03206d76eb1",
      "chapter_level_two_parent_id": "f0ae7574ff0483b8c849f37dda06a9af",
      "chapter_level_two_name": "Node.js 拓展教程",
      "chapter_level_two_url": "//www.w3cschool.cn/nodejs/node-js-tutorial.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \">Node.js是一个编写网络系统和Web应用程序的平台，是围绕事件驱动的非阻塞编程模型构建的。<br>运行Node.js和“Hello World!”。<br><p>创建一个名为hello.js的文件：</p><p></p><pre><code><span>/**\n  * comment.\n  */</span>\nconsole.log(<span>\"Hello World!\"</span>);</code></pre><p></p><p>现在，我们可以从命令行执行这个文件<br></p><p></p><pre>node hello.js</pre>你可以看到以下输出：<br><p></p><p><span><span style=\"color:#e33737;\">Hello World!</span></span><br></p><h2><span style=\"line-height: 1.7;\">变量</span></h2><p></p><p>变量在JavaScript中使用var关键字定义。例如，以下代码段创建一个变量foo并将其记录到控制台。</p><p></p><pre><code><span><span>var</span></span> myData = 123; \nconsole.log(myData);</code></pre><p></p><p>上面的代码生成以下结果。<br></p><p><img src=\"https://atts.w3cschool.cn/attachments/day_170107/201701071457266256.PNG\" alt=\"结果\"><br>JavaScript运行时有机会定义一些我们可以在代码中使用的全局变量。其中一个是控制台对象。控制台对象包含一个成员函数（log），它接受任意数量的参数并将它们打印到控制台。<br></p><p></p><h2>第一个Web服务器</h2>输入并保存以下内容到名为web.js的文件中：<p></p><p></p><pre><code><span><span>var</span></span> http = require(<span>\"http\"</span>);\n<span>/</span><span>*</span><span>f</span><span>r</span><span>o</span><span>m</span><span> www.w3cschool.cn</span><span>*</span><span>/</span>\nfunction process_request(req, res) {\n     <span><span>var</span></span> body = <span>'Thanks for calling!\\n'</span>;\n     <span><span>var</span></span> content_length =  body.length ;\n     res.writeHead(200, {\n         <span>'Content-Length'</span>: content_length,\n         <span>'Content-Type'</span>: <span>'text/plain'</span>\n     });\n     res.end(body);\n}\n<span><span>var</span></span> s = http.createServer(process_request);\ns.listen(8080);</code></pre><p>要运行它，只需键入</p><p></p><pre>node web.js</pre>你的计算机现在有一个在端口8080上运行的Web服务器。我们可以在web浏览器中输入http://localhost:8080。<br><p>或使用：</p><p></p><pre>curl -i http://localhost:8080</pre>现在，你应该看到类似以下的内容：<br><p></p><p></p><pre>HTTP/1.1 200 OK\nContent-Length: 20\nContent-Type: text/plain\nDate: Tue, 15 Feb 2013 03:05:08 GMT\nConnection: keep-alive\n\nThanks for calling!</pre><h2>curl</h2>我们可以通过访问http://curl.haxx.se/download.html并查找“Win32 - Generic”部分下载curl的Windows二进制文件。下载一个高亮显示的二进制文件，最好是支持SSL和SSH，解压缩它，并将curl.exe放在PATH或用户目录中。<br><p>要启动它，只需在命令提示符或PowerShell中键入：</p><p></p><pre>C:\\Users\\abc\\curl --help</pre><h2>Wget</h2>wget是curl的一个很好的选择。我们可以从http://users.ugent.be/~bpuype/wget/下载。<br>要了解详情，可看帮助：<br><p></p><p></p><p></p><pre>C:\\Users\\abc\\wget  --help</pre><h2>注意</h2>要停止服务器运行，只需按Ctrl+C，足以清理一切并进行正确关闭。<br>要调试，只需在程序名称前添加调试标志：<br><p></p><p></p><p></p><pre>node debug web.js</pre><br><p></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 37,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e0580a8a76676eeb92aa20bf17534633",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js ZLIB",
      "chapter_level_two_url": "/nodejs/dyfg1iuf.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Zlib</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 文档</code></pre><p>本节介绍Node.js中ZLIB模块的使用，你可以通过以下方式访问这个模块：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var zlib = require('zlib');</code></pre><p>这个模块提供了对Gzip/Gunzip, Deflate/Inflate, 和 DeflateRaw/InflateRaw类的绑定。每个类都有相同的参数和可读/写的流。 </p><h2 class=\"head2\">例子</h2><p>压缩/解压缩一个文件，可以通过倒流（piping）一个fs.ReadStream到zlib流里来，再到一个fs.fs.WriteStream：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var gzip = zlib.createGzip();\nvar fs = require('fs');\nvar inp = fs.createReadStream('input.txt');\nvar out = fs.createWriteStream('input.txt.gz');\n\ninp.pipe(gzip).pipe(out);</code></pre><p>一步压缩/解压缩数据可以通过一个简便方法来实现。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var input = '.................................';\nzlib.deflate(input, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString('base64'));\n  }\n});\n\nvar buffer = new Buffer('eJzT0yMAAGTvBe8=', 'base64');\nzlib.unzip(buffer, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString());\n  }\n});</code></pre><p>要在一个HTTP客户端或服务器中使用这个模块，可以在请求时使用<a rel=\"nofollow\" href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\" target=\"_blank\">accept-encoding</a>，响应时使用<a rel=\"nofollow\" href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\" target=\"_blank\">content-encoding</a>头。</p><p><strong>注意: 这些例子只是简单展示了基本概念。</strong>Zlib编码可能消耗非常大，并且结果可能要被缓存。更多使用 zlib 相关的速度/内存/压缩的权衡选择细节参见后面的<a href=\"#zlib_memory_usage_tuning\">Memory Usage Tuning</a>。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// client request example\nvar zlib = require('zlib');\nvar http = require('http');\nvar fs = require('fs');\nvar request = http.get({ host: 'izs.me',\n                         path: '/',\n                         port: 80,\n                         headers: { 'accept-encoding': 'gzip,deflate' } });\nrequest.on('response', function(response) {\n  var output = fs.createWriteStream('izs.me_index.html');\n\n  switch (response.headers['content-encoding']) {\n    // or, just use zlib.createUnzip() to handle both cases\n    case 'gzip':\n      response.pipe(zlib.createGunzip()).pipe(output);\n      break;\n    case 'deflate':\n      response.pipe(zlib.createInflate()).pipe(output);\n      break;\n    默认：\n      response.pipe(output);\n      break;\n  }\n});\n\n// server example\n// Running a gzip operation on every request is quite expensive.\n// It would be much more efficient to cache the compressed buffer.\nvar zlib = require('zlib');\nvar http = require('http');\nvar fs = require('fs');\nhttp.createServer(function(request, response) {\n  var raw = fs.createReadStream('index.html');\n  var acceptEncoding = request.headers['accept-encoding'];\n  if (!acceptEncoding) {\n    acceptEncoding = '';\n  }\n\n  // Note: this is not a conformant accept-encoding parser.\n  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n  if (acceptEncoding.match(/\\bdeflate\\b/)) {\n    response.writeHead(200, { 'content-encoding': 'deflate' });\n    raw.pipe(zlib.createDeflate()).pipe(response);\n  } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n    response.writeHead(200, { 'content-encoding': 'gzip' });\n    raw.pipe(zlib.createGzip()).pipe(response);\n  } else {\n    response.writeHead(200, {});\n    raw.pipe(response);\n  }\n}).listen(1337);</code></pre><h2 class=\"head2\">zlib.createGzip([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_gzip\">Gzip</a>对象。</p><h2 class=\"head2\">zlib.createGunzip([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_gunzip\">Gunzip</a>对象。</p><h2 class=\"head2\">zlib.createDeflate([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_deflate\">Deflate</a>对象。</p><h2 class=\"head2\">zlib.createInflate([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_inflate\">Inflate</a>对象。</p><h2 class=\"head2\">zlib.createDeflateRaw([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_deflateraw\">DeflateRaw</a>对象。</p><h2 class=\"head2\">zlib.createInflateRaw([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_inflateraw\">InflateRaw</a>对象。</p><h2 class=\"head2\">zlib.createUnzip([options])</h2><p>根据参数<a href=\"#zlib_options\">options</a>返回一个新的<a href=\"#zlib_class_zlib_unzip\">Unzip</a>对象。</p><h2 class=\"head2\">Class: zlib.Zlib</h2><p>这个类未被<code>zlib</code>模块导出。之所以写在这，是因为这是压缩/解压缩类的基类。</p><h3>zlib.flush([kind], callback)</h3><p>参数<code>kind</code>默认为<code>zlib.Z_FULL_FLUSH</code>。</p><p>刷入缓冲数据。不要轻易调用这个方法，过早的刷会对压缩算法产生负面影响。</p><h3>zlib.params(level, strategy, callback)</h3><p>动态更新压缩基本和压缩策略。仅对deflate算法有效。</p><h3>zlib.reset()</h3><p>重置压缩/解压缩为默认值。仅适用于inflate和deflate算法。</p><h2 class=\"head2\">Class: zlib.Gzip</h2><p>使用gzip压缩数据。</p><h2 class=\"head2\">Class: zlib.Gunzip</h2><p>使用gzip解压缩数据。</p><h2 class=\"head2\">Class: zlib.Deflate</h2><p>使用deflate压缩数据。</p><h2 class=\"head2\">Class: zlib.Inflate</h2><p>解压缩deflate流。</p><h2 class=\"head2\">Class: zlib.DeflateRaw</h2><p>使用deflate压缩数据，不需要拼接zlib头。</p><h2 class=\"head2\">Class: zlib.InflateRaw</h2><p>解压缩一个原始deflate流。</p><h2 class=\"head2\">Class: zlib.Unzip</h2><p>通过自动检测头解压缩一个Gzip-或Deflate-compressed流。</p><h2 class=\"head2\">简便方法</h2><p>所有的这些方法第一个参数为字符串或缓存，第二个可选参数可以供zlib类使用，回调函数为<code>callback(error, result)</code>。</p><p>每个方法都有一个<code>*Sync</code>伴随方法，它接收相同参数，不过没有回调。</p><h2 class=\"head2\">zlib.deflate(buf[, options], callback)</h2><h2 class=\"head2\">zlib.deflateSync(buf[, options])</h2><p>使用Deflate压缩一个字符串。</p><h2 class=\"head2\">zlib.deflateRaw(buf[, options], callback)</h2><h2 class=\"head2\">zlib.deflateRawSync(buf[, options])</h2><p>使用DeflateRaw压缩一个字符串。</p><h2 class=\"head2\">zlib.gzip(buf[, options], callback)</h2><h2 class=\"head2\">zlib.gzipSync(buf[, options])</h2><p>使用Gzip压缩一个字符串。</p><h2 class=\"head2\">zlib.gunzip(buf[, options], callback)</h2><h2 class=\"head2\">zlib.gunzipSync(buf[, options])</h2><p>使用Gunzip解压缩一个原始的Buffer。</p><h2 class=\"head2\">zlib.inflate(buf[, options], callback)</h2><h2 class=\"head2\">zlib.inflateSync(buf[, options])</h2><p>使用Inflate解压缩一个原始的Buffer。</p><h2 class=\"head2\">zlib.inflateRaw(buf[, options], callback)</h2><h2 class=\"head2\">zlib.inflateRawSync(buf[, options])</h2><p>使用InflateRaw解压缩一个原始的Buffer。</p><h2 class=\"head2\">zlib.unzip(buf[, options], callback)</h2><h2 class=\"head2\">zlib.unzipSync(buf[, options])</h2><p>使用Unzip解压缩一个原始的Buffer。</p><h2 class=\"head2\">Options</h2><p>每个类都有一个选项对象。所有选项都是可选的。</p><p>注意：某些选项仅在压缩时有用，解压缩时会被忽略。</p><ul><li>flush (默认：<code>zlib.Z_NO_FLUSH</code>)</li><li>chunkSize (默认：16*1024)</li><li>windowBits</li><li>level (仅压缩有效)</li><li>memLevel (仅压缩有效)</li><li>strategy (仅压缩有效)</li><li>dictionary (仅 deflate/inflate 有效, 默认为空字典)</li></ul><p>参见<code>deflateInit2</code>和<code>inflateInit2</code>的描述，它们位于<a rel=\"nofollow\" href=\"http://zlib.net/manual.html#Advanced\" target=\"_blank\">http://zlib.net/manual.html#Advanced</a>。</p><h2 class=\"head2\">使用内存调优</h2><p>来自<code>zlib/zconf.h</code>，修改为node's的用法:</p><p>deflate的内存需求（单位：字节）：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre><p>windowBits=15的128K加memLevel = 8的128K （缺省值），加其他对象的若干KB。</p><p>例如，如果你想减少默认的内存需求（从256K减为128k），设置选项：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ windowBits: 14, memLevel: 7 }</code></pre><p>当然这通常会降低压缩等级。</p><p>inflate的内存需求（单位：字节）：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">1 &lt;&lt; windowBits</code></pre><p>windowBits=15(默认值)32K 加其他对象的若干KB。</p><p>这是除了内部输出缓冲外chunkSize的大小，默认为16K。</p><p>影响zlib的压缩速度最大因素为<code>level</code>压缩级别。<code>level</code>越大，压缩率越高，速度越慢，<code>level</code>越小，压缩率越小，速度会更快。</p><p>通常来说，使用更多的内存选项，意味着node必须减少对zlib掉哟过，因为可以在一个<code>write</code>操作里可以处理更多的数据。所以，这是另一个影响速度和内存使用率的因素，</p><h2 class=\"head2\">常量</h2><p>所有常量定义在zlib.h ，也定义在<code>require('zlib')</code> 。</p><p>通常的操作，基本用不到这些常量。写到文档里是想你不会对他们的存在感到惊讶。这个章节基本都来自<a rel=\"nofollow\" href=\"http://zlib.net/manual.html#Constants\" target=\"_blank\">zlibdocumentation</a>。更多细节参见<a rel=\"nofollow\" href=\"http://zlib.net/manual.html#Constants\" target=\"_blank\">http://zlib.net/manual.html#Constants</a>。</p><p>允许flush的值：</p><ul><li><code>zlib.Z_NO_FLUSH</code></li><li><code>zlib.Z_PARTIAL_FLUSH</code></li><li><code>zlib.Z_SYNC_FLUSH</code></li><li><code>zlib.Z_FULL_FLUSH</code></li><li><code>zlib.Z_FINISH</code></li><li><code>zlib.Z_BLOCK</code></li><li><code>zlib.Z_TREES</code></li></ul><p>压缩/解压缩函数的返回值。负数代表错误，正数代表特殊但正常的事件：</p><ul><li><code>zlib.Z_OK</code></li><li><code>zlib.Z_STREAM_END</code></li><li><code>zlib.Z_NEED_DICT</code></li><li><code>zlib.Z_ERRNO</code></li><li><code>zlib.Z_STREAM_ERROR</code></li><li><code>zlib.Z_DATA_ERROR</code></li><li><code>zlib.Z_MEM_ERROR</code></li><li><code>zlib.Z_BUF_ERROR</code></li><li><code>zlib.Z_VERSION_ERROR</code></li></ul><p>压缩级别：</p><ul><li><code>zlib.Z_NO_COMPRESSION</code></li><li><code>zlib.Z_BEST_SPEED</code></li><li><code>zlib.Z_BEST_COMPRESSION</code></li><li><code>zlib.Z_DEFAULT_COMPRESSION</code></li></ul><p>压缩策略：</p><ul><li><code>zlib.Z_FILTERED</code></li><li><code>zlib.Z_HUFFMAN_ONLY</code></li><li><code>zlib.Z_RLE</code></li><li><code>zlib.Z_FIXED</code></li><li><code>zlib.Z_DEFAULT_STRATEGY</code></li></ul><p>data_type字段的可能值：</p><ul><li><code>zlib.Z_BINARY</code></li><li><code>zlib.Z_TEXT</code></li><li><code>zlib.Z_ASCII</code></li><li><code>zlib.Z_UNKNOWN</code></li></ul><p>deflate的压缩方法：</p><ul><li><code>zlib.Z_DEFLATED</code></li></ul><p>初始化zalloc, zfree, opaque：</p><ul><li><code>zlib.Z_NULL</code></li></ul></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 36,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "61507ceb2eb6662293b130ad4292aaa8",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 虚拟机",
      "chapter_level_two_url": "/nodejs/p7mf1iud.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>虚拟机</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>本节介绍了Node.js的虚拟机（VM）模块，该模块提供了用于在V8虚拟机上下文中编译和运行代码的API。<br></p><p>可以通过以下方法访问该模块：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var vm = require('vm');</code></pre><p>JavaScript 可以立即编译立即执行，也可以编译，保存，之后再运行。</p><h2 class=\"head2\">vm.runInThisContext(code[, options])</h2><p><code>vm.runInThisContext()</code>对参数<code>code</code>编译，运行并返回结果。运行的代码没有权限访问本地作用域（local scope），但是可以访问全局对象。</p><p>使用<code>vm.runInThisContext</code>和<code>eval</code>方法运行同样代码的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var localVar = 'initial value';\n\nvar vmResult = vm.runInThisContext('localVar = \"vm\";');\nconsole.log('vmResult: ', vmResult);\nconsole.log('localVar: ', localVar);\n\nvar evalResult = eval('localVar = \"eval\";');\nconsole.log('evalResult: ', evalResult);\nconsole.log('localVar: ', localVar);\n\n// vmResult: 'vm', localVar: 'initial value'\n// evalResult: 'eval', localVar: 'eval'</code></pre><p><code>vm.runInThisContext</code>没有访问本地作用域，所以没有改变<code>localVar</code>。<code>eval</code>范围了本地作用域，所以改变了<code>localVar</code>。</p><p><code>vm.runInThisContext</code>用起来很像间接调用<code>eval</code>，比如<code>(0,eval)('code')</code>。但是，<code>vm.runInThisContext</code>也包含以下选项：</p><ul><li><code>filename</code>: 允许更改显示在站追踪（stack traces）的文件名。</li><li><code>displayErrors</code>: 是否在stderr上打印错误，抛出异常的代码行高亮显示。会捕获编译时的语法错误，和执行时抛出的错误。默认为<code>true</code>。</li><li><code>timeout</code>: 中断前代码执行的毫秒数。如果执行终止，将会抛出错误。</li></ul><h2 class=\"head2\">vm.createContext([sandbox])</h2><p>如果参数<code>sandbox</code>不为空，调用<code>vm.runInContext</code>或<code>script.runInContext</code>时可以调用沙箱的上下文。以此方式运行的脚本，<code>sandbox</code>是全局对象，它保留自己的属性同时拥有标准全局对象（<a rel=\"nofollow\" href=\"http://es5.github.io/#x15.1\" target=\"_blank\">global object</a>）拥有的内置对象和函数。</p><p>如果参数sandbox对象为空，返回一个可用的新且空的上下文相关的沙盒对象。</p><p>这个函数对于创建一个可运行多脚本的沙盒非常有用。比如，在模拟浏览器的时候可以使用该函数创建一个用于表示window全局对象的沙箱，并将所有<code>&lt;script&gt;</code>标签放入沙箱执行。</p><h2 class=\"head2\">vm.isContext(sandbox)</h2><p>沙箱对象是否已经通过调用<code>vm.createContext</code>上下文化。</p><h2 class=\"head2\">vm.runInContext(code, contextifiedSandbox[, options])</h2><p><code>vm.runInContext</code>编译代码，运行在<code>contextifiedSandbox</code>并返回结果。运行代码不能访问本地域。<code>contextifiedSandbox</code>对象必须通过 <code>vm.createContext</code>上下文化；<code>code</code> 会通过全局变量使用它。</p><p><code>vm.runInContext</code>和<code>vm.runInThisContext</code>参数相同。</p><p>在同一个上下文中编译并执行不同的脚本，例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var util = require('util');\nvar vm = require('vm');\n\nvar sandbox = { globalVar: 1 };\nvm.createContext(sandbox);\n\nfor (var i = 0; i &lt; 10; ++i) {\n    vm.runInContext('globalVar *= 2;', sandbox);\n}\nconsole.log(util.inspect(sandbox));\n\n// { globalVar: 1024 }</code></pre><p>注意，执行不被信任的代码是需要技巧且要非常的小心。<code>vm.runInContext</code>非常有用，不过想要安全些，最好还是在独立的进程里运行不被信任的代码。</p><h2 class=\"head2\">vm.runInNewContext(code[, sandbox][, options])</h2><p><code>vm.runInNewContext</code>编译代码, 如果提供了sandbox ，则将sandbox上下文化，否则创建一个新的上下文化过的沙盒，将沙盒作为全局变量运行代码并返回结果。</p><p><code>vm.runInNewContext</code>和<code>vm.runInThisContext</code>参数相同。</p><p>编译并执行代码，增加全局变量值，并设置一个新的。这些全局变量包含在一个新的沙盒里。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var util = require('util');\nvar vm = require('vm'),\n\nvar sandbox = {\n  animal: 'cat',\n  count: 2\n};\n\nvm.runInNewContext('count += 1; name = \"kitty\"', sandbox);\nconsole.log(util.inspect(sandbox));\n\n// { animal: 'cat', count: 3, name: 'kitty' }</code></pre><p>注意，执行不被信任的代码是需要技巧且要非常的小心。<code>vm.runInNewContext</code>非常有用，不过想要安全些，最好还是在独立的进程里运行不被信任的代码。</p><h2 class=\"head2\">vm.runInDebugContext(code)</h2><p><code>vm.runInDebugContext</code>在V8的调试上下文中编译并执行。最主要的应用场景是获得V8调试对象访问权限。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var Debug = vm.runInDebugContext('Debug');\nDebug.scripts().forEach(function(script) { console.log(script.name); });</code></pre><p>注意，调试上下文和对象内部绑定到V8的调试实现里，并可能在没有警告时改变（或移除）。</p><p>可以通过<code>--expose_debug_as=</code>开关暴露调试对象。</p><h2 class=\"head2\">Class: Script</h2><p>包含预编译脚本的类，并在指定的沙盒里执行。</p><h3>new vm.Script(code, options)</h3><p>创建一个新的脚本编译代码，但是不运行。使用被创建的<code>vm.Script</code>来表示编译完的代码。这个代码可以使用以下的方法调用多次。返回的脚本没有绑定到任何全局变量。在运行前绑定，执行后释放。</p><p>创建脚本的选项有:</p><ul><li><code>filename</code>: 允许更改显示在站追踪（stack traces）的文件名。</li><li><code>displayErrors</code>: 是否在stderr上打印错误，抛出异常的代码行高亮显示。只会捕获编译时的语法错误，执行时抛出的错误由脚本的方法的选项来控制。默认为 <code>true</code>。</li></ul><h3>script.runInThisContext([options])</h3><p>和<code>vm.runInThisContext</code>类似，只是作为<code>Script</code>脚本对象的预编译方法。<code>script.runInThisContext</code>执行编译过的脚本并返回结果。被运行的代码没有本地作用域访问权限，但是拥有权限访问全局对象。</p><p>以下例子，使用<code>script.runInThisContext</code>编译代码一次，并运行多次：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var vm = require('vm');\n\nglobal.globalVar = 0;\n\nvar script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' });\n\nfor (var i = 0; i &lt; 1000; ++i) {\n  script.runInThisContext();\n}\n\nconsole.log(globalVar);\n\n// 1000</code></pre><p>所运行的代码选项：</p><ul><li><code>displayErrors</code>: 是否在stderr上打印错误，抛出异常的代码行高亮显示。仅适用于执行时抛出的错误。不能创建一个语法错误的<code>Script</code>实例，因为构造函数会抛出。</li><li><code>timeout</code>: 中断前代码执行的毫秒数。如果执行终止，将会抛出错误。</li></ul><h3>script.runInContext(contextifiedSandbox[, options])</h3><p>和<code>vm.runInContext</code>类似，只是作为预编译的<code>Script</code>对象方法。<code>script.runInContext</code>运行脚本（在<code>contextifiedSandbox</code>中编译）并返回结果。运行的代码没有权限访问本地域。</p><p><code>script.runInContext</code>的选项和<code>script.runInThisContext</code>类似。</p><p>例子：编译一段代码，并执行多次，这段代码实现了一个全局变量的自增，并创建一个新的全局变量。这些全局变量保存在沙盒里。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var util = require('util');\nvar vm = require('vm');\n\nvar sandbox = {\n  animal: 'cat',\n  count: 2\n};\n\nvar script = new vm.Script('count += 1; name = \"kitty\"');\n\nfor (var i = 0; i &lt; 10; ++i) {\n  script.runInContext(sandbox);\n}\n\nconsole.log(util.inspect(sandbox));\n\n// { animal: 'cat', count: 12, name: 'kitty' }</code></pre><p>注意，执行不被信任的代码是需要技巧且要非常的小心。<code>script.runInContext</code>非常有用，不过想要安全些，最好还是在独立的进程里运行不被信任的代码。</p><h3>script.runInNewContext([sandbox][, options])</h3><p>和<code>vm.runInNewContext</code>类似，只是作为预编译的<code>Script</code>对象方法。若提供sandbox则script.runInNewContext将sandbox上下文化，若未提供，则创建一个新的上下文化的沙箱。</p><p><code>script.runInNewContext</code>和<code>script.runInThisContext</code>的参数类似。</p><p>例子：编译代码（设置了一个全局变量）并在不同的上下文里执行多次。这些全局变量会被保存在沙箱中。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var util = require('util');\nvar vm = require('vm');\n\nvar sandboxes = [{}, {}, {}];\n\nvar script = new vm.Script('globalVar = \"set\"');\n\nsandboxes.forEach(function (sandbox) {\n  script.runInNewContext(sandbox);\n});\n\nconsole.log(util.inspect(sandboxes));\n\n// [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }]</code></pre><p>注意，执行不被信任的代码是需要技巧且要非常的小心。<code>script.runInNewContext</code>非常有用，不过想要安全些，最好还是在独立的进程里运行不被信任的代码。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 35,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "fdec84c84e6ce2b9697658c8619364a4",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 实用工具",
      "chapter_level_two_url": "/nodejs/g4qi1iub.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\">\n    <h2>实用工具</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 4 - 锁定</code></pre><p>本节介绍Node.js的<code>'util'</code>模块中的函数的使用，通过<code>require('util')</code>访问该模块，如下所示：</p><pre lang=\"javascript\"><code class=\"javascript\">const util = require('util');</code></pre>\n    <p><code>util</code> 模块原先设计的初衷是用来支持Node.js的内部API的。这里的很多的函数对你的程序来说都非常有用。如果你觉得这些函数不能满足你的要求，那你可以写自己的工具函数。我们不希望<code>'util'</code>模块里添加对于node内部函数无用的扩展。</p>\n    <h2 class=\"head2\">util.debuglog(section)</h2>\n    <ul>\n        <li><code>section</code>{字符串} 被调试的程序节点部分</li>\n        <li>Returns: {Function} 日志函数</li>\n    </ul>\n    <p>用来创建一个有条件的写到stderr的函数（基于<code>NODE_DEBUG</code>环境变量）。如果<code>section</code>出现在环境变量里，返回函数将会和<code>console.error()</code>类似。否则，返回一个空函数。</p>\n    <p>例如：</p><pre lang=\"javascript\"><code class=\"javascript\">javascript\nvar debuglog = util.debuglog('foo');\n\nvar bar = 123;\ndebuglog('hello from foo [%d]', bar);</code></pre>\n    <p>如果这个程序以<code>NODE_DEBUG=foo</code>的环境运行，将会输出：</p><pre lang=\"javascript\"><code class=\"javascript\">FOO 3245: hello from foo [123]</code></pre>\n    <p><code>3245</code>是进程ID。如果没有运行在这个环境变量里，将不会打印任何东西。</p>\n    <p>可以用逗号切割多个<code>NODE_DEBUG</code>环境变量。例如：<code>NODE_DEBUG=fs,net,tls</code>。</p>\n    <h2 class=\"head2\">util.format(format[, ...])</h2>\n    <p>使用第一个参数返回一个格式化的字符串，类似<code>printf</code>。</p>\n    <p>第一个参数是字符串，它包含0或更多的占位符。每个占位符被替换成想要参数转换的值。支持的占位符包括：</p>\n    <ul>\n        <li><code>%s</code>- 字符串.</li>\n        <li><code>%d</code>- 数字 (整数和浮点数).</li>\n        <li><code>%j</code>- JSON。如果参数包含循环引用，将会用字符串替换R</li>\n        <li><code>%%</code>- 单独一个百分号 (<code>'%'</code>)。 不会消耗一个参数。</li>\n    </ul>\n    <p>如果占位符没有包含一个相应的参数，占位符不会被替换。</p><pre lang=\"javascript\"><code class=\"javascript\">util.format('%s:%s', 'foo'); // 'foo:%s'</code></pre>\n    <p>如果参数超过占位符，多余的参数将会用<code>util.inspect()</code>转换成字符串，并拼接在一起，用空格隔开。</p><pre lang=\"javascript\"><code class=\"javascript\">util.format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'</code></pre>\n    <p>如果第一个参数不是格式化字符串，那么<code>util.format()</code>会返回所有参数拼接成的字符串（空格分割）。每个参数都会用<code>util.inspect()</code>转换成字符串。</p><pre lang=\"javascript\"><code class=\"javascript\">util.format(1, 2, 3); // '1 2 3'</code></pre>\n    <h2 class=\"head2\">util.log(string)</h2>\n        <p>在<code>stdout</code>输出并带有时间戳：</p><pre lang=\"javascript\"><code class=\"javascript\">require('util').log('Timestamped message.');</code></pre>\n        <h2 class=\"head2\">util.inspect(object[, options])</h2>\n        <p>返回一个对象的字符串表现形式，在代码调试的时候非常有用。</p>\n        <p>通过加入一些可选选项，来改变对象的格式化输出形式：</p>\n        <ul>\n            <li>\n                <p><code>showHidden</code>- 如果为<code>true</code>，将会显示对象的不可枚举属性。默认为<code>false</code>。</p>\n            </li>\n            <li>\n                <p><code>depth</code>- 告诉<code>inspect</code>格式化对象时递归多少次。这在格式化大且复杂对象时非常有用。默认为 <code>2</code>。如果想无穷递归的话，传<code>null</code>。</p>\n            </li>\n            <li>\n                <p><code>colors</code>- 如果为<code>true</code>，输出内容将会格式化为有颜色的代码。默认为<code>false</code>， 颜色可以自定义，参见下文。</p>\n            </li>\n            <li><code>customInspect</code>- 如果为<code>false</code>，那么定义在被检查对象上的inspect(depth, opts) 方法将不会被调用。 默认为true。</li>\n        </ul>\n        <p>检查<code>util</code>对象上所有属性的例子：</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nconsole.log(util.inspect(util, { showHidden: true, depth: null }));</code></pre>\n        <p>当被调用的时候，参数值可以提供自己的自定义inspect(depth, opts)方法。该方法会接收当前的递归检查深度，以及传入util.inspect()的其他参数。</p>\n        <h3>自定义<code>util.inspect</code>颜色</h3>\n        <p><code>util.inspect</code>通过<code>util.inspect.styles</code>和<code>util.inspect.colors</code>对象，自定义全局的输出颜色，</p>\n        <p><code>util.inspect.styles</code>和<code>util.inspect.colors</code>组成风格颜色的一对映射。</p>\n        <p>高亮风格和他们的默认值：</p>\n        <ul>\n            <li><code>数字</code> (黄色)</li>\n            <li><code>boolean</code> (黄色)</li>\n            <li><code>字符串</code> (绿色)</li>\n            <li><code>date</code> (洋红)</li>\n            <li><code>regexp</code> (红色)</li>\n            <li><code>null</code> (粗体)</li>\n            <li><code>undefined</code> (斜体)</li>\n            <li><code>special</code> (青绿色)</li>\n            <li><code>name</code> (内部用，不是风格)</li>\n        </ul>\n        <p>预定义的颜色为: <code>white</code>、<code>斜体</code>、<code>black</code>、<code>blue</code>、<code>cyan</code>、<code>绿色</code>、<code>洋红</code>、<code>红色</code>和<code>黄色</code>以及<code>粗体</code>、<code>斜体</code>、<code>下划线</code>和<code>反选</code>风格。</p>\n        <h3>对象自定义<code>inspect()</code>函数</h3>\n        <p>对象也能自定义<code>inspect(depth)</code>函数， 当使用util.inspect()检查该对象的时候，将会执行对象自定义的检查方法：</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nvar obj = { name: 'nate' };\nobj.inspect = function(depth) {\n  return '{' + this.name + '}';\n};\n\nutil.inspect(obj);\n  // \"{nate}\"</code></pre>\n        <p>你可以返回另外一个对象，返回的字符串会根据返回的对象格式化。这和<code>JSON.stringify()</code>的工作流程类似。您还可以完全返回另一个对象，返回的字符串将根据返回的对象格式化。这与<code>JSON.stringify()</code>的工作方式类似：</p><pre lang=\"javascript\"><code class=\"javascript\">var obj = { foo: 'this will not show up in the inspect() output' };\nobj.inspect = function(depth) {\n  return { bar: 'baz' };\n};\n\nutil.inspect(obj);\n  // \"{ bar: 'baz' }\"</code></pre>\n        <h2 class=\"head2\">util.isArray(object)</h2>\n        <p>Array.isArray的内部别名。</p>\n        <p>如果参数\"object\"是数组，返回<code>true</code> ，否则返回<code>false</code>。</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false</code></pre>\n        <h2 class=\"head2\">util.isRegExp(object)</h2>\n        <p>如果参数\"object\"是<code>RegExp</code>返回<code>true</code> ，否则返回<code>false</code>。</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp('another regexp'))\n  // true\nutil.isRegExp({})\n  // false</code></pre>\n        <h2 class=\"head2\">util.isDate(object)</h2>\n        <p>如果参数\"object\"是<code>Date</code>返回<code>true</code>，否则返回<code>false</code>。</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without 'new' returns a String)\nutil.isDate({})\n  // false</code></pre>\n        <h2 class=\"head2\">util.isError(object)</h2>\n        <p>如果参数\"object\"是<code>Error</code>返回<code>true</code>，否则返回<code>false</code>。</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require('util');\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: 'Error', message: 'an error occurred' })\n  // false</code></pre>\n        <h2 class=\"head2\">util.inherits(constructor, superConstructor)</h2>\n        <p>从一个构造函数<a rel=\"nofollow\" href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor\" target=\"_blank\">constructor</a>继承原型方法到另一个。构造函数的原型将被设置为一个新的从超类（<code>superConstructor</code>）创建的对象。</p>\n        <p>通过<code>constructor.super_</code>属性可以访问<code>superConstructor</code>。</p><pre lang=\"javascript\"><code class=\"javascript\">var util = require(\"util\");\nvar events = require(\"events\");\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(\"data\", data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on(\"data\", function(data) {\n    console.log('Received data: \"' + data + '\"');\n})\nstream.write(\"It works!\"); // Received data: \"It works!\"</code></pre>\n        <h2 class=\"head2\">util.deprecate(function, string)</h2>\n        <p>标明该方法不要再使用。</p><pre lang=\"javascript\"><code class=\"javascript\">exports.puts = exports.deprecate(function() {\n  for (var i = 0, len = arguments.length; i &lt; len; ++i) {\n    process.stdout.write(arguments[i] + '\\n');\n  }\n}, 'util.puts: Use console.log instead')</code></pre>\n        <p>返回一个修改过的函数，默认情况下仅警告一次。如果设置了<code>--no-deprecation</code>该函数不做任何事。如果设置了<code>--throw-deprecation</code>，如果使用了该API应用将会抛出异常。</p>\n        <h2 class=\"head2\">util.debug(string)</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 0 - 抛弃: 使用 console.error() 替换。</code></pre>\n        <p><code>console.error</code>的前身。</p>\n        <h2 class=\"head2\">util.error([...])</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 0 - 抛弃: 使用 console.error() 替换。</code></pre>\n        <p><code>console.error</code>的前身。</p>\n        <h2 class=\"head2\">util.puts([...])</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 0 - 抛弃:使用 console.log() 替换。</code></pre>\n        <p><code>console.log</code>的前身。</p>\n        <h2 class=\"head2\">util.print([...])</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 0 - 抛弃: 使用 console.log() 替换。</code></pre>\n        <p><code>console.log</code>的前身。</p>\n        <h2 class=\"head2\">util.pump(readableStream, writableStream[, callback])</h2><pre lang=\"javascript\"><code class=\"javascript\">稳定性: 0 - 抛弃: Use readableStream.pipe(writableStream)</code></pre>\n        <p><code>stream.pipe</code>的前身。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 34,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e2e0ab15cf899796cb6aa9ba87be757d",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js URL",
      "chapter_level_two_url": "/nodejs/eq9c1iu9.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>URL</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>Node.js的URL模块提供了用于分析和解析URL的实用程序。可以调用<code>require('url')</code>来访问它：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const url = require('url');</code></pre><p>解析URL对象有以下内容，依赖于他们是否在URL字符串里存在。任何不在URL字符串里的部分，都不会出现在解析对象里。例子如下：</p><p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p><ul><li><p><code>href</code>：准备解析的完整的URL，包含协议和主机（小写）。</p><p>例子：<code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li><li><p><code>protocol</code>: 请求协议，小写。</p><p>例子：<code>'http:'</code></p></li><li><p><code>slashes</code>: 协议要求的斜杠（冒号后）</p><p>例子：true或false</p></li><li><p><code>host</code>: 完整的URL小写主机部分，包含端口信息。</p><p>例子：<code>'host.com:8080'</code></p></li><li><p><code>auth</code>: url中的验证信息。</p><p>例子：<code>'user:pass'</code></p></li><li><p><code>hostname</code>: 域名中的小写主机名</p><p>例子：<code>'host.com'</code></p></li><li><p><code>port</code>: 主机的端口号</p><p>例子：<code>'8080'</code></p></li><li><p><code>pathname</code>: URL中的路径部分，在主机名后，查询字符前，包含第一个斜杠。</p><p>例子：<code>'/p/a/t/h'</code></p></li><li><p><code>search</code>: URL中得查询字符串，包含开头的问号</p><p>例子：<code>'?query=string'</code></p></li><li><p><code>path</code>: <code>pathname</code>和<code>search</code>连在一起</p><p>例子：<code>'/p/a/t/h?query=string'</code></p></li><li><p><code>query</code>: 查询字符串中得参数部分，或者使用querystring.parse()解析后返回的对象。</p><p>例子：<code>'query=string'</code>或者<code>{'query':'string'}</code></p></li><li><p><code>hash</code>:  URL的“#”后面部分（包括 # 符号）</p><p>例子：<code>'#hash'</code></p></li></ul><p>URL模块提供了以下方法：</p><p><a name=\"url.parse\"></a></p><h2 class=\"head2\">url.parse(urlStr[, parseQueryString][, slashesDenoteHost])</h2><p>输入URL字符串，返回一个对象。</p><p>第二个参数为<code>true</code>时，使用<code>querystring</code>来解析查询字符串。如果为<code>true</code>，<code>query</code>属性将会一直赋值为对象，并且<code>search</code>属性将会一直是字符串(可能为空)。默认为<code>false</code>。</p><p>第三个参数为<code>true</code>，把<code>//foo/bar</code>当做<code>{ host: 'foo', pathname: '/bar' }</code> ，而不是<code>{ pathname: '//foo/bar' }</code>。默认为<code>false</code>。</p><h2 class=\"head2\">url.format(urlObj)</h2><p>输入一个解析过的URL对象，返回格式化过的字符串。</p><p>格式化的工作流程：</p><ul><li><code>href</code>会被忽略</li><li><code>protocol</code>无论是否有末尾的 : (冒号)，会同样的处理<ul><li><code>http</code>，<code>https</code>，<code>ftp</code>，<code>gopher</code>，<code>file</code>协议会被添加后缀<code>://</code> </li><li><code>mailto</code>，<code>xmpp</code>，<code>aim</code>，<code>sftp</code>，<code>foo</code>等协议添加后缀<code>:</code></li></ul></li><li><code>slashes</code>如果协议需要<code>://</code>，设置为true。<ul><li>仅需对之前列出的没有斜杠的协议，比如议<code>mongodb://localhost:8000/</code></li></ul></li><li><code>auth</code>如果出现将会使用.</li><li><code>hostname</code>仅在缺少<code>host</code>时使用</li><li><code>port</code>仅在缺少<code>host</code>时使用</li><li><code>host</code>用来替换<code>hostname</code>和<code>port</code></li><li><code>pathname</code>无论结尾是否有“/”将会同样处理</li><li><code>search</code>将会替 query属性<ul><li>无论前面是否有“/”将会同样处理</li></ul></li><li><code>query</code> (对象；参见<code>querystring</code>) 如果没有search，将会使用</li><li><code>hash</code>无论前面是否有#，都会同样处理</li></ul><h2 class=\"head2\">url.resolve(from, to)</h2><p>给一个基础URL，href URL，如同浏览器一样的解析它们可以带上锚点，例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">url.resolve('/one/two/three', 'four')         // '/one/two/four'\nurl.resolve('http://example.com/', '/one')    // 'http://example.com/one'\nurl.resolve('http://example.com/one', '/two') // 'http://example.com/two'</code></pre></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 33,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "ff64d967567b2f69a544c79331a6eb47",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js UDP/Datagram",
      "chapter_level_two_url": "/nodejs/nlqs1iu8.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>UDP/Datagram Sockets</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>Node.js的dgram模块提供了UDP数据报套接字的实现。</p><p>使用数据报文sockets(Datagram sockets)的方式是调用<code>require('dgram')</code>。</p><p>重要提醒：<code>dgram.Socket#bind()</code>的行为在v0.10做了改动 ，它总是异步的。如果你的代码像下面的一样：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var s = dgram.createSocket('udp4');\ns.bind(1234);\ns.addMembership('224.0.0.114');</code></pre><p>现在需要改为：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var s = dgram.createSocket('udp4');\ns.bind(1234, function() {\n  s.addMembership('224.0.0.114');\n});</code></pre><h2 class=\"head2\">dgram.createSocket(type[, callback])</h2><ul><li><code>type</code>字符串。 'udp4'或'udp6'</li><li><code>callback</code>函数。附加到<code>message</code>事件的监听器。可选参数。</li><li>返回：Socket对象</li></ul><p>创建指定类型的数据报文(datagram) Socket。有效类型是<code>udp4</code>和<code>udp6</code></p><p>接受一个可选的回调，会被添加为<code>message</code>的监听事件。</p><p>如果你想接收数据报文(datagram)可以调用<code>socket.bind()</code>。<code>socket.bind()</code>将会绑定到所有接口（\"all interfaces\"）的随机端口上（<code>udp4</code>和<code>udp6</code> sockets都适用）。你可以通过<code>socket.address().address</code>和<code>socket.address().port</code>获取地址和端口。</p><h2 class=\"head2\">dgram.createSocket(options[, callback])</h2><ul><li><code>options</code>对象</li><li><code>callback</code>函数。给<code>message</code>事件添加事件监听器。</li><li>返回：Socket对象</li></ul><p>参数<code>options</code>必须包含<code>type</code>值(<code>udp4</code>或<code>udp6</code>)，或可选的boolean值<code>reuseAddr</code>。</p><p>当<code>reuseAddr</code>为 true 时，<code>socket.bind()</code>将会重用地址，即使另一个进程已经绑定socket。<code>reuseAddr</code>默认为<code>false</code>。</p><p>回调函数为可选参数，作为<code>message</code>事件的监听器。</p><p>如果你想接受数据报文(datagram)，可以调用<code>socket.bind()</code>。<code>socket.bind()</code>将会绑定到所有接口（\"all interfaces\"）地址的随机端口上（<code>udp4</code>和<code>udp6</code> sockets都适用）。你可以通过<code>socket.address().address</code>和<code>socket.address().port</code>获取地址和端口。</p><h2 class=\"head2\">Class: dgram.Socket</h2><p>报文数据Socket类封装了数据报文(datagram)函数。必须通过<code>dgram.createSocket(...)</code>函数创建。</p><h3>Event: 'message'</h3><ul><li><code>msg</code>缓存对象. 消息。</li><li><code>rinfo</code>对象. 远程地址信息。</li></ul><p>当socket上新的数据报文(datagram)可用的时候，会触发这个事件。<code>msg</code>是一个缓存，<code>rinfo</code>是一个包含发送者地址信息的对象。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">socket.on('message', function(msg, rinfo) {\n  console.log('Received %d bytes from %s:%d\\n',\n              msg.length, rinfo.address, rinfo.port);\n});</code></pre><h3>Event: 'listening'</h3><p>当socket开始监听数据报文(datagram)时触发。在UDP socket创建时触发。</p><h3>Event: 'close'</h3><p>当socket使用<code>close()</code>关闭时触发。在这个socket上不会触发新的消息事件。</p><h3>Event: 'error'</h3><ul><li><code>exception</code>Error对象</li></ul><p>当发生错误时触发。</p><h3>socket.send(buf, offset, length, port, address[, callback])</h3><ul><li><code>buf</code>缓存对象或字符串.  要发送的消息。</li><li><code>offset</code>整数。消息在缓存中得偏移量。</li><li><code>length</code>整数。消息的比特数。</li><li><code>port</code>整数。端口的描述。</li><li><code>address</code>字符串。目标的主机名或IP地址。</li><li><code>callback</code>函数。当消息发送完毕的时候调用。可选。</li></ul><p>对于UDP socket，必须指定目标端口和地址。<code>address</code>参数可能是字符串，它会被DNS解析。</p><p>如果忽略地址或者地址是空字符串，将使用<code>'0.0.0.0'</code>或<code>'::0'</code>替代。依赖于网络配置，这些默认值有可能行也可能不行。</p><p>如果socket之前没被调用<code>bind</code>绑定，则它会被分配一个随机端口并绑定到所有接口（\"all interfaces\"）地址(<code>udp4</code>sockets的<code>'0.0.0.0'</code> ，<code>udp6</code>sockets的<code>'::0'</code>)</p><p>回调函数可能用来检测DNS错误，或用来确定什么时候重用<code>buf</code>对象。注意，DNS查询会导致发送tick延迟。通过回调函数能确认数据报文(datagram)是否已经发送的。</p><p>考虑到多字节字符串情况，偏移量和长度是字节长度<a href=\"x1u41ith.html\" target=\"_blank\">byte length</a>，而不是字符串长度。</p><p>下面的例子是在<code>localhost</code>上发送一个UDP包给随机端口：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var dgram = require('dgram');\nvar message = new Buffer(\"Some bytes\");\nvar client = dgram.createSocket(\"udp4\");\nclient.send(message, 0, message.length, 41234, \"localhost\", function(err) {\n  client.close();\n});</code></pre><p><strong>关于UDP数据报文(datagram) 尺寸</strong></p><p><code>IPv4/v6</code>数据报文(datagram)的最大长度依赖于<code>MTU</code> (<em>Maximum Transmission Unit</em>)和<code>Payload Length</code>的长度。</p><ul><li><p><code>Payload Length</code>内容为16位宽，它意味着Payload的最大字节说不超过64k，其中包括了头信息和数据（65,507字节 = 65,535 − 8字节UDP头 − 20字节IP 头）；对于环回接口（loopback interfaces）这是真的，但对于多数主机和网络来说不太现实。</p></li><li><p><code>MTU</code>能支持数据报文(datagram)的最大值（以目前链路层技术来说）。对于任何连接，<code>IPv4</code>允许的最小值为<code>68</code>的<code>MTU</code>，推荐值为<code>576</code>（通常推荐作拨号应用的<code>MTU</code>）,无论他们是完整接收还是碎片接收。</p><p>对于<code>IPv6</code>，<code>MTU</code>的最小值为<code>1280</code>字节，最小碎片缓存大小为<code>1500</code>字节。16字节实在是太小，所以目前链路层一般最小<code>MTU</code>大小为<code>1500</code>。</p></li></ul><p>我们不可能知道一个包可能进过的每个连接的MTU。通常发送一个超过接收端MTU大小的数据报文(datagram)会失效。（数据包会被悄悄的抛弃，不会通知发送端数据包没有到达接收端）。</p><h3>socket.bind(port[, address][, callback])</h3><ul><li><code>port</code>整数</li><li><code>address</code>字符串，可选</li><li><code>callback</code>没有参数的函数，可选。绑定时会调用回调。</li></ul><p>对于UDP socket，在一个端口和可选地址上监听数据报文(datagram)。如果没有指定地点，系统将会参数监听所有的地址。绑定完毕后，会触发\"listening\" 事件，并会调用传入的回调函数。指定监听事件和回调函数非常有用。</p><p>一个绑定了的数据报文socket会保持node进程运行来接收数据。</p><p>如果绑定失败，会产生错误事件。极少数情况（比如绑定一个关闭的socket）。这个方法会抛出一个错误。</p><p>以下是UDP服务器监听端口41234的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var dgram = require(\"dgram\");\n\nvar server = dgram.createSocket(\"udp4\");\n\nserver.on(\"error\", function (err) {\n  console.log(\"server error:\\n\" + err.stack);\n  server.close();\n});\n\nserver.on(\"message\", function (msg, rinfo) {\n  console.log(\"server got: \" + msg + \" from \" +\n    rinfo.address + \":\" + rinfo.port);\n});\n\nserver.on(\"listening\", function () {\n  var address = server.address();\n  console.log(\"server listening \" +\n      address.address + \":\" + address.port);\n});\n\nserver.bind(41234);\n// server listening 0.0.0.0:41234</code></pre><h3>socket.bind(options[, callback])</h3><ul><li><code>options</code>{对象} - 必需. 有以下的属性:<ul><li><code>port</code>{Number} - 必需.</li><li><code>address</code>{字符串} - 可选.</li><li><code>exclusive</code>{Boolean} - 可选.</li></ul></li><li><code>callback</code>{函数} - 可选.</li></ul><p><code>options</code>的可选参数<code>port</code>和 <code>address</code>，以及可选参数<code>callback</code>，好像在调用<a href=\"#dgram_socket_bind_port_address_callback\">socket.bind(port, [address], [callback])</a>。</p><p>如果<code>exclusive</code>是<code>false</code>（默认），集群进程将会使用相同的底层句柄，允许连接处理共享的任务。当<code>exclusive</code>为<code>true</code>时，句柄不会共享，尝试共享端口也会失败。监听<code>exclusive</code>端口的例子如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">socket.bind({\n  address: 'localhost',\n  port: 8000,\n  exclusive: true\n});</code></pre><h3>socket.close()</h3><p>关闭底层socket并且停止监听数据。</p><h3>socket.address()</h3><p>返回一个包含套接字地址信息的对象。对于UDP socket，这个对象会包含<code>address</code>，<code>family</code>和<code>port</code>。</p><h3>socket.setBroadcast(flag)</h3><ul><li><code>flag</code>Boolean</li></ul><p>设置或清除<code>SO_BROADCAST</code>socket选项。设置这个选项后，UDP包可能会发送给一个本地的接口广播地址。</p><h3>socket.setTTL(ttl)</h3><ul><li><code>ttl</code>整数</li></ul><p>设置<code>IP_TTL</code>socket选项。TTL表示生存时间（Time to Live），但是在这个上下文中它指的是报文允许通过的IP跃点数。各个转发报文的路由器或者网关都会递减 TTL。如果TTL被路由器递减为0，则它将不会被转发。改变TTL的值通常用于网络探测器或多播。</p><p><code>setTTL()</code>的参数为1到255的跃点数。多数系统默认值为64。</p><h3>socket.setMulticastTTL(ttl)</h3><ul><li><code>ttl</code>整数</li></ul><p>设置<code>IP_MULTICAST_TTL</code>socket选项。TTL表示生存时间（Time to Live），但是在这个上下文中它指的是报文允许通过的IP跃点数。各个转发报文的路由器或者网关都会递减TTL。如果TTL被路由器递减为0，则它将不会被转发。改变TTL的值通常用于网络探测器或多播。</p><p><code>setMulticastTTL()</code>的参数为1到255的跃点数。多数系统默认值为1。</p><h3>socket.setMulticastLoopback(flag)</h3><ul><li><code>flag</code> Boolean</li></ul><p>设置或清空<code>IP_MULTICAST_LOOP</code>socket选项。设置完这个选项后，当该选项被设置时，组播报文也会被本地接口收到。</p><h3>socket.addMembership(multicastAddress[, multicastInterface])</h3><ul><li><code>multicastAddress</code>字符串</li><li><code>multicastInterface</code>字符串，可选</li></ul><p>告诉内核加入广播组，选项为<code>IP_ADD_MEMBERSHIP</code>socket</p><p>如果没有指定<code>multicastInterface</code>，操作系统会给所有可用的接口添加关系。</p><h3>socket.dropMembership(multicastAddress[, multicastInterface])</h3><ul><li><code>multicastAddress</code>字符串</li><li><code>multicastInterface</code>字符串，可选</li></ul><p>和<code>addMembership</code>相反 - 用<code>IP_DROP_MEMBERSHIP</code>选项告诉内核离开广播组 。如果没有指定<code>multicastInterface</code>，操作系统会移除所有可用的接口关系。</p><h3>socket.unref()</h3><p>在socket上调用<code>unref</code>允许程序退出，如果这是在事件系统中唯一的活动socket。如果socket已经<code>unref</code>，再次调用<code>unref</code>将会无效。</p><h3>socket.ref()</h3><p>和<code>unref</code>相反，如果这是唯一的socket，在一个之前被unref了的socket上调用ref将不会让程序退出（缺省行为）。如果一个socket已经被ref，则再次调用ref将会无效。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 32,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "7951c28acb4da04e59d36d3b70c8353a",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js TTY",
      "chapter_level_two_url": "/nodejs/xml71iu7.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>TTY</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 2 - 不稳定</code></pre><p>Node.js的<code>tty</code>模块包含<code>tty.ReadStream</code>和<code>tty.WriteStream</code>类，多数情况下，你不必直接使用这个模块，访问该模块的方法如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const tty = require('tty');</code></pre><p>当node检测到自己正运行于TTY上下文时，<code>process.stdin</code>将会是一个<code>tty.ReadStream</code>实例，并且<code>process.stdout</code>将会是<code>tty.WriteStream</code>实例。检测 node是否运行在TTY上下文的好方法是检测<code>process.stdout.isTTY</code>：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">$ node -p -e \"Boolean(process.stdout.isTTY)\"\ntrue\n$ node -p -e \"Boolean(process.stdout.isTTY)\" | cat\nfalse</code></pre><h2 class=\"head2\">tty.isatty(fd)</h2><p>如果<code>fd</code>和终端相关联返回<code>true</code>，否则返回<code>false</code>。</p><h2 class=\"head2\">tty.setRawMode(mode)</h2><p>已经抛弃。使用<code>tty.ReadStream#setRawMode()</code>（比如<code>process.stdin.setRawMode()</code>）替换。</p><h2 class=\"head2\">Class: ReadStream</h2><p><code>net.Socket</code>的子类，表示tty的可读部分。通常情况，在任何node程序里（仅当<code>isatty(0)</code>为true时），<code>process.stdin</code>是<code>tty.ReadStream</code>的唯一实例。</p><h3>rs.isRaw</h3><p><code>Boolean</code>值，默认为<code>false</code>。它代表当前<code>tty.ReadStream</code>实例的\"raw\"状态。 </p><h3>rs.setRawMode(mode)</h3><p><code>mode</code>需是<code>true</code>或<code>false</code>。它设定<code>tty.ReadStream</code>属性为原始设备或默认。<code>isRaw</code>将会设置为结果模式。</p><h2 class=\"head2\">Class: WriteStream</h2><p><code>net.Socket</code>的子类，代表tty的可写部分。通常情况下，<code>process.stdout</code>是<code>tty.WriteStream</code>唯一实例（仅当<code>isatty(1)</code>为true时）。</p><h3>ws.columns</h3><p>TTY当前拥有的列数。触发\"resize\"事件时会更新这个值。</p><h3>ws.rows</h3><p>TTY当前拥有的行数。触发\"resize\"事件时会更新这个值。</p><h3>Event: 'resize'</h3><p><code>function () {}</code></p><p>行或列变化时会触发<code>refreshSize()</code>事件。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.stdout.on('resize', function() {\n  console.log('screen size has changed!');\n  console.log(process.stdout.columns + 'x' + process.stdout.rows);\n});</code></pre></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 31,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "f772827f4244be081bb6d4b1af347644",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 进程",
      "chapter_level_two_url": "/nodejs/qvcz1iu6.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>进程</h2><p>本节介绍Node.js的process（过程）对象，它提供有关当前Node.js过程的信息和控制。<br></p><p><code>process</code>是全局对象，能够在任意位置对其进行访问，而无需使用require()，是<a href=\"aue11itf.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">EventEmitter</a>的实例。</p><h2 class=\"head2\">退出状态码</h2><p>当不需要处理新的异步的操作时，Node正常情况下退出时会返回状态码<code>0</code>。下面提供了一些表示其他状态的状态码：</p><ul><li><code>1</code><strong>未捕获的致命异常-Uncaught Fatal Exception</strong> - 有未捕获异常，并且没有被域或 <code>uncaughtException</code> 处理函数处理。  </li><li><code>2</code>- Unused (保留)</li><li><code>3</code><strong>JavaScript解析错误-Internal JavaScript Parse Error</strong> - JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发Node时才会有。   </li><li><code>4</code><strong>JavaScript评估失败-Internal JavaScript Evaluation Failure</strong> - JavaScript的源码启动Node进程，评估时返回函数失败。非常罕见，仅会在开发 Node时才会有。  </li><li><code>5</code><strong>致命错误-Fatal Error</strong> - V8里致命的不可恢复的错误。通常会打印到stderr，内容为：<code>FATAL ERROR</code></li><li><code>6</code><strong>Non-function异常处理-Non-function Internal Exception Handler</strong> - 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</li><li><code>7</code><strong>异常处理函数运行时失败-Internal Exception Handler Run-Time Failure</strong> - 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 <code>process.on('uncaughtException')</code>或<code>domain.on('error')</code>抛出了异常。  </li><li><code>8</code>- Unused保留。 之前版本的Node， 状态码8有时表示未捕获异常。  </li><li><code>9</code>- <strong>参数非法-Invalid Argument</strong> - 可能是给了未知的参数，或者给的参数没有值。</li><li><code>10</code><strong>运行时失败-Internal JavaScript Run-Time Failure</strong> - JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</li><li><code>12</code><strong>无效的Debug参数-Invalid Debug Argument</strong> - 设置了参数<code>--debug</code>或<code>--debug-brk</code>，但是选择了错误端口。</li><li><code>&gt;128</code><strong>信号退出-Signal Exits</strong> - 如果Node接收到致命信号，比如<code>SIGKILL</code>或<code>SIGHUP</code>，那么退出代码就是<code>128</code>加信号代码。这是标准的Unix做法，退出信号代码放在高位。</li></ul><h2 class=\"head2\">事件: 'exit'</h2><p>当进程准备退出时触发。此时已经没有办法阻止从事件循环中推出。因此，你必须在处理函数中执行同步操作。这是一个在固定事件检查模块状态（比如单元测试）的好时机。回调函数有一个参数，它是进程的退出代码。</p><p>监听<code>exit</code>事件的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.on('exit', function(code) {\n  // do *NOT* do this\n  setTimeout(function() {\n    console.log('This will not run');\n  }, 0);\n  console.log('About to exit with code:', code);\n});</code></pre><h2 class=\"head2\">事件: 'beforeExit'</h2><p>当node清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时node退出，但是'beforeExit'的监听器可以异步调用，这样node就会继续执行。</p><p>'beforeExit'并不是明确退出的条件，<code>process.exit()</code>或异常捕获才是，所以不要把它当做'exit'事件。除非你想安排更多的工作。</p><h2 class=\"head2\">事件: 'uncaughtException'</h2><p>当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</p><p>监听<code>uncaughtException</code>的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.on('uncaughtException', function(err) {\n  console.log('Caught exception: ' + err);\n});\n\nsetTimeout(function() {\n  console.log('This will still run.');\n}, 500);\n\n// Intentionally cause an exception, but don't catch it.\nnonexistentFunc();\nconsole.log('This will not run.');</code></pre><p>注意：<code>uncaughtException</code>是非常简略的异常处理机制。</p><p>尽量不要使用它，而应该用<a href=\"gx171iu4.html\" target=\"_blank\">domains</a> 。如果你用了，每次未处理异常后，重启你的程序。</p><p>不要使用node.js里诸如<code>On Error Resume Next</code>这样操作。每个未处理的异常意味着你的程序，和你的node.js扩展程序，一个未知状态。盲目的恢复意味着任何事情都可能发生</p><p>你在升级的系统时拉掉了电源线，然后恢复了。可能10次里有9次没有问题，但是第10次，你的系统可能就会挂掉。</p><h2 class=\"head2\">Signal 事件</h2><p>当进程接收到信号时就触发。信号列表详见标准的POSIX信号名，如SIGINT、SIGUSR1等。</p><p>监听<code>SIGINT</code>的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// Start reading from stdin so we don't exit.\nprocess.stdin.resume();\n\nprocess.on('SIGINT', function() {\n  console.log('Got SIGINT.  Press Control-D to exit.');\n});</code></pre><p>在大多数终端程序里，发送<code>SIGINT</code>信号的简单方法是按下<code>信号Control-C</code>。</p><p>注意:</p><ul><li><code>SIGUSR1</code>node.js 接收这个信号开启调试模式。可以安装一个监听器，但开始时不会中断调试。  </li><li><code>SIGTERM</code>和<code>SIGINT</code>在非Windows系统里，有默认的处理函数，退出（伴随退出代码<code>128 + 信号码</code>）前，重置退出模式。如果这些信号有监视器，默认的行为将会被移除。  </li><li><code>SIGPIPE</code>默认情况下忽略，可以加监听器。</li><li><code>SIGHUP</code>当Windowns控制台关闭的时候生成，其他平台的类似条件，参见signal(7)。可以添加监听者，Windows平台上10秒后会无条件退出。在非Windows平台上，<code>SIGHUP</code>的默认操作是终止node，但是一旦添加了监听器，默认动作将会被移除。</li><li><code>SIGTERM</code>Windows不支持，可以被监听。</li><li><code>SIGINT</code>所有的终端都支持，通常由<code>CTRL+C</code>生成（可能需要配置）。当终端原始模式启用后不会再生成。  </li><li><code>SIGBREAK</code>Windows里，按下<code>CTRL+BREAK</code>会发送。非Windows平台，可以被监听，但是不能发送或生成。  </li><li><code>SIGWINCH</code>- 当控制台被重设大小时发送。Windows系统里，仅会在控制台上输入内容时，光标移动，或者可读的tty在原始模式上使用。 </li><li><code>SIGKILL</code>不能有监视器，在所有平台上无条件关闭node。  </li><li><code>SIGSTOP</code>不能有监视器。</li></ul><p>Windows不支持发送信号，但是node提供了很多<code>process.kill()</code>和<code>child_process.kill()</code>的模拟：</p><ul><li>发送Sending信号<code>0</code>可以查找运行中得进程</li><li>发送<code>SIGINT</code>，<code>SIGTERM</code>和<code>SIGKILL</code>会引起目标进程无条件退出。</li></ul><h2 class=\"head2\">process.stdout</h2><p>一个<code>Writable Stream</code>执向<code>stdout</code>(fd<code>1</code>).</p><p>例如：<code>console.log</code>的定义：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log = function(d) {\n  process.stdout.write(d + '\\n');\n};</code></pre><p><code>process.stderr</code>和<code>process.stdout</code>和 node 里的其他流不同，他们不会被关闭（<code>end()</code>将会被抛出），它们不会触发<code>finish</code>事件，并且写是阻塞的。</p><ul><li>引用指向常规文件或TTY文件描述符时，是阻塞的。</li><li>引用指向pipe管道时:<ul><li>在Linux/Unix里阻塞.</li><li>在Windows像其他流一样，不被阻塞</li></ul></li></ul><p>检查Node是否运行在TTY上下文中，从<code>process.stderr</code>，<code>process.stdout</code>或<code>process.stdin</code>里读取<code>isTTY</code>属性。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">$ node -p \"Boolean(process.stdin.isTTY)\"\ntrue\n$ echo \"foo\" | node -p \"Boolean(process.stdin.isTTY)\"\nfalse\n\n$ node -p \"Boolean(process.stdout.isTTY)\"\ntrue\n$ node -p \"Boolean(process.stdout.isTTY)\" | cat\nfalse</code></pre><p>更多信息参见<a href=\"xml71iu7.html\" target=\"_blank\">the tty docs</a>。</p><h2 class=\"head2\">process.stderr</h2><p>一个指向stderr (fd<code>2</code>)的可写流。</p><p><code>process.stderr</code>和<code>process.stdout</code>和node里的其他流不同，他们不会被关闭（<code>end()</code>将会被抛出），它们不会触发<code>finish</code>事件，并且写是阻塞的。</p><ul><li>引用指向常规文件或TTY文件描述符时，是阻塞的。</li><li>引用指向pipe管道时:<ul><li>在Linux/Unix里阻塞</li><li>在Windows像其他流一样，不被阻塞</li></ul></li></ul><h2 class=\"head2\">process.stdin</h2><p>一个指向stdin (fd<code>0</code>)的可读流。</p><p>以下例子：打开标准输入流，并监听两个事件:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.stdin.setEncoding('utf8');\n\nprocess.stdin.on('readable', function() {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write('data: ' + chunk);\n  }\n});\n\nprocess.stdin.on('end', function() {\n  process.stdout.write('end');\n});</code></pre><p><code>process.stdin</code>可以工作在老模式里，和v0.10之前版本的node代码兼容。</p><p>更多信息参见<a href=\"ocq11itw.html\" target=\"_blank\">Stream compatibility</a>.</p><p>在老的流模式里，stdin流默认暂停，必须调用<code>process.stdin.resume()</code>读取。可以调用<code>process.stdin.resume()</code>切换到老的模式。</p><p>如果开始一个新的工程，最好选择新的流，而不是用老的流。</p><h2 class=\"head2\">process.argv</h2><p>包含命令行参数的数组。第一个元素是'node'，第二个参数是JavaScript文件的名字，第三个参数是任意的命令行参数。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// print process.argv\nprocess.argv.forEach(function(val, index, array) {\n  console.log(index + ': ' + val);\n});</code></pre><p>将会生成：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four</code></pre><h2 class=\"head2\">process.execPath</h2><p>开启当前进程的执行文件的绝对路径。</p><p>例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">/usr/local/bin/node</code></pre><h2 class=\"head2\">process.execArgv</h2><p>启动进程所需的 node 命令行参数。这些参数不会在<code>process.argv</code>里出现，并且不包含node执行文件的名字，或者任何在名字之后的参数。这些用来生成子进程，使之拥有和父进程有相同的参数。</p><p>例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">$ node --harmony script.js --version</code></pre><p>process.execArgv 的参数：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">['--harmony']</code></pre><p>process.argv 的参数：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">['/usr/local/bin/node', 'script.js', '--version']</code></pre><h2 class=\"head2\">process.abort()</h2><p>这将导致node触发abort事件。会让node退出并生成一个核心文件。</p><h2 class=\"head2\">process.chdir(directory)</h2><p>改变当前工作进程的目录，如果操作失败抛出异常。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('Starting directory: ' + process.cwd());\ntry {\n  process.chdir('/tmp');\n  console.log('New directory: ' + process.cwd());\n}\ncatch (err) {\n  console.log('chdir: ' + err);\n}</code></pre><h2 class=\"head2\">process.cwd()</h2><p>返回当前进程的工作目录：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('Current directory: ' + process.cwd());</code></pre><h2 class=\"head2\">process.env</h2><p>包含用户环境的对象，参见environ(7).</p><p>这个对象的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ TERM: 'xterm-256color',\n  SHELL: '/usr/local/bin/bash',\n  USER: 'maciej',\n  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',\n  PWD: '/Users/maciej',\n  EDITOR: 'vim',\n  SHLVL: '1',\n  HOME: '/Users/maciej',\n  LOGNAME: 'maciej',\n  _: '/usr/local/bin/node' }</code></pre><p>你可以写入这个对象，但是不会改变当前运行的进程。以下的命令不会成功：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">node -e 'process.env.foo = \"bar\"' &amp;&amp; echo $foo</code></pre><p>这个会成功：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.env.foo = 'bar';\nconsole.log(process.env.foo);</code></pre><h2 class=\"head2\">process.exit([code])</h2><p>使用指定的code结束进程。如果忽略，将会使用code  <code>0</code></p><p>使用失败的代码退出：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.exit(1);</code></pre><p>Shell将会看到退出代码为1.</p><h2 class=\"head2\">process.exitCode</h2><p>进程退出时的代码，如果进程优雅的退出，或者通过<code>process.exit()</code>退出，不需要指定退出码。</p><p>设定<code>process.exit(code)</code>将会重写之前设置的<code>process.exitCode</code>。</p><h2 class=\"head2\">process.getgid()</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>获取进程的群组标识（参见getgid(2)）。获取到得时群组的数字id，而不是名字。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">if (process.getgid) {\n  console.log('Current gid: ' + process.getgid());\n}</code></pre><h2 class=\"head2\">process.setgid(id)</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows 和 Android)。</p><p>设置进程的群组标识（参见setgid(2)）。可以接收数字ID或者群组名。如果指定了群组名，会阻塞等待解析为数字ID 。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">if (process.getgid &amp;&amp; process.setgid) {\n  console.log('Current gid: ' + process.getgid());\n  try {\n    process.setgid(501);\n    console.log('New gid: ' + process.getgid());\n  }\n  catch (err) {\n    console.log('Failed to set gid: ' + err);\n  }\n}</code></pre><h2 class=\"head2\">process.getuid()</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>获取进程的用户标识(参见getuid(2))。这是数字的用户id，不是用户名：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">if (process.getuid) {\n  console.log('Current uid: ' + process.getuid());\n}</code></pre><h2 class=\"head2\">process.setuid(id)</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>设置进程的用户标识（参见setuid(2)）。接收数字ID或字符串名字。果指定了群组名，会阻塞等待解析为数字ID。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">if (process.getuid &amp;&amp; process.setuid) {\n  console.log('Current uid: ' + process.getuid());\n  try {\n    process.setuid(501);\n    console.log('New uid: ' + process.getuid());\n  }\n  catch (err) {\n    console.log('Failed to set uid: ' + err);\n  }\n}</code></pre><h2 class=\"head2\">process.getgroups()</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>返回进程的群组iD数组。POSIX系统没有保证一定有，但是node.js保证有。</p><h2 class=\"head2\">process.setgroups(groups)</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>设置进程的群组ID。这是授权操作，所有你需要有root权限，或者有CAP_SETGID能力。</p><p>列表可以包含群组IDs，群组名，或者两者都有。</p><h2 class=\"head2\">process.initgroups(user, extra_group)</h2><p>注意：这个函数仅在POSIX平台上可用(例如，非Windows和Android)。</p><p>读取/etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有root权限，或者有CAP_SETGID能力。</p><p><code>user</code>是用户名或者用户ID，<code>extra_group</code>是群组名或群组ID。</p><p>当你在注销权限 (dropping privileges) 的时候需要注意. 例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log(process.getgroups());         // [ 0 ]\nprocess.initgroups('bnoordhuis', 1000);   // switch user\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     // drop root gid\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre><h2 class=\"head2\">process.version</h2><p>一个编译属性，包含<code>NODE_VERSION</code>。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('Version: ' + process.version);</code></pre><h2 class=\"head2\">process.versions</h2><p>一个属性，包含了node的版本和依赖。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log(process.versions);</code></pre><p>打印出来：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ http_parser: '1.0',\n  node: '0.10.4',\n  v8: '3.14.5.8',\n  ares: '1.9.0-DEV',\n  uv: '0.10.3',\n  zlib: '1.2.3',\n  modules: '11',\n  openssl: '1.0.1e' }</code></pre><h2 class=\"head2\">process.config</h2><p>一个包含用来编译当前node执行文件的javascript配置选项的对象。它与运行./configure 脚本生成的\"config.gypi\"文件相同。</p><p>一个可能的输出：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ target_defaults:\n   { cflags: [],\n     default_configuration: 'Release',\n     defines: [],\n     include_dirs: [],\n     libraries: [] },\n  variables:\n   { host_arch: 'x64',\n     node_install_npm: 'true',\n     node_prefix: '',\n     node_shared_cares: 'false',\n     node_shared_http_parser: 'false',\n     node_shared_libuv: 'false',\n     node_shared_v8: 'false',\n     node_shared_zlib: 'false',\n     node_use_dtrace: 'false',\n     node_use_openssl: 'true',\n     node_shared_openssl: 'false',\n     strict_aliasing: 'true',\n     target_arch: 'x64',\n     v8_use_snapshot: 'true' } }</code></pre><h2 class=\"head2\">process.kill(pid[, signal])</h2><p>发送信号给进程。<code>pid</code>是进程id，并且<code>signal</code>是发送的信号的字符串描述。信号名是字符串，比如'SIGINT'或'SIGHUP'。如果忽略，信号会是'SIGTERM'。更多信息参见<a href=\"#process_signal_%E4%BA%8B%E4%BB%B6\">Signal 事件</a>和kill(2) .</p><p>如果进程没有退出，会抛出错误。信号<code>0</code>可以用来测试进程是否存在。</p><p>注意，虽然这个这个函数名叫<code>process.kill</code>，它真的仅是信号发射器，就像<code>kill</code>系统调用。信号发射可以做其他事情，不仅是杀死目标进程。</p><p>例子， 给自己发信号：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">process.on('SIGHUP', function() {\n  console.log('Got SIGHUP signal.');\n});\n\nsetTimeout(function() {\n  console.log('Exiting.');\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, 'SIGHUP');</code></pre><p>注意：当Node.js接收到SIGUSR1信号，它会开启debugger调试模式, 参见<a href=\"#process_signal_events\">Signal Events</a>.</p><h2 class=\"head2\">process.pid</h2><p>当前进程的PID：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('This process is pid ' + process.pid);</code></pre><h2 class=\"head2\">process.title</h2><p>获取/设置(Getter/setter) 'ps'中显示的进程名。</p><p>使用setter时，字符串的长度由系统指定，可能会很短。</p><p>在Linux和OS X上，它受限于名称的长度加上命令行参数的长度，因为它会覆盖参数内存(argv memory)。</p><p>v0.8版本允许更长的进程标题字符串，也支持覆盖环境内存，但是存在潜在的不安全和混乱（很难说清楚）。</p><h2 class=\"head2\">process.arch</h2><p>当前CPU的架构：'arm'、'ia32'或者'x64'。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('This processor architecture is ' + process.arch);</code></pre><h2 class=\"head2\">process.platform</h2><p>运行程序所在的平台系统<code>'darwin'</code>，<code>'freebsd'</code>，<code>'linux'</code>，<code>'sunos'</code>或者<code>'win32'</code></p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('This platform is ' + process.platform);</code></pre><h2 class=\"head2\">process.memoryUsage()</h2><p>返回一个对象，描述了Node进程所用的内存状况，单位为字节。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var util = require('util');\n\nconsole.log(util.inspect(process.memoryUsage()));</code></pre><p>将会生成：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }</code></pre><p><code>heapTotal</code>和<code>heapUsed</code>指V8的内存使用情况。</p><h2 class=\"head2\">process.nextTick(callback)</h2><ul><li><code>callback</code>{Function}</li></ul><p>一旦当前事件循环结束，调用回到函数。</p><p>这不是<code>setTimeout(fn, 0)</code>的简单别名，这个效率更高。在任何附加I/O事件在子队列事件循环中触发前，它就会运行。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log('start');\nprocess.nextTick(function() {\n  console.log('nextTick callback');\n});\nconsole.log('scheduled');\n// Output:\n// start\n// scheduled\n// nextTick callback</code></pre><p>在对象构造后，在I/O事件发生前，你又想改变附加事件处理函数时，这个非常有用。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(function() {\n    this.startDoingStuff();\n  }.bind(this));\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n// thing.startDoingStuff() gets called now, not before.</code></pre><p>要保证你的函数一定是100%同步执行，或者100%异步执行。例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre><p>这个API非常危险.  如果你这么做：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">maybeSync(true, function() {\n  foo();\n});\nbar();</code></pre><p>不清楚<code>foo()</code>或<code>bar()</code>哪个先执行。</p><p>更好的方法：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre><p>注意：nextTick队列会在完全执行完毕之后才调用I/O操作。因此，递归设置nextTick的回调就像一个<code>while(true);</code>循环一样，将会阻止任何I/O操作的发生。</p><h2 class=\"head2\">process.umask([mask])</h2><p>设置或读取进程文件的掩码。子进程从父进程继承掩码。如果<code>mask</code>参数有效，返回旧的掩码。否则，返回当前掩码。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var oldmask, newmask = 0022;\n\noldmask = process.umask(newmask);\nconsole.log('Changed umask from: ' + oldmask.toString(8) +\n            ' to ' + newmask.toString(8));</code></pre><h2 class=\"head2\">process.uptime()</h2><p>返回Node已经运行的秒数。</p><h2 class=\"head2\">process.hrtime()</h2><p>返回当前进程的高分辨时间，形式为<code>[seconds, nanoseconds]</code>数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。</p><p>你可以将之前的结果传递给当前的<code>process.hrtime()</code>，会返回两者间的时间差，用来基准和测量时间间隔。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var time = process.hrtime();\n// [ 1800216, 25 ]\n\nsetTimeout(function() {\n  var diff = process.hrtime(time);\n  // [ 1, 552 ]\n\n  console.log('benchmark took %d nanoseconds', diff[0] * 1e9 + diff[1]);\n  // benchmark took 1000000527 nanoseconds\n}, 1000);</code></pre><h2 class=\"head2\">process.mainModule</h2><p><code>require.main</code>的备选方法。不同点，如果主模块在运行时改变，<code>require.main</code>可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</p><p>该<code>process.mainModule</code>属性提供了一种替代的检索方式<code>require.main</code>。不同之处在于，如果主模块在运行时发生更改，<code>require.main</code>可能仍会引用发生更改之前所需模块中的原始主模块。通常，假设这两个参照相同的模块是安全的。<br></p><p>和<code>require.main</code>一样, 如果没有入口脚本，将会返回<code>undefined</code>。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 30,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b8aca0050277f4e27d6a199abd4c28d5",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js TLS/SSL",
      "chapter_level_two_url": "/nodejs/a18q1iu5.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>TLS/SSL</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">Stability: 3 - Stable</code></pre><p>Node.js可以使用<code>require('tls')</code>来访问TLS/SSL模块：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const tls = require('tls');</code></pre><p><code>tls</code>模块使用OpenSSL来提供传输层安全性（Transport Layer Security，TLS）和安全套接层（Secure Socket Layer，SSL）：加密过的流通讯。</p><p>TLS/SSL是一种公钥/私钥基础架构，每个客户端和服务端都需要一个私钥。私钥的创建方法如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">openssl genrsa -out ryans-key.pem 2048</code></pre><p>你还需要为所有服务器和某些客户端添加证书。证书由认证中心（Certificate Authority）签名，或者自签名。获得证书第一步是创建一个证书签名请求\"Certificate Signing Request\" (CSR)文件。证书的创建方法如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</code></pre><p>使用CSR创建一个自签名的证书：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre><p>或者你可以发送CSR给认证中心（Certificate Authority）来签名。</p><p>(TODO: 创建CA的文档，感兴趣的读者可以在Node源码<code>test/fixtures/keys/Makefile</code>里查看)</p><p>创建.pfx或.p12，可以这么做：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \\\n    -certfile ca-cert.pem -out agent5.pfx</code></pre><ul><li><code>in</code>: 签名证书</li><li><code>inkey</code>: 关联的私钥</li><li><code>certfile</code>: 是将所有证书颁发机构 (CA) 证书连接到单个文件中，例如，<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code><br></li></ul><h2 class=\"head2\">协议支持</h2><p>Node.js默认遵循SSLv2和SSLv3协议，不过这些协议被禁用。因为他们不太可靠，很容易受到威胁，参见<a rel=\"nofollow\" href=\"https://access.redhat.com/articles/1232123\" target=\"_blank\">CVE-2014-3566</a>。某些情况下，旧版本客户端/服务器（比如 IE6）可能会产生问题。如果你想启用SSLv2或SSLv3 ，使用参数<code>--enable-ssl2</code>或<code>--enable-ssl3</code>运行Node。Node.js的未来版本中不会再默认编译SSLv2 和SSLv3。</p><p>有一个办法可以强制node进入仅使用SSLv3或SSLv2模式，分别指定<code>secureProtocol</code>为<code>'SSLv3_method'</code>或<code>'SSLv2_method'</code>。</p><p>Node.js使用的默认协议方法准确名字是<code>AutoNegotiate_method</code>， 这个方法会尝试并协商客户端支持的从高到底协议。为了提供默认的安全级别，Node.js(v0.10.33 版本之后)通过将<code>secureOptions</code>设为<code>SSL_OP_NO_SSLv3|SSL_OP_NO_SSLv2</code> ，明确的禁用了SSLv3和SSLv2（除非你给<code>secureProtocol</code> 传值<code>--enable-ssl3</code>，或<code>--enable-ssl2</code>，或<code>SSLv3_method</code>）。</p><p>如果你设置了<code>secureOptions</code>，我们不会重新这个参数。</p><p>改变这个行为的后果：</p><ul><li>如果你的应用被当做为安全服务器，<code>SSLv3</code>客户端不能协商建立连接，会被拒绝。这种情况下，你的服务器会触发<code>clientError</code>事件。错误消息会包含错误版本数字(<code>'wrong version number'</code>)。</li><li>如果你的应用被当做安全客户端，和一个不支持比SSLv3更高安全性的方法的服务器通讯，你的连接不会协商成功。这种情况下，你的客户端会触发 <code>clientError</code>事件。错误消息会包含错误版本数字(<code>'wrong version number'</code>)。</li></ul><h2 class=\"head2\">Client-initiated renegotiation attack mitigation</h2><p>TLS协议让客户端协商TLS会话的某些方法内容。但是，会话协商需要服务器端响应的资源，这回让它成为阻断服务攻击（denial-of-service attacks）的潜在媒介。</p><p>为了降低这种情况的发生，重新协商被限制为每10分钟3次。当超出这个界限时，在<a href=\"#tls_class_tls_tlssocket\">tls.TLSSocket</a>实例上会触发错误。这个限制可设置：</p><ul><li><p><code>tls.CLIENT_RENEG_LIMIT</code>: 重新协商limit，默认是3。</p></li><li><code>tls.CLIENT_RENEG_WINDOW</code>: 重新协商窗口的时间，单位秒，默认是10分钟。</li></ul><p>除非你明确知道自己在干什么，否则不要改变默认值。</p><p>要测试你的服务器的话，使用<code>openssl s_client -connect address:port</code>连接服务器，并敲<code>R&lt;CR&gt;</code>（字母 R 键加回车）几次。</p><h2 class=\"head2\">NPN 和 SNI</h2><p>NPN(Next Protocol Negotiation 下次协议协商)和SNI (Server Name Indication 域名指示)都是TLS握手扩展：</p><ul><li>NPN - 同一个TLS服务器使用多种协议 (HTTP, SPDY)</li><li>SNI - 同一个TLS服务器使用多个主机名（不同的 SSL 证书）。certificates.</li></ul><h2 class=\"head2\">完全正向保密</h2><p>\"<a rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/Perfect_forward_secrecy\" target=\"_blank\">Forward Secrecy</a>\"或\"Perfect Forward Secrecy-完全正向保密\"协议描述了秘钥协商（比如秘钥交换）方法的特点。实际上这意味着及时你的服务器的秘钥有危险，通讯仅有可能被一类人窃听，他们必须设法获的每次会话都会生成的秘钥对。</p><p>完全正向保密是通过每次握手时为秘钥协商随机生成密钥对来完成（和所有会话一个key相反）。实现这个技术（提供完全正向保密-Perfect Forward Secrecy）的方法被称为\"ephemeral\"。</p><p>通常目前有2个方法用于完成完全正向保密（Perfect Forward Secrecy）:</p><ul><li><a rel=\"nofollow\" href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\" target=\"_blank\">DHE</a> - 一个迪菲-赫尔曼密钥交换密钥协议（Diffie Hellman key-agreement protocol）短暂（ephemeral）版本。</li><li><a rel=\"nofollow\" href=\"https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman\" target=\"_blank\">ECDHE</a> - 一个椭圆曲线密钥交换密钥协议（ Elliptic Curve Diffie Hellman key-agreement protocol）短暂（ephemeral）版本。</li></ul><p>短暂（ephemeral）方法有性能缺点，因为生成 key 非常耗费资源。</p><h2 class=\"head2\">tls.getCiphers()</h2><p>返回支持的SSL密码名数组。</p><p>例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var ciphers = tls.getCiphers();\nconsole.log(ciphers); // ['AES128-SHA', 'AES256-SHA', ...]</code></pre><p><a name=\"tls_tls_createserver_options_secureconnectionlistener\"></a></p><h2 class=\"head2\">tls.createServer(options[, secureConnectionListener])</h2><p>创建一个新的<a href=\"#tls_class_tls_server\">tls.Server</a>。参数<code>connectionListener</code>会自动设置为<a href=\"#tls_event_secureconnection\">secureConnection</a>事件的监听器。参数<code>options</code>对象有以下可能性：</p><ul><li><p><code>pfx</code>: 包含私钥，证书和服务器的CA证书（PFX或PKCS12 格式）字符串或缓存<code>Buffer</code>。（<code>key</code>，<code>cert</code>和<code>ca</code>互斥）。</p></li><li><p><code>key</code>: 包含服务器私钥（PEM格式）字符串或缓存<code>Buffer</code>。（可以是keys的数组）（必传）。</p></li><li><p><code>passphrase</code>: 私钥或pfx的密码字符串  </p></li><li><p><code>cert</code>: 包含服务器证书key（PEM格式）字符串或缓存<code>Buffer</code>。（可以是certs的数组）（必传）。</p></li><li><p><code>ca</code>: 信任的证书（PEM格式）的字符串/缓存数组。如果忽略这个参数，将会使用\"root\" CAs ，比如VeriSign。用来授权连接。</p></li><li><p><code>crl</code> : 不是PEM编码CRLs （证书撤销列表 Certificate Revocation List）的字符串就是字符串列表.</p></li><li><p><code>ciphers</code>: 要使用或排除的密码（cipher）字符串</p><p>为了减轻<a rel=\"nofollow\" href=\"http://blog.ivanristic.com/2011/10/mitigating-the-beast-attack-on-tls.html\" target=\"_blank\">BEAST attacks</a> ，推荐使用这个参数和之后会提到的<code>honorCipherOrder</code>参数来优化non-CBC密码（cipher）</p><p>默认：<code>ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL</code>。格式上更多细节参见<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\" target=\"_blank\">OpenSSL cipher list format documentation</a></p><p><code>ECDHE-RSA-AES128-SHA256</code>, <code>DHE-RSA-AES128-SHA256</code>和<code>AES128-GCM-SHA256</code>都是TLS v1.2密码（cipher），当node.js连接OpenSSL 1.0.1或更早版本（比如）时使用。注意，<code>honorCipherOrder</code>设置为enabled后，现在仍然可以和TLS v1.2客户端协商弱密码（cipher），</p><p><code>RC4</code>可作为客户端和老版本TLS协议通讯的备用方法。<code>RC4</code>这些年受到怀疑，任何对信任敏感的对象都会考虑其威胁性。国家级别（state-level）的参与者拥有中断它的能力。</p><p><strong>注意</strong>: 早些版本的修订建议，<code>AES256-SHA</code>作为可以接受的密码（cipher）.Unfortunately,<code>AES256-SHA</code>是一个CBC密码（cipher），容易受到<a rel=\"nofollow\" href=\"http://blog.ivanristic.com/2011/10/mitigating-the-beast-attack-on-tls.html\" target=\"_blank\">BEAST attacks</a> 攻击，不要使用它。  </p></li><li><p><code>ecdhCurve</code>: 包含用来ECDH秘钥交换弧形（curve）名字符串，或者false禁用ECDH。</p><p>默认<code>prime256v1</code>。更多细节参考<a rel=\"nofollow\" href=\"http://www.rfc-editor.org/rfc/rfc4492.txt\" target=\"_blank\">RFC 4492</a> 。</p></li><li><p><code>dhparam</code>: DH参数文件，用于DHE秘钥协商。使用<code>openssl dhparam</code>命令来创建。如果加载文件失败，会悄悄的抛弃它。</p></li><li><p><code>handshakeTimeout</code>: 如果SSL/TLS握手事件超过这个参数，会放弃里连接。默认是120秒.</p><p>握手超时后，<code>tls.Server</code>对象会触发<code>'clientError</code>'事件。</p></li><li><p><code>honorCipherOrder</code>: 当选择一个密码（cipher）时，使用服务器配置，而不是客户端的。  </p><p>虽然这个参数默认不可用，还是推荐你用这个参数，和<code>ciphers</code>参数连接使用，减轻BEAST攻击。</p><p>注意，如果使用了SSLv2，服务器会发送自己的配置列表给客户端，客户端会挑选密码（cipher）。默认不支持SSLv2，除非node.js配置了<code>./configure --with-sslv2</code>。</p></li><li><p><code>requestCert</code>: 如果设为<code>true</code>，服务器会要求连接的客户端发送证书，并尝试验证证书。默认：<code>false</code>。</p></li><li><p><code>rejectUnauthorized</code>: 如果为<code>true</code>，服务器将会拒绝任何不被CAs列表授权的连接。仅<code>requestCert</code>参数为<code>true</code>时这个参数才有效。默认：<code>false</code>。</p></li><li><p><code>checkServerIdentity(servername, cert)</code>: 提供一个重写的方法来检查证书对应的主机名。如果验证失败，返回error。如果验证通过，返回<code>undefined</code>。</p></li><li><p><code>NPNProtocols</code>: NPN协议的<code>Buffer</code>数组（协议需按优先级排序）。</p></li><li><p><code>SNICallback(servername, cb)</code>: 如果客户端支持SNI TLS扩展会调用这个函数。会传入2个参数：<code>servername</code>和<code>cb</code>。<code>SNICallback</code>必须调用 <code>cb(null, ctx)</code>，其中<code>ctx</code>是SecureContext实例。（你可以用<code>tls.createSecureContext(...)</code>来获取相应的SecureContext上下文）。如果  <code>SNICallback</code>没有提供，将会使用高级的API（参见下文）.</p></li><li><p><code>sessionTimeout</code>: 整数，设定了服务器创建TLS会话标示符（TLS session identifiers）和TLS会话票据（TLS session tickets）后的超时时间（单位：秒）。更多细节参见：<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html\" target=\"_blank\">SSL_CTX_set_timeout</a>。</p></li><li><p><code>ticketKeys</code>: 一个48字节的<code>Buffer</code>实例，由16字节的前缀，16字节的hmac key，16字节的AES key组成。可用用它来接受tls服务器实例上的tls会话票据（tls session tickets）。</p><p>注意: 自动在集群模块（ <code>cluster</code> module）工作进程间共享。</p></li><li><p><code>sessionIdContext</code>: 会话恢复（session resumption）的标示符字符串。如果<code>requestCert</code>为<code>true</code>。默认值为命令行生成的MD5哈希值。否则不提供默认值。</p></li><li><p><code>secureProtocol</code>: SSL使用的方法，例如，<code>SSLv3_method</code>强制SSL版本为3。可能的值定义于你所安装的OpenSSL中的常量<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS\" target=\"_blank\">SSL_METHODS</a>。</p></li><li><code>secureOptions</code>: 设置服务器配置。例如设置<code>SSL_OP_NO_SSLv3</code>可用禁用SSLv3协议。所有可用的参数见<a rel=\"nofollow\" href=\"https://www.openssl.org/docs/ssl/SSL_CTX_set_options.html\" target=\"_blank\">SSL_CTX_set_options</a></li></ul><p>响应服务器的简单例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  key: fs.readFileSync('server-key.pem'),\n  cert: fs.readFileSync('server-cert.pem'),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n  // This is necessary only if the client uses the self-signed certificate.\n  ca: [ fs.readFileSync('client-cert.pem') ]\n};\n\nvar server = tls.createServer(options, function(socket) {\n  console.log('server connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  socket.write(\"welcome!\\n\");\n  socket.setEncoding('utf8');\n  socket.pipe(socket);\n});\nserver.listen(8000, function() {\n  console.log('server bound');\n});</code></pre><p>或者：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('server.pfx'),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n};\n\nvar server = tls.createServer(options, function(socket) {\n  console.log('server connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  socket.write(\"welcome!\\n\");\n  socket.setEncoding('utf8');\n  socket.pipe(socket);\n});\nserver.listen(8000, function() {\n  console.log('server bound');\n});</code></pre><p>你可以通过<code>openssl s_client</code>连接服务器来测试：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">openssl s_client -connect 127.0.0.1:8000</code></pre><p><a name=\"tls_tls_connect_options_callback\"></a></p><h2 class=\"head2\">tls.connect(options[, callback])</h2><h2 class=\"head2\">tls.connect(port[, host][, options][, callback])</h2><p>创建一个新的客户端连接到指定的端口和主机（<code>port</code> and <code>host</code>）（老版本API），或者<code>options.port</code>和<code>options.host</code>（如果忽略<code>host</code>，默认为 <code>localhost</code>）。<code>options</code>是一个包含以下值得对象：</p><ul><li><p><code>host</code>: 客户端需要连接到的主机。</p></li><li><p><code>port</code>: 客户端需要连接到的端口。</p></li><li><p><code>socket</code>: 在指定的socket（而非新建）上建立安全连接。如果这个参数有值，将忽略<code>host</code>和<code>port</code>参数。</p></li><li><p><code>path</code>: 创建 到参数<code>path</code>的unix socket连接。如果这个参数有值，将忽略<code>host</code>和<code>port</code>参数。</p></li><li><p><code>pfx</code>: 包含私钥，证书和客户端（PFX或PKCS12格式）的CA证书的字符串或<code>Buffer</code>缓存。</p></li><li><p><code>key</code>: 包含客户端（PEM格式）的 私钥的字符串或<code>Buffer</code>缓存。可以是keys数组。</p></li><li><p><code>passphrase</code>: 私钥或pfx的密码字符串。</p></li><li><p><code>cert</code>: 包含客户端证书key（PEM格式）字符串或缓存<code>Buffer</code>。（可以是certs的数组）。  </p></li><li><p><code>ca</code>: 信任的证书（PEM格式）的字符串/缓存数组。如果忽略这个参数，将会使用\"root\" CAs ，比如VeriSign。用来授权连接。</p></li><li><p><code>rejectUnauthorized</code>: 如果为<code>true</code>，服务器证书根据CAs列表授权列表验证。如果验证失败，触发<code>'error'</code>事件；<code>err.code</code>包含OpenSSL错误代码。默认：<code>true</code>。</p></li><li><p><code>NPNProtocols</code>: NPN协议的字符串或<code>Buffer</code>数组。<code>Buffer</code>必须有以下格式<code>0x05hello0x05world</code>，第一个字节是下一个协议名字的长度。（传的数组通常非常简单，比如：<code>['hello', 'world']</code>）。</p></li><li><p><code>servername</code>: SNI（域名指示 Server Name Indication） TLS扩展的服务器名。</p></li><li><p><code>secureProtocol</code>: SSL使用的方法，例如，<code>SSLv3_method</code>强制SSL版本为3。可能的值定义于你所安装的OpenSSL中的常量<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS\" target=\"_blank\">SSL_METHODS</a>。</p></li><li><code>session</code>: 一个<code>Buffer</code>实例，包含TLS会话.</li></ul><p>将参数<code>callback</code>添加到<a href=\"#tls_event_secureconnect\">'secureConnect'</a>事件上，其效果如同监听器。</p><p><code>tls.connect()</code>返回一个<a href=\"#tls_class_tls_tlssocket\">tls.TLSSocket</a>对象。</p><p>这是一个简单的客户端应答服务器例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  // These are necessary only if using the client certificate authentication\n  key: fs.readFileSync('client-key.pem'),\n  cert: fs.readFileSync('client-cert.pem'),\n\n  // This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync('server-cert.pem') ]\n};\n\nvar socket = tls.connect(8000, options, function() {\n  console.log('client connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding('utf8');\nsocket.on('data', function(data) {\n  console.log(data);\n});\nsocket.on('end', function() {\n  server.close();\n});</code></pre><p>或者：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('client.pfx')\n};\n\nvar socket = tls.connect(8000, options, function() {\n  console.log('client connected',\n              socket.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(socket);\n  process.stdin.resume();\n});\nsocket.setEncoding('utf8');\nsocket.on('data', function(data) {\n  console.log(data);\n});\nsocket.on('end', function() {\n  server.close();\n});</code></pre><h2 class=\"head2\">类: tls.TLSSocket</h2><p><a href=\"sbua1itx.html\" target=\"_blank\">net.Socket</a>实例的封装，取代内部socket读写程序，执行透明的输入/输出数据的加密/解密。</p><h2 class=\"head2\">new tls.TLSSocket(socket, options)</h2><p>从现有的TCP socket里构造一个新的TLSSocket对象。</p><p><code>socket</code>一个<a href=\"sbua1itx.html\" target=\"_blank\">net.Socket</a>的实例</p><p><code>options</code>一个包含以下属性的对象:</p><ul><li><p><code>secureContext</code>: 来自<code>tls.createSecureContext( ... )</code>的可选TLS上下文对象。</p></li><li><p><code>isServer</code>: 如果为true， TLS socket将会在服务器模式(server-mode)初始化。  </p></li><li><p><code>server</code>: 一个可选的<a href=\"sbua1itx.html\" target=\"_blank\">net.Server</a>实例</p></li><li><p><code>requestCert</code>: 可选的，参见<a href=\"#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized\">tls.createSecurePair</a></p></li><li><p><code>rejectUnauthorized</code>: 可选的，参见<a href=\"#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized\">tls.createSecurePair</a></p></li><li><p><code>NPNProtocols</code>: 可选的，参见<a href=\"#tls_tls_createserver_options_secureconnectionlistener\">tls.createServer</a></p></li><li><p><code>SNICallback</code>: 可选的，参见<a href=\"#tls_tls_createserver_options_secureconnectionlistener\">tls.createServer</a></p></li><li><p><code>session</code>: 可选的，一个<code>Buffer</code>实例，包含TLS会话</p></li><li><code>requestOCSP</code>: 可选的，如果为<code>true</code>- OCSP状态请求扩展将会被添加到客户端hello，并且<code>OCSPResponse</code>事件将会在socket上建立安全通讯前触发。</li></ul><h2 class=\"head2\">tls.createSecureContext(details)</h2><p>创建一个凭证（credentials）对象，包含字典有以下的key：</p><ul><li><code>pfx</code> : 包含PFX或PKCS12加密的私钥，证书和服务器的CA证书（PFX或PKCS12格式）字符串或缓存<code>Buffer</code>。（<code>key</code>，<code>cert</code>和<code>ca</code>互斥）。</li><li><code>key</code> : 包含PEM加密过的私钥的字符串。</li><li><code>passphrase</code> : 私钥或pfx的密码字符串。  </li><li><code>cert</code> : 包含PEM加密过的证书的字符串。</li><li><code>ca</code> : 信任的PEM加密过的可信任的证书（PEM格式）字符串/缓存数组。  </li><li><code>crl</code> :PEM加密过的CRLs（证书撤销列表）</li><li><code>ciphers</code>: 要使用或排除的密码（cipher）字符串。更多格式上的细节参见<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\" target=\"_blank\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a></li><li><code>honorCipherOrder</code> : 当选择一个密码（cipher） 时, 使用服务器配置，而不是客户端的。  更多细节参见<code>tls</code>模块文档。</li></ul><p>如果没给 'ca' 细节，node.js 将会使用默认的公开信任的 CAs 列表（参见<a rel=\"nofollow\" href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\" target=\"_blank\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>）。</p><h2 class=\"head2\">tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized])</h2><p>创建一个新的安全对（secure pair）对象，包含2个流，其中一个读/写加密过的数据，另外一个读/写明文数据。通常加密端数据来自是从输入的加密数据流，另一端被当做初始加密流。</p><ul><li><p><code>credentials</code>: 来自tls.createSecureContext( ... )的安全上下文对象。</p></li><li><p><code>isServer</code>: 是否以服务器/客户端模式打开这个tls连接。</p></li><li><p><code>requestCert</code>: 是否服务器需要连接的客户端发送证书。仅适用于服务端连接。  </p></li><li><code>rejectUnauthorized</code>:非法证书时，是否服务器需要自动拒绝客户端。启用<code>requestCert</code>后，才适用于服务器。</li></ul><p><code>tls.createSecurePair()</code>返回一个安全对（SecurePair）对象，包含明文<code>cleartext</code>和密文<code>encrypted</code>流 。</p><p>注意: <code>cleartext</code>和<a href=\"#tls_class_tls_tlssocket\">tls.TLSSocket</a>拥有相同的 API。</p><h2 class=\"head2\">类: SecurePair</h2><p>通过tls.createSecurePair返回。</p><h3>事件: 'secure'</h3><p>一旦安全对（SecurePair）成功建立一个安全连接，安全对（SecurePair）将会触发这个事件。</p><p>和检查服务器'secureConnection'事件一样，pair.cleartext.authorized必须检查确认是否适用的证书是授权过的。  </p><h2 class=\"head2\">类: tls.Server</h2><p>这是<code>net.Server</code>的子类，拥有相同的方法。这个类接受适用TLS或SSL的加密连接，而不是接受原始TCP连接。</p><h3>事件: 'secureConnection'</h3><p><code>function (tlsSocket) {}</code></p><p>新的连接握手成功后回触发这个事件。参数是<a href=\"#tls_class_tls_tlssocket\">tls.TLSSocket</a>实例。它拥有常用的流方法和事件。</p><p><code>socket.authorized</code>是否客户端被证书（服务器提供）授权。如果<code>socket.authorized</code>为false，<code>socket.authorizationError</code>是如何授权失败。值得一提的是，依赖于TLS服务器的设置，你的未授权连接可能也会被接受。<code>socket.authorizationError</code>如何授权失败。值得一提的是，依赖于TLS服务器的设置，你的未授权连接可能也会被接受。<code>socket.npnProtocol</code>包含选择的NPN协议的字符串。<code>socket.servername</code>包含SNI请求的服务器名的字符串。</p><h3>事件: 'clientError'</h3><p><code>function (exception, tlsSocket) { }</code></p><p>在安全连接建立前，客户端连接触发'error'事件会转发到这里来。</p><p><code>tlsSocket</code>是<a href=\"#tls_class_tls_tlssocket\">tls.TLSSocket</a>，错误是从这里触发的。</p><h3>事件: 'newSession'</h3><p><code>function (sessionId, sessionData, callback) { }</code></p><p>创建TLS会话的时候会触发。可能用来在外部存储器里存储会话。<code>callback</code>必须最后调用，否则没法从安全连接发送/接收数据。</p><p>注意： 添加这个事件监听器仅会在连接连接时有效果。</p><h3>事件: 'resumeSession'</h3><p><code>function (sessionId, callback) { }</code></p><p>当客户端想恢复之前的TLS会话时会触发。事件监听器可能会使用<code>sessionId</code>到外部存储器里查找，一旦结束会触发<code>callback(null, sessionData)</code>。如果会话不能恢复（比如不存在这个会话），可能会调用<code>callback(null, null)</code>。调用<code>callback(err)</code>将会终止连接，并销毁socket。</p><p>注意： 添加这个事件监听器仅会在连接连接时有效果。</p><h3>事件: 'OCSPRequest'</h3><p><code>function (certificate, issuer, callback) { }</code></p><p>当客户端发送证书状态请求时会触发。你可以解析服务器当前的证书，来获取OCSP网址和证书id，获取OCSP响应调用<code>callback(null, resp)</code>，其中<code>resp</code>是 <code>Buffer</code>实例。证书（<code>certificate</code>）和发行者（<code>issuer</code>）都是初级表达式缓存（<code>Buffer</code>DER-representations of the primary）和证书的发行者。它可以用来获取OCSP证书和OCSP终点网址。</p><p>可以调用<code>callback(null, null)</code>，表示没有OCSP响应。</p><p>调用<code>callback(err)</code>可能会导致调用<code>socket.destroy(err)</code>。</p><p>典型流程:</p><ol><li>客户端连接服务器，并发送<code>OCSPRequest</code>(通过 ClientHello 里的状态信息扩展)。</li><li>服务器收到请求，调用<code>OCSPRequest</code>事件监听器。</li><li>服务器从<code>certificate</code>或<code>issuer</code>获取OCSP网址，并执行<a rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/OCSP_stapling\" target=\"_blank\">OCSP request</a>到CA</li><li>服务器CA收到<code>OCSPResponse</code>， 并通过<code>callback</code>参数送回到客户端</li><li>客户端验证响应，并销毁socket或执行握手</li></ol><p>注意: 如果证书是自签名的，或者如果发行者不再根证书列表里（你可以通过参数提供一个发行者）。<code>issuer</code>就可能为null。  </p><p>注意：添加这个事件监听器仅会在连接连接时有效果。</p><p>注意：你可以能想要使用npm模块（比如<a rel=\"nofollow\" href=\"http://npmjs.org/package/asn1.js\" target=\"_blank\">asn1.js</a>）来解析证书。</p><h3>server.listen(port[, host][, callback])</h3><p>在指定的端口和主机上开始接收连接。如果<code>host</code>参数没传，服务接受通过IPv4地址(<code>INADDR_ANY</code>)的直连。</p><p>这是异步函数。当服务器已经绑定后回调用最后一个参数<code>callback</code>。</p><p>更多信息参见<code>net.Server</code>。</p><h3>server.close()</h3><p>停止服务器，不再接收新连接。这是异步函数，当服务器触发<code>'close'</code>事件后回最终关闭。</p><h3>server.address()</h3><p>返回绑定的地址，地址家族名和服务器端口。更多信息参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.address()</a></p><h3>server.addContext(hostname, context)</h3><p>如果客户端请求SNI主机名和传入的<code>hostname</code>相匹配，将会用到安全上下文（secure context）。<code>context</code>可以包含<code>key</code>，<code>cert</code>，<code>ca</code>和/或<code>tls.createSecureContext</code><code>options</code>参数的其他任何属性。</p><h3>server.maxConnections</h3><p>设置这个属性可以在服务器的连接数达到最大值时拒绝连接。</p><h3>server.connections</h3><p>当前服务器连接数。</p><h2 class=\"head2\">类: CryptoStream</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 0 - 抛弃. 使用 tls.TLSSocket 替代.</code></pre><p>这是一个加密的流</p><h3>cryptoStream.bytesWritten</h3><p>底层socket写字节访问器（bytesWritten accessor）的代理，将会返回写到socket的全部字节数。包括 TLS 的开销。</p><h2 class=\"head2\">类: tls.TLSSocket</h2><p><a href=\"sbua1itx.html\" target=\"_blank\">net.Socket</a>实例的封装，透明的加密写数据和所有必须的TLS协商。</p><p>这个接口实现了一个双工流接口。它包含所有常用的流方法和事件。</p><h3>事件: 'secureConnect'</h3><p>新的连接成功握手后回触发这个事件。无论服务器证书是否授权，都会调用监听器。用于用户测试<code>tlsSocket.authorized</code>看看如果服务器证书已经被指定的CAs签名。如果<code>tlsSocket.authorized === false</code> ，可以在<code>tlsSocket.authorizationError</code>里找到错误。如果使用了NPN，你可以检<code>tlsSocket.npnProtocol</code>获取协商协议（negotiated protocol）。</p><h3>事件: 'OCSPResponse'</h3><p><code>function (response) { }</code></p><p>如果启用<code>requestOCSP</code>参赛会触发这个事件。<code>response</code>是缓存对象，包含服务器的OCSP响应。</p><p>一般来说，<code>response</code>是服务器CA签名的对象，它包含服务器撤销证书状态的信息。</p><h3>tlsSocket.encrypted</h3><p>静态boolean变量，一直是<code>true</code>。可以用来区别TLS socket和常规对象。</p><h3>tlsSocket.authorized</h3><p>boolean变量，如果对等实体证书（peer's certificate）被指定的某个CAs签名，返回<code>true</code>，否则<code>false</code>。</p><h3>tlsSocket.authorizationError</h3><p>对等实体证书（peer's certificate）没有验证通过的原因。当<code>tlsSocket.authorized === false</code>时，这个属性才可用。</p><h3>tlsSocket.getPeerCertificate([ detailed ])</h3><p>返回一个代表对等实体证书（ peer's certificate）的对象。这个返回对象有一些属性和证书内容相对应。如果参数<code>detailed</code>是<code>true</code>，将会返回包含发行者<code>issuer</code>完整链。如果<code>false</code>，仅有顶级证书没有发行者<code>issuer</code>属性。</p><p>例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ subject:\n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  issuerInfo:\n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  issuer:\n   { ... another certificate ... },\n  raw: &lt; RAW DER buffer &gt;,\n  valid_from: 'Nov 11 09:52:22 2009 GMT',\n  valid_to: 'Nov  6 09:52:22 2029 GMT',\n  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF',\n  serialNumber: 'B9B0D332A1AA5635' }</code></pre><p>如果peer没有提供证书，返回<code>null</code>或空对象。</p><h3>tlsSocket.getCipher()</h3><p>返回一个对象，它代表了密码名和当前连接的SSL/TLS协议的版本。</p><p>例子：{ name: 'AES256-SHA', version: 'TLSv1/SSLv3' }</p><p>更多信息参见http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS里的SSL_CIPHER_get_name()和SSL_CIPHER_get_version() 。</p><h3>tlsSocket.renegotiate(options, callback)</h3><p>初始化 TLS 重新协商进程。参数<code>options</code>可能包含以下内容：<code>rejectUnauthorized</code>，<code>requestCert</code>(细节参见<a href=\"#tls_tls_createserver_options_secureconnectionlistener\" target=\"_blank\">tls.createServer</a>)。一旦重新协商成（renegotiation）功完成，将会执行<code>callback(err)</code>，其中<code>err</code>为<code>null</code>。</p><p>注意：当安全连接建立后，可以用这来请求对等实体证书（peer's certificate）。</p><p>注意：作为服务器运行时，<code>handshakeTimeout</code>超时后，socket将会被销毁。</p><h3>tlsSocket.setMaxSendFragment(size)</h3><p>设置最大的TLS碎片大小（默认最大值为：<code>16384</code>，最小值为：<code>512</code>）。成功的话，返回<code>true</code>，否则返回<code>false</code>。</p><p>小的碎片包会减少客户端的缓存延迟：大的碎片直到接收完毕后才能被TLS层完全缓存，并且验证过完整性；大的碎片可能会有多次往返，并且可能会因为丢包或重新排序导致延迟。而小的碎片会增加额外的TLS帧字节和CPU负载，这会减少CPU的吞吐量。</p><h3>tlsSocket.getSession()</h3><p>返回ASN.1编码的TLS会话，如果没有协商，会返回。连接到服务器时，可以用来加速握手的建立。 </p><h3>tlsSocket.getTLSTicket()</h3><p>注意：仅和客户端TLS socket打交道。仅在调试时有用，会话重用是，提供<code>session</code>参数给<code>tls.connect</code>。</p><p>返回TLS会话票据（ticket），或如果没有协商（negotiated），返回<code>undefined</code>。</p><h3>tlsSocket.address()</h3><p>返回绑定的地址，地址家族名和服务器端口。更多信息参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.address()</a>。返回三个属性, 比如：<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code></p><h3>tlsSocket.remoteAddress</h3><p>表示远程IP地址（字符串表示），例如：<code>'74.125.127.100'</code>或<code>'2001:4860:a005::68'</code>.</p><h3>tlsSocket.remoteFamily</h3><p>表示远程 IP 家族，<code>'IPv4'</code>或<code>'IPv6'</code>。</p><h3>tlsSocket.remotePort</h3><p>远程端口（数字表示），例如，<code>443</code>。</p><h3>tlsSocket.localAddress</h3><p>本地IP地址（字符串表示）。</p><h3>tlsSocket.localPort</h3><p>本地端口号（数字表示）。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 29,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "68095358520cd83d4ab0fd4c15903a9d",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 域",
      "chapter_level_two_url": "/nodejs/gx171iu4.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>域</h2><pre><code class=\"hljs\">稳定性: 2 - 不稳定</code></pre><p>Node.js域包含了能把不同的IO操作看成单独组的方法。如果任何一个注册到域的事件或者回调触发<code>error</code>事件，或者抛出一个异常，则域就会接收到通知，而不是在<code>process.on('uncaughtException')</code>处理程序中丢失错误的上下文，也不会使程序立即以错误代码退出。<br></p><h2 class=\"head2\">警告：不要忽视错误!</h2><p>你不能将域错误处理程序看做错误发生时就关闭进程的一个替代方案。<br></p><p>根据JavaScript中抛出异常的工作原理，基本上没有方法可以安全的“回到原先离开的位置”，在不泄露引用，或者不造成一些其他未定义的状态下。</p><p>响应抛出错误最安全的方法就是关闭进程。一个正常的服务器会可能有很多活跃的连接，因为某个错误就关闭所有连接显然是不合理的。</p><p>比较好的方法是给触发错误的请求发送错误响应，让其他连接正常工作时，停止监听触发错误的人的新请求。</p><p>按这种方法，<code>域</code>和集群（cluster）模块可以协同工作，当某个进程遇到错误时，主进程可以复制一个新的进程。对于Node程序，终端代理或者注册的服务，可以留意错误并做出反应。</p><p>举例来说，下面的代码就不是好办法：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// XXX WARNING!  BAD IDEA!\n\nvar d = require('domain').create();\nd.on('error', function(er) {\n  // The error won't crash the process, but what it does is worse!\n  // Though we've prevented abrupt process restarting, we are leaking\n  // resources like crazy if this ever happens.\n  // This is no better than process.on('uncaughtException')!\n  console.log('error, but oh well', er.message);\n});\nd.run(function() {\n  require('http').createServer(function(req, res) {\n    handleRequest(req, res);\n  }).listen(PORT);\n});</code></pre><p>通过使用域的上下文，并将程序切为多个工作进程，我们能够更合理的响应，处理错误更安全：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// 好一些的做法!\n\nvar cluster = require('cluster');\nvar PORT = +process.env.PORT || 1337;\n\nif (cluster.isMaster) {\n  // In real life, you'd probably use more than just 2 workers,\n  // and perhaps not put the master and worker in the same file.\n  //\n  // You can also of course get a bit fancier about logging, and\n  // implement whatever custom logic you need to prevent DoS\n  // attacks and other bad behavior.\n  //\n  // See the options in the cluster documentation.\n  //\n  // The important thing is that the master does very little,\n  // increasing our resilience to unexpected errors.\n\n  cluster.fork();\n  cluster.fork();\n\n  cluster.on('disconnect', function(worker) {\n    console.error('disconnect!');\n    cluster.fork();\n  });\n\n} else {\n  // the worker\n  //\n  // This is where we put our bugs!\n\n  var domain = require('domain');\n\n  // See the cluster documentation for more details about using\n  // worker processes to serve requests.  How it works, caveats, etc.\n\n  var server = require('http').createServer(function(req, res) {\n    var d = domain.create();\n    d.on('error', function(er) {\n      console.error('error', er.stack);\n\n      // Note: we're in dangerous territory!\n      // By definition, something unexpected occurred,\n      // which we probably didn't want.\n      // Anything can happen now!  Be very careful!\n\n      try {\n        // make sure we close down within 30 seconds\n        var killtimer = setTimeout(function() {\n          process.exit(1);\n        }, 30000);\n        // But don't keep the process open just for that!\n        killtimer.unref();\n\n        // stop taking new requests.\n        server.close();\n\n        // Let the master know we're dead.  This will trigger a\n        // 'disconnect' in the cluster master, and then it will fork\n        // a new worker.\n        cluster.worker.disconnect();\n\n        // try to send an error to the request that triggered the problem\n        res.statusCode = 500;\n        res.setHeader('content-type', 'text/plain');\n        res.end('Oops, there was a problem!\\n');\n      } catch (er2) {\n        // oh well, not much we can do at this point.\n        console.error('Error sending 500!', er2.stack);\n      }\n    });\n\n    // Because req and res were created before this domain existed,\n    // we need to explicitly add them.\n    // See the explanation of implicit vs explicit binding below.\n    d.add(req);\n    d.add(res);\n\n    // Now run the handler function in the domain.\n    d.run(function() {\n      handleRequest(req, res);\n    });\n  });\n  server.listen(PORT);\n}\n\n// This part isn't important.  Just an example routing thing.\n// You'd put your fancy application logic here.\nfunction handleRequest(req, res) {\n  switch(req.url) {\n    case '/error':\n      // We do some async stuff, and then...\n      setTimeout(function() {\n        // Whoops!\n        flerb.bark();\n      });\n      break;\n    default:\n      res.end('ok');\n  }\n}</code></pre><h2 class=\"head2\">错误对象的附加内容</h2><p>任何时候一个错误被路由传到一个域的时，会添加几个字段。  </p><ul><li><code>error.domain</code> 第一个处理错误的域</li><li><code>error.domainEmitter</code>  用这个错误对象触发'error'事件的事件分发器</li><li><code>error.domainBound</code> 绑定到domain的回调函数，第一个参数是error。</li><li><code>error.domainThrown</code> boolean值，表明是抛出错误，分发，或者传递给绑定的回到函数。  </li></ul><h2 class=\"head2\">隐式绑定</h2><p>新分发的对象（包括流对象（Stream objects），请求（requests），响应（responses）等）会隐式的绑定到当前正在使用的域中。</p><p>另外，传递给底层事件循环（比如fs.open或其他接收回调的方法）的回调函数将会自动的绑定到这个域。如果他们抛出异常，域会捕捉到错误信息。</p><p>为了避免过度使用内存，域对象不会象隐式的添加为有效域的子对象。如果这样做的话，很容易影响到请求和响应对象的垃圾回收。</p><p>如果你想将域对象作为子对象嵌入到父域里，就必须显式的添加它们。  </p><p>隐式绑定路由抛出的错误和<code>'error'</code>事件，但是不会注册事件分发器到域，所以<code>domain.dispose()</code>不会关闭事件分发器。隐式绑定仅需注意抛出的错误和 <code>'error'</code>事件。 </p><h2 class=\"head2\">显式绑定</h2><p>有时候正在使用的域并不是某个事件分发器的域。或者说，事件分发器可能在某个域里创建，但是被绑定到另外一个域里。</p><p>例如，HTTP服务器使用正一个域对象，但我们希望可以每一个请求使用一个不同的域。</p><p>这可以通过显式绑定来实现。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// create a top-level domain for the server\nvar serverDomain = domain.create();\n\nserverDomain.run(function() {\n  // server is created in the scope of serverDomain\n  http.createServer(function(req, res) {\n    // req and res are also created in the scope of serverDomain\n    // however, we'd prefer to have a separate domain for each request.\n    // create it first thing, and add req and res to it.\n    var reqd = domain.create();\n    reqd.add(req);\n    reqd.add(res);\n    reqd.on('error', function(er) {\n      console.error('Error', er, req.url);\n      try {\n        res.writeHead(500);\n        res.end('Error occurred, sorry.');\n      } catch (er) {\n        console.error('Error sending 500', er, req.url);\n      }\n    });\n  }).listen(1337);\n});</code></pre><h2 class=\"head2\">domain.create()</h2><ul><li>return: {Domain}</li></ul><p>用于返回一个新的域对象。</p><h2 class=\"head2\">Class: Domain</h2><p>这个类封装了将错误和没有捕捉到的异常到有效对象功能。</p><p>域是<a href=\"aue11itf.html\" target=\"_blank\">EventEmitter</a>的子类.  监听它的<code>error</code>事件来处理捕捉到的错误。  </p><h3>domain.run(fn)</h3><ul><li><code>fn</code> {Function}</li></ul><p>在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</p><p>这是使用域的基本方法。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var d = domain.create();\nd.on('error', function(er) {\n  console.error('Caught error!', er);\n});\nd.run(function() {\n  process.nextTick(function() {\n    setTimeout(function() { // simulating some various async stuff\n      fs.open('non-existent file', 'r', function(er, fd) {\n        if (er) throw er;\n        // proceed...\n      });\n    }, 100);\n  });\n});</code></pre><p>这个例子里程序不会崩溃，而会触发<code>d.on('error')</code>。  </p><h3>domain.members</h3><ul><li>{Array}</li></ul><p>显式添加到域里的计时器和事件分发器数组。</p><h3>domain.add(emitter)</h3><ul><li><code>emitter</code> {EventEmitter | Timer} 添加到域里的计时器和事件分发器</li></ul><p>显式地将一个分发器添加到域。如果分发器调用的事件处理函数抛出错误，或者分发器遇到<code>error</code>事件，将会导向域的<code>error</code>事件，和隐式绑定一样。  </p><p>对于<code>setInterval</code>和<code>setTimeout</code>返回的计时器同样适用。如果这些回调函数抛出错误，将会被域的'error'处理器捕捉到。</p><p>如果计时器或分发器已经绑定到域，那它将会从上一个域移除，绑定到当前域。</p><h3>domain.remove(emitter)</h3><ul><li><code>emitter</code> {EventEmitter | Timer} 要移除的分发器或计时器</li></ul><p>与domain.add(emitter)函数恰恰相反，这个函数将分发器移除出域。</p><h3>domain.bind(callback)</h3><ul><li><code>callback</code> {Function} 回调函数</li><li>return: {Function}被绑定的函数</li></ul><p>返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的<code>error</code>事件。</p><h4>Example</h4><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, 'utf8', d.bind(function(er, data) {\n    // if this throws, it will also be passed to the domain\n    return cb(er, data ? JSON.parse(data) : null);\n  }));\n}\n\nd.on('error', function(er) {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});</code></pre><h3>domain.intercept(callback)</h3><ul><li><code>callback</code> {Function} 回调函数</li><li>return: {Function} 被拦截的函数</li></ul><p>和<code>domain.bind(callback)</code>类似。除了捕捉被抛出的错误外，它还会拦截Error对象作为参数传递到这个函数。  </p><p>这种方式下，常见的<code>if (er) return callback(er);</code>模式，能被一个地方一个错误处理替换。</p><h4>Example</h4><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, 'utf8', d.intercept(function(data) {\n    // note, the first argument is never passed to the\n    // callback since it is assumed to be the 'Error' argument\n    // and thus intercepted by the domain.\n\n    // if this throws, it will also be passed to the domain\n    // so the error-handling logic can be moved to the 'error'\n    // event on the domain instead of being repeated throughout\n    // the program.\n    return cb(null, JSON.parse(data));\n  }));\n}\n\nd.on('error', function(er) {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});</code></pre><h3>domain.enter()</h3><p>这个函数就像<code>run</code>，<code>bind</code>和<code>intercept</code>的管道系统，它设置有效域。它设定了域的<code>domain.active</code>和<code>process.domain</code>，还隐式的将域推到域模块管理的域栈（关于域栈的细节详见<code>domain.exit()</code>）。enter函数的调用，分隔了异步调用链以及绑定到一个域的I/O操作的结束或中断。</p><p>调用<code>enter</code>仅改变活动的域，而不改变域本身。在一个单独的域里可以调用任意多次<code>Enter</code>和<code>exit</code>。</p><h3>domain.exit()</h3><p><code>exit</code>函数退出当前域，并从域的栈里移除。每当程序的执行流程要切换到不同的异步调用链的时候，要保证退出当前域。调用exit函数，分隔了异步调用链，和绑定到一个域的I/O操作的结束或中断。</p><p>如果有多个嵌套的域绑定到当前的上下文，<code>exit</code>函数将会退出所有嵌套。</p><p>调用<code>exit</code>仅改变活跃域，不会改变自身域。在一个单独的域里可以调用任意多次<code>Enter</code>和<code>exit</code>。</p><p>如果在这个域名下exit已经被设置，exit将不退出域返回。</p><h3>domain.dispose()</h3><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 0 - 抛弃。通过域里设置的错误事件来显示的消除失败的 IO 操作。</code></pre><p>调用<code>dispos</code>后，通过run，bind或intercept绑定到域的回调函数不再使用这个域，并且分发<code>dispose</code>事件。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 28,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "31dd7c17e9651119a3d5ff6a49aefd9c",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 路径",
      "chapter_level_two_url": "/nodejs/xzel1iu3.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>路径</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>Node.js路径（path）模块包含一系列用于处理和转换文件路径的工具集。基本所有的反复都仅对字符串转换。文件系统不会检查路径是否有效。<br></p><p>你可以通过<code>require('path')</code>来访问这个模块：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const path = require('path');</code></pre><p>Node.js路径模块包含下文中介绍的方法：</p><h2 class=\"head2\">path.normalize(p)</h2><p>用于规范化路径，注意<code>'..'</code>和<code>'.'</code>。</p><p>发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。</p><p>Windows系统使用反斜杠。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.normalize('/foo/bar//baz/asdf/quux/..')\n// returns\n'/foo/bar/baz/asdf'</code></pre><h2 class=\"head2\">path.join([path1][, path2][, ...])</h2><p>用于连接所有的参数，并规范化输出路径。</p><p>参数必须是字符串。在v0.8版本，非字符参数会被忽略。v0.10之后的版本后抛出异常。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n// returns\n'/foo/bar/baz/asdf'\n\npath.join('foo', {}, 'bar')\n// throws exception\nTypeError: Arguments to path.join must be strings</code></pre><h2 class=\"head2\">path.resolve([from ...], to)</h2><p>能够将<code>to</code>参数解析为绝对路径。</p><p>如果参数<code>to</code>不是一个相对于参数<code>from</code>的绝对路径，<code>to</code>会添加到<code>from</code>右侧，直到找到一个绝对路径为止。如果使用所有<code>from</code>参数后，还是没有找到绝对路径，将会使用当前工作目录。返回的路径已经规范化过，并且去掉了尾部的斜杠（除非是根目录）。非字符串的参数会被忽略。</p><p>另一种思路就是在shell里执行一系列的<code>cd</code>命令。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')</code></pre><p>类似于：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">cd foo/bar\ncd /tmp/file/\ncd ..\ncd a/../subfile\npwd</code></pre><p>不同点是，不同的路径不需要存在的，也可能是文件。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.resolve('/foo/bar', './baz')\n// returns\n'/foo/bar/baz'\n\npath.resolve('/foo/bar', '/tmp/file/')\n// returns\n'/tmp/file'\n\npath.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n// if currently in /home/myself/node, it returns\n'/home/myself/node/wwwroot/static_files/gif/image.gif'</code></pre><h2 class=\"head2\">path.isAbsolute(path)</h2><p>判断参数<code>path</code>是否是绝对路径。一个绝对路径解析后都会指向相同的位置，无论当前的工作目录在哪里。</p><p>Posix例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.isAbsolute('/foo/bar') // true\npath.isAbsolute('/baz/..')  // true\npath.isAbsolute('qux/')     // false\npath.isAbsolute('.')        // false</code></pre><p>Windows例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.isAbsolute('//server')  // true\npath.isAbsolute('C:/foo/..') // true\npath.isAbsolute('bar\\\\baz')   // false\npath.isAbsolute('.')         // false</code></pre><h2 class=\"head2\">path.relative(from, to)</h2><p>解决从<code>from</code>到<code>to</code>的相对路径。</p><p>有时我们会有2个绝对路径，需要从中找到相对目录。这是<code>path.resolve</code>的逆实现：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n// returns\n'..\\\\..\\\\impl\\\\bbb'\n\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'</code></pre><h2 class=\"head2\">path.dirname(p)</h2><p>返回路径<code>p</code>所在的目录。和Unix<code>dirname</code>命令类似。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'</code></pre><h2 class=\"head2\">path.basename(p[, ext])</h2><p>返回路径的最后一个部分。和Unix<code>basename</code>命令类似。</p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'</code></pre><h2 class=\"head2\">path.extname(p)</h2><p>返回路径<code>p</code>的扩展名，从最后一个'.'到字符串的末尾。如果最后一个部分没有'.' ，或者路径是以'.'开头，则返回空字符串。例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.coffee.md')\n// returns\n'.md'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''</code></pre><h2 class=\"head2\">path.sep</h2><p>特定平台的文件分隔符，<code>'\\\\'</code>或<code>'/'</code>。</p><p>*nix上的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']</code></pre><p>Windows的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">'foo\\\\bar\\\\baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']</code></pre><h2 class=\"head2\">path.delimiter</h2><p>特定平台的分隔符，<code>;</code>或者<code>':'</code>。</p><p>*nix上的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log(process.env.PATH)\n// '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'\n\nprocess.env.PATH.split(path.delimiter)\n// returns\n['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin']</code></pre><p>Windows例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">console.log(process.env.PATH)\n// 'C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\nodejs\\'\n\nprocess.env.PATH.split(path.delimiter)\n// returns\n['C:\\\\Windows\\\\system32', 'C:\\\\Windows', 'C:\\\\Program Files\\\\nodejs\\\\']</code></pre><h2 class=\"head2\">path.parse(pathString)</h2><p>返回路径字符串的对象。</p><p>*nix上的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.parse('/home/user/dir/file.txt')\n// returns\n{\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n}</code></pre><p>Windows例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.parse('C:\\\\path\\\\dir\\\\index.html')\n// returns\n{\n    root : \"C:\\\\\",\n    dir : \"C:\\\\path\\\\dir\",\n    base : \"index.html\",\n    ext : \".html\",\n    name : \"index\"\n}</code></pre><h2 class=\"head2\">path.format(pathObject)</h2><p>从对象中返回路径字符串，和<code>path.parse</code>相反：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">path.format({\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n})\n// returns\n'/home/user/dir/file.txt'</code></pre><h2 class=\"head2\">path.posix</h2><p>提供上述<code>path</code>路径访问，不过总是以posix兼容的方式交互。</p><h2 class=\"head2\">path.win32</h2><p>提供上述<code>path</code>路径访问，不过总是以win32兼容的方式交互。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 27,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "3a3fd5a406a300c162b91092994fc6ac",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 定时器",
      "chapter_level_two_url": "/nodejs/8kdi1iu2.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>定时器</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 5 - 锁定</code></pre><p>Node.js定时器模块提供了全局API，用于在以后的某个时间段调用函数。</p><p>所有的定时器函数都是全局的。不需要通过<code>require()</code>就可以访问。</p><h2 class=\"head2\">setTimeout(callback, delay[, arg][, ...])</h2><p><code>delay</code>毫秒之后执行<code>callback</code>。返回<code>timeoutObject</code>对象，可能会用来<code>clearTimeout()</code>。你也可以给回调函数传参数。</p><p>需要注意，你的回调函数可能不会非常准确的在<code>delay</code>毫秒后执行，Node.js不保证回调函数的精确时间和执行顺序。回调函数会尽量的靠近指定的时间。</p><h2 class=\"head2\">clearTimeout(timeoutObject)</h2><p>阻止一个timeout被触发。</p><h2 class=\"head2\">setInterval(callback, delay[, arg][, ...])</h2><p>每隔<code>delay</code>毫秒就重复执行<code>callback</code>。返回<code>timeoutObject</code>对象，可能会用来<code>clearTimeout()</code>。你也可以给回调函数传参数。</p><h2 class=\"head2\">clearInterval(intervalObject)</h2><p>阻止一个interval被触发。</p><h2 class=\"head2\">unref()</h2><p><code>setTimeout</code>和<code>setInterval</code>所返回的值，拥有<code>timer.unref()</code>方法，它能让你创建一个活动的定时器，但是它所在的事件循环中如果仅剩它一个定时器，将不会保持程序运行。如果定时器已经调用了<code>unref</code>，再次调用将无效。</p><p>在<code>setTimeout</code>场景中，当你使用<code>unref</code>并创建了一个独立定时器它将会唤醒事件循环。创建太多的这样的东西会影响事件循环性能，所以谨慎使用。</p><h2 class=\"head2\">ref()</h2><p>如果你之前已经使用<code>unref()</code>一个定时器，就可以使用<code>ref()</code>来明确的请求定时器保持程序打开状态。如果计时器已经调用了<code>ref（）</code>，再次调用将无效。</p><h2 class=\"head2\">setImmediate(callback[, arg][, ...])</h2><p>在<code>setTimeout</code>和<code>setInterval</code>事件前，在输入/输出事件后，安排一个<code>callback</code>\"immediate\"立即执行。</p><p>immediates的回调以它们创建的顺序加入队列。整个回调队列会在事件循环迭代中执行。如果你将immediates加入到一个正在执行回调中，那么将不会触发immediate，直到下次事件循环迭代。</p><h2 class=\"head2\">clearImmediate(immediateObject)</h2><p>用于停止一个immediate的触发。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 26,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "c57596e8cc4f6c5eacecd4725695c0bd",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js DNS",
      "chapter_level_two_url": "/nodejs/653b1iu1.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>DNS</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>本节将介绍Node.js的DNS模块，你可以通过调用<code>require('dns')</code>来访问DNS模块。</p><p>DNS模块包含的函数属于2个不同的分类：</p><p>1）使用系统底层的特性，完成名字解析，这个过程不需要网络通讯，这个分类仅有一个函数：<code>dns.lookup</code>。<strong>开发者在同一个系统里名字解析都是用 <code>dns.lookup</code>。</strong></p><p>下面的例子解析了<code>www.google.com</code>：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var dns = require('dns');\n\ndns.lookup('www.google.com', function onLookup(err, addresses, family) {\n  console.log('addresses:', addresses);\n});</code></pre><p>2）连接到DNS服务器进行名字解析，<strong>始终</strong>使用网络来进行域名查询。这个分类包含除了<code>dns.lookup</code>外的所有函数。这些函数不会和<code>dns.lookup</code>使用同一套配置文件。如果你不想使用系统底层的特性来进行名字解析，而想进行DNS查询的话，可以使用这个分类的函数。</p><p>下面的例子，解析了<code>'www.google.com'</code>，并反向解析返回的IP地址：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var dns = require('dns');\n\ndns.resolve4('www.google.com', function (err, addresses) {\n  if (err) throw err;\n\n  console.log('addresses: ' + JSON.stringify(addresses));\n\n  addresses.forEach(function (a) {\n    dns.reverse(a, function (err, hostnames) {\n      if (err) {\n        throw err;\n      }\n\n      console.log('reverse for ' + a + ': ' + JSON.stringify(hostnames));\n    });\n  });\n});</code></pre><p>更多细节参考<a href=\"#dns_implementation_considerations\">Implementation considerations section</a>。</p><h2 class=\"head2\">dns.lookup(hostname[, options], callback)</h2><p>将域名（比如<code>'google.com'</code>）解析为第一条找到的记录A （IPV4）或AAAA（IPV6）。参数<code>options</code>可以是一个对象或整数。如果没有提供<code>options</code>，IP v4和 v6地址都可以。如果<code>options</code>是整数，则必须是<code>4</code>或<code>6</code>。</p><p><code>options</code>参数可能是包含<code>family</code>和<code>hints</code>两个属性的对象。这两个属性都是可选的。如果提供了<code>family</code>，则必须是<code>4</code>或<code>6</code>，否则，IP v4和v6地址都可以。如果提供了<code>hints</code>，可以是一个或者多个<code>getaddrinfo</code>标志，若不提供，没有标志会传给<code>getaddrinfo</code>。多个标志位可以通过或运算来整合。以下的例子展示如何使用<code>options</code>。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{\n  family: 4,\n  hints: dns.ADDRCONFIG | dns.V4MAPPED\n}</code></pre><p>参见<a href=\"#dns_supported_getaddrinfo_flags\">supported <code>getaddrinfo</code> flags</a> 查看更多的标志位。</p><p>回调函数包含参数 <code>(err, address, family)</code>。<code>address</code>参数表示IP v4或v6地址。<code>family</code>参数是4或6，表示<code>address</code>家族（不一定是之前传入lookup的值）。</p><p>出错时，参数<code>err</code>是<code>Error</code>对象，<code>err.code</code>是错误代码。请记住，<code>err.code</code>等于<code>'ENOENT'</code>，不仅可能是因为域名不存在，还有可能是是其他原因，比如没有可用文件描述符。</p><p><code>dns.lookup</code>不必和DNS协议有关系。它使用了操作系统的特性，能将名字和地址关联。</p><p>实现这些东西也许很简单，但是对于 Node.js 程序来说都重要，所以在使用前请花点时间阅读<a href=\"#dns_implementation_considerations\">Implementation considerations section</a>。</p><h2>dns.lookupService(address, port, callback)</h2><p>使用<code>getnameinfo</code>解析传入的地址和端口为域名和服务。</p><p>这个回调函数的参数是<code>(err, hostname, service)</code>。<code>hostname</code>和<code>service</code>都是字符串 (比如<code>'localhost'</code>和<code>'http'</code>）。</p><p>出错时，参数<code>err</code>是<code>Error</code>对象，<code>err.code</code>是错误代码。</p><h2 class=\"head2\">dns.resolve(hostname[, rrtype], callback)</h2><p>将一个域名（如'google.com'）解析为一个rrtype指定记录类型的数组。</p><p>有效的rrtypes值为:</p><ul><li><code>'A'</code> (IPV4地址，默认)</li><li><code>'AAAA'</code> (IPV6地址)</li><li><code>'MX'</code> (邮件交换记录)</li><li><code>'TXT'</code> (text记录)</li><li><code>'SRV'</code> (SRV记录)</li><li><code>'PTR'</code> (用来反向IP查找)</li><li><code>'NS'</code> (域名服务器记录)</li><li><code>'CNAME'</code> (别名记录)</li><li><code>'SOA'</code> (授权记录的初始值)</li></ul><p>回调参数为<code>(err, addresses)</code>.  其中<code>addresses</code>中每一项的类型都取决于记录类型，详见下文对应的查找方法。</p><p>出错时，参数<code>err</code>是 <code>Error</code> 对象，<code>err.code</code>是错误代码。</p><h2 class=\"head2\">dns.resolve4(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能查询IPv4 (<code>A</code>记录）。<code>addresses</code>IPv4地址数组 (比如，<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>）。</p><h2 class=\"head2\">dns.resolve6(hostname, callback)</h2><p>和<code>dns.resolve4()</code>类似，仅能查询 IPv4(<code>AAAA</code>查询）。</p><h2 class=\"head2\">dns.resolveMx(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能查询邮件交换(<code>MX</code>记录)。</p><p><code>addresses</code>是MX记录数组，每一个包含优先级和交换属性(比如，<code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>）。</p><h2 class=\"head2\">dns.resolveTxt(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能进行文本查询 (<code>TXT</code>记录）。<code>addresses</code>是2-d文本记录数组。(比如，<code>[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]</code>）。每个子数组包含一条记录的TXT块。根据使用情况可以连接在一起，也可单独使用。</p><h2 class=\"head2\">dns.resolveSrv(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能进行服务记录查询 (<code>SRV</code>记录）。<code>addresses</code>是<code>hostname</code>可用的SRV记录数组。SRV记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，<code>[{'priority': 10, 'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>）。</p><h2 class=\"head2\">dns.resolveSoa(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能查询权威记录(<code>SOA</code>记录）。</p><p><code>addresses</code>是包含以下结构的对象:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{\n  nsname: 'ns.example.com',\n  hostmaster: 'root.example.com',\n  serial: 2013101809,\n  refresh: 10000,\n  retry: 2400,\n  expire: 604800,\n  minttl: 3600\n}</code></pre><h2 class=\"head2\">dns.resolveNs(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能进行域名服务器记录查询(<code>NS</code>记录）。<code>addresses</code>是域名服务器记录数组（<code>hostname</code>可以使用） (比如，<code>['ns1.example.com', 'ns2.example.com']</code>）。</p><h2 class=\"head2\">dns.resolveCname(hostname, callback)</h2><p>和<code>dns.resolve()</code>类似，仅能进行别名记录查询 (<code>CNAME</code>记录)。<code>addresses</code>是对<code>hostname</code>可用的别名记录数组 (比如，<code>['bar.example.com']</code>）。</p><h2 class=\"head2\">dns.reverse(ip, callback)</h2><p>反向解析IP地址，返回指向该IP地址的域名数组。  </p><p>回调函数参数<code>(err, hostnames)</code>。</p><p>出错时，参数<code>err</code>是<code>Error</code>对象，<code>err.code</code>是错误代码。</p><h2 class=\"head2\">dns.getServers()</h2><p>返回一个用于当前解析的IP地址的数组的字符串。</p><h2 class=\"head2\">dns.setServers(servers)</h2><p>指定一组IP地址作为解析服务器。</p><p>如果你给地址指定了端口，端口会被忽略，因为底层库不支持。</p><p>传入无效参数，会抛出以下错误:</p><h2 class=\"head2\">Error codes</h2><p>每个DNS查询都可能返回以下错误:</p><ul><li><code>dns.NODATA</code>: DNS服务器返回无数据应答。 </li><li><code>dns.FORMERR</code>: DNS服务器声称查询格式错误。 </li><li><code>dns.SERVFAIL</code>: DNS服务器返回一般失败。 </li><li><code>dns.NOTFOUND</code>: 没有找到域名。 </li><li><code>dns.NOTIMP</code>: DNS服务器未实现请求的操作。 </li><li><code>dns.REFUSED</code>: DNS服务器拒绝查询。 </li><li><code>dns.BADQUERY</code>: DNS查询格式错误。 </li><li><code>dns.BADNAME</code>:  域名格式错误。 </li><li><code>dns.BADFAMILY</code>: 地址协议不支持。 </li><li><code>dns.BADRESP</code>: DNS回复格式错误。 </li><li><code>dns.CONNREFUSED</code>: 无法连接到DNS服务器。 </li><li><code>dns.TIMEOUT</code>: 连接DNS服务器超时。 </li><li><code>dns.EOF</code>: 文件末端。 </li><li><code>dns.FILE</code>: 读文件错误。 </li><li><code>dns.NOMEM</code>: 内存溢出。 </li><li><code>dns.DESTRUCTION</code>: 通道被摧毁。 </li><li><code>dns.BADSTR</code>: 字符串格式错误。 </li><li><code>dns.BADFLAGS</code>: 非法标识符。 </li><li><code>dns.NONAME</code>: 所给主机不是数字。 </li><li><code>dns.BADHINTS</code>: 非法HINTS标识符。 </li><li><code>dns.NOTINITIALIZED</code>: c c-ares库尚未初始化。 </li><li><code>dns.LOADIPHLPAPI</code>: 加载iphlpapi.dll出错。 </li><li><code>dns.ADDRGETNETWORKPARAMS</code>: 无法找到GetNetworkParams函数。 </li><li><code>dns.CANCELLED</code>: 取消DNS查询。 </li></ul><h2 class=\"head2\">支持的 getaddrinfo 标志</h2><p>以下内容可作为hints标志传给<code>dns.lookup</code>  </p><ul><li><code>dns.ADDRCONFIG</code>: 返回当前系统支持的地址类型。例如，如果当前系统至少配置了一个IPv4地址，则返回IPv4地址。</li><li><code>dns.V4MAPPED</code>: 如果指定了IPv6家族， 但是没有找到IPv6地址，将返回IPv4映射的IPv6地址。</li></ul><h2 class=\"head2\">Implementation considerations</h2><p>虽然<code>dns.lookup</code>和<code>dns.resolve*/dns.reverse</code>函数都能实现网络名和网络地址的关联，但是他们的行为不太一样。这些不同点虽然很巧妙，但是会对Node.js程序产生显著的影响。</p><h3>dns.lookup</h3><p><code>dns.lookup</code>和绝大多数程序一样使用了相同的系统特性。例如，<code>dns.lookup</code>和<code>ping</code>命令用相同的方法解析了一个指定的名字。多数类似POSIX的系统，<code>dns.lookup</code>函数可以通过改变<code>nsswitch.conf(5)</code>和/或<code>resolv.conf(5)</code>的设置调整。如果改变这些文件将会影响系统里的其他应用。</p><p>虽然，JavaScript调用是异步的，它的实现是同步的调用libuv线程池里的<code>getaddrinfo(3)</code>。因为libuv线程池固定大小，所以如果调用<code>getaddrinfo(3)</code> 的时间太长，会使的池里的其他操作（比如文件操作）性能降低。为了降低这个风险，可以通过增加'UV_THREADPOOL_SIZE'的值，让它超过4，来调整libuv线程池大小，更多信息参见[the official libuvdocumentation](<a rel=\"nofollow\" href=\"http://docs.libuv.org/en/latest/threadpool.html\" target=\"_blank\">http://docs.libuv.org/en/latest/threadpool.html</a>）。</p><h3>dns.resolve, functions starting with dns.resolve and dns.reverse</h3><p>这些函数的实现和<code>dns.lookup</code>不大相同。他们不会用到<code>getaddrinfo(3)</code>，而是始终进行网络查询。这些操作都是异步的，和libuv线程池无关。</p><p>因此，这些操作对于其他线程不会产生负面影响，这和<code>dns.lookup</code>不同。</p><p>它们不会用到<code>dns.lookup</code>的配置文件（例如 ，<code>/etc/hosts</code>_）。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 25,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "53164e9d5825c0286cb1ebd358f3e3bd",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 系统",
      "chapter_level_two_url": "/nodejs/1b871iu0.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>系统</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 4 - API 冻结</code></pre><p>Node.js系统（OS）模块提供一些与基本的操作系统有关的函数。<br></p><p>使用<code>require('os')</code>访问这个模块，如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const os = require('os');</code></pre><h3>os.tmpdir()</h3><p>用于返回操作系统的默认临时文件夹。</p><h3>os.endianness()</h3><p>用于返回CPU的字节序，可能的是\"BE\"或\"LE\"。</p><h3>os.hostname()</h3><p>用于返回操作系统的主机名。</p><h3>os.type()</h3><p>用于返回操作系统名。</p><h3>os.platform()</h3><p>用于返回操作系统名</p><h3>os.arch()</h3><p>用于返回操作系统CPU架构，可能的值有\"x64\"、\"arm\"和\"ia32\"。</p><h3>os.release()</h3><p>用于返回操作系统的发行版本</p><h3>os.uptime()</h3><p>用于返回操作系统运行的时间，以秒为单位。</p><h3>os.loadavg()</h3><p>用于显示原文其他翻译纠错返回一个包含1、5、15分钟平均负载的数组。</p><p>平均负载是系统的一个指标，操作系统计算，用一个很小的数字表示。理论上来说，平均负载最好比系统里的CPU低。  </p><p>平均负载是一个非常UNIX-y的概念，windows系统没有相同的概念。所以windows总是返回<code>[0, 0, 0]</code>。</p><h3>os.totalmem()</h3><p>用于返回系统内存总量，单位为字节。</p><h3>os.freemem()</h3><p>用于返回操作系统空闲内存量，单位是字节。</p><h3>os.cpus()</h3><p>用于返回一个对象数组，包含所安装的每个CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含user、nice、sys、idle和irq所使用CPU/内核毫秒数的对象）。</p><p>os.cpus的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">[ { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 252020,\n       nice: 0,\n       sys: 30340,\n       idle: 1070356870,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 306960,\n       nice: 0,\n       sys: 26980,\n       idle: 1071569080,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 248450,\n       nice: 0,\n       sys: 21750,\n       idle: 1070919370,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 256880,\n       nice: 0,\n       sys: 19430,\n       idle: 1070905480,\n       irq: 20 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 511580,\n       nice: 20,\n       sys: 40900,\n       idle: 1070842510,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 291660,\n       nice: 0,\n       sys: 34360,\n       idle: 1070888000,\n       irq: 10 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 308260,\n       nice: 0,\n       sys: 55410,\n       idle: 1071129970,\n       irq: 880 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 266450,\n       nice: 1480,\n       sys: 34920,\n       idle: 1072572010,\n       irq: 30 } } ]</code></pre><h2 class=\"head2\">os.networkInterfaces()</h2><p>获得网络接口列表的方法如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ lo:\n   [ { address: '127.0.0.1',\n       netmask: '255.0.0.0',\n       family: 'IPv4',\n       mac: '00:00:00:00:00:00',\n       internal: true },\n     { address: '::1',\n       netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',\n       family: 'IPv6',\n       mac: '00:00:00:00:00:00',\n       internal: true } ],\n  eth0:\n   [ { address: '192.168.1.108',\n       netmask: '255.255.255.0',\n       family: 'IPv4',\n       mac: '01:02:03:0a:0b:0c',\n       internal: false },\n     { address: 'fe80::a00:27ff:fe4e:66a1',\n       netmask: 'ffff:ffff:ffff:ffff::',\n       family: 'IPv6',\n       mac: '01:02:03:0a:0b:0c',\n       internal: false } ] }</code></pre><h3>os.EOL</h3><p>定义了操作系统的End-of-line的常量。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 24,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "6a68bcc57a7a15bba1d8d9de282e593f",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 字符串解码器",
      "chapter_level_two_url": "/nodejs/zach1itz.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>字符串解码器</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p>Node.js字符串解码器（string_decoder）模块的使用是通过<code>require('string_decoder')</code>实现的。<br></p><p>Node.js字符串解码器（string_decoder）用于将缓存（buffer）解码为字符串。这是<code>buffer.toString()</code>的简单接口，提供了utf8支持。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var StringDecoder = require('string_decoder').StringDecoder;\nvar decoder = new StringDecoder('utf8');\n\nvar cent = new Buffer([0xC2, 0xA2]);\nconsole.log(decoder.write(cent));\n\nvar euro = new Buffer([0xE2, 0x82, 0xAC]);\nconsole.log(decoder.write(euro));</code></pre><h2 class=\"head2\">Class: StringDecoder</h2><p>接受一个参数<code>encoding</code>，默认值为<code>utf8</code>。</p><h3>decoder.write(buffer)</h3><p>返回解码后的字符串。</p><h3>decoder.end()</h3><p>返回buffer里剩下的末尾字节。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 23,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "04f7d98e3c26cfb935ceb7ed35b963fa",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 调试器",
      "chapter_level_two_url": "/nodejs/mazx1ity.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>调试器</h2><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>V8提供了强大的调试工具，可以通过<a rel=\"nofollow\" href=\"http://code.google.com/p/v8/wiki/DebuggerProtocol\" target=\"_blank\">TCP protocol</a>从外部访问。Node内置这个调试工具客户端。使用这个调试器的方法是，以<code>debug</code>参数启动Node.js，将会出现提示，指示调试器成功启动：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">% node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug&gt;</code></pre><p>Node的调试器不支持所有的命令，但是简单的步进和检查还是可以的。在代码里嵌入<code>debugger;</code>，可以设置断点。</p><p>例：<code>myscript.js</code>代码如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">// myscript.js\nx = 5;\nsetTimeout(function () {\n  debugger;\n  console.log(\"world\");\n}, 1000);\nconsole.log(\"hello\");</code></pre><p>如果启动debugger，它会断在第四行：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">% node debug myscript.js\n&lt; debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug&gt; cont\n&lt; hello\nbreak in /home/indutny/Code/git/indutny/myscript.js:3\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log(\"world\");\n  5 }, 1000);\ndebug&gt; next\nbreak in /home/indutny/Code/git/indutny/myscript.js:4\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log(\"world\");\n  5 }, 1000);\n  6 console.log(\"hello\");\ndebug&gt; repl\nPress Ctrl + C to leave debug repl\n&gt; x\n5\n&gt; 2+2\n4\ndebug&gt; next\n&lt; world\nbreak in /home/indutny/Code/git/indutny/myscript.js:5\n  3   debugger;\n  4   console.log(\"world\");\n  5 }, 1000);\n  6 console.log(\"hello\");\n  7\ndebug&gt; quit\n%</code></pre><p><code>repl</code>命令能执行远程代码；<code>next</code>能步进到下一行。此外可以输入<code>help</code>查看哪些命令可用。</p><h2 class=\"head2\">监视器-Watchers</h2><p>调试的时候可以查看表达式和变量。每个断点处，监视器都会显示上下文。  </p><p>输入<code>watch(\"my_expression\")</code>开始监视表达式，<code>watchers</code>显示活跃的监视器。输入<code>unwatch(\"my_expression\")</code>可以移除监视器。  </p><h2 class=\"head2\">命令参考-Commands reference</h2><h3>步进-Stepping</h3><ul><li><code>cont</code>, <code>c</code>- 继续执行</li><li><code>next</code>, <code>n</code>- Step next</li><li><code>step</code>, <code>s</code>- Step in</li><li><code>out</code>, <code>o</code>- Step out</li><li><code>pause</code>- 暂停 (类似开发工具的暂停按钮)</li></ul><h3>断点Breakpoints</h3><ul><li><code>setBreakpoint()</code>, <code>sb()</code>- 当前行设置断点</li><li><code>setBreakpoint(line)</code>, <code>sb(line)</code>- 在指定行设置断点</li><li><code>setBreakpoint('fn()')</code>, <code>sb(...)</code>- 在函数里的第一行设置断点</li><li><code>setBreakpoint('script.js', 1)</code>, <code>sb(...)</code>- 在 script.js 第一行设置断点。</li><li><code>clearBreakpoint</code>, <code>cb(...)</code>- 清除断点</li></ul><p>也可以在尚未加载的文件里设置断点：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">% ./node debug test/fixtures/break-in-module/main.js\n&lt; debugger listening on port 5858\nconnecting to port 5858... ok\nbreak in test/fixtures/break-in-module/main.js:1\n  1 var mod = require('./mod.js');\n  2 mod.hello();\n  3 mod.hello();\ndebug&gt; setBreakpoint('mod.js', 23)\nWarning: script 'mod.js' was not loaded yet.\n  1 var mod = require('./mod.js');\n  2 mod.hello();\n  3 mod.hello();\ndebug&gt; c\nbreak in test/fixtures/break-in-module/mod.js:23\n 21\n 22 exports.hello = function() {\n 23   return 'hello from module';\n 24 };\n 25\ndebug&gt;</code></pre><h3>信息Info</h3><ul><li><code>backtrace</code>, <code>bt</code>- 打印当前执行框架的backtrace</li><li><code>list(5)</code>- 显示脚本代码的5行上下文（之前5行和之后5行）</li><li><code>watch(expr)</code>- 监视列表里添加表达式</li><li><code>unwatch(expr)</code>- 从监视列表里删除表达式</li><li><code>watchers</code>- 显示所有的监视器和它们的值（每个断点都会自动列出）  </li><li><code>repl</code>- 在所调试的脚本的上下文中，打开调试器的repl </li></ul><h3>执行控制Execution control</h3><ul><li><code>run</code>- 运行脚本 (开始调试的时候自动运行)</li><li><code>restart</code>- 重新运行脚本</li><li><code>kill</code>- 杀死脚本</li></ul><h3>杂项Various</h3><ul><li><code>scripts</code>- 列出所有已经加载的脚本</li><li><code>version</code>- 显示v8版本</li></ul><h2 class=\"head2\">高级应用Advanced Usage</h2><p>V8调试器可以用两种方法启用和访问，<code>--debug</code>命令启动调试，或向已经启动Node发送<code>SIGUSR1</code>。</p><p>一旦一个进程进入调试模式，它可以被node调试器连接。调试器可以通过<code>pid</code>或URI来连接。</p><ul><li><code>node debug -p &lt;pid&gt;</code>- 通过<code>pid</code>连接进程</li><li><code>node debug &lt;URI&gt;</code>- 通过URI（比如localhost:5858）连接进程w。</li></ul></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 22,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "8e211d1b75743868300d8306bed1a35e",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 网络",
      "chapter_level_two_url": "/nodejs/sbua1itx.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>网络</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 3 - 稳定</code></pre><p><code>\n\nnet</code>模块提供了异步网络封装，该Node.js模块包含了创建服务器/客户端的方法（调用 streams），你可以通过调用  <code>require('net')</code> 包含这个模块，访问方法如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const net = require('net');</code></pre><h2 class=\"head2\">net.createServer([options][, connectionListener])</h2><p>创建一个TCP服务器。参数<code>connectionListener</code>自动给<a href=\"#net_event_connection\">'connection'</a>事件创建监听器。</p><p><code>options</code>包含有以下默认值：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{\n  allowHalfOpen: false,\n  pauseOnConnect: false\n}</code></pre><p>如果<code>allowHalfOpen</code>=<code>true</code>，当另一端socket发送FIN包时，socket不会自动发送FIN包。socket变为不可读，但仍可写。你需要显式的调用<code>end()</code>方法。更多信息参见<a href=\"#net_event_end\">'end'</a>事件。</p><p>如果<code>pauseOnConnect</code>=<code>true</code>，当连接到来的时候相关联的socket将会暂停。它允许在初始进程不读取数据情况下，让连接在进程间传递。调用<code>resume()</code>从暂停的socket里读取数据。</p><p>下面是一个监听8124端口连接的应答服务器的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var net = require('net');\nvar server = net.createServer(function(c) { //'connection' listener\n  console.log('client connected');\n  c.on('end', function() {\n    console.log('client disconnected');\n  });\n  c.write('hello\\r\\n');\n  c.pipe(c);\n});\nserver.listen(8124, function() { //'listening' listener\n  console.log('server bound');\n});</code></pre><p>使用<code>telnet</code>来测试：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">telnet localhost 8124</code></pre><p>要监听socket t<code>/tmp/echo.sock</code>，仅需要改倒数第三行代码，如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">server.listen('/tmp/echo.sock', function() { //'listening' listener</code></pre><p>使用<code>nc</code>连接到一个UNIX domain socket服务器：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">nc -U /tmp/echo.sock</code></pre><h2 class=\"head2\">net.connect(options[, connectionListener])</h2><h2 class=\"head2\">net.createConnection(options[, connectionListener])</h2><p>工厂方法，返回一个新的<a href=\"#net_class_net_socket\">'net.Socket'</a>，并连接到指定的地址和端口。</p><p>当socket建立的时候，将会触发<a href=\"#net_event_connect\">'connect'</a>事件。</p><p>和<a href=\"#net_class_net_socket\">'net.Socket'</a>有相同的方法。</p><p>对于TCP sockets，参数<code>options</code>因为下列参数的对象：</p><ul><li><p><code>port</code>: 客户端连接到Port的端口（必须）。</p></li><li><p><code>host</code>: 客户端要连接到得主机。默认<code>'localhost'</code>.</p></li><li><p><code>localAddress</code>: 网络连接绑定的本地接口。</p></li><li><p><code>localPort</code>: 网络连接绑定的本地端口。</p></li><li><code>family</code> : IP栈版本。默认<code>4</code>。</li></ul><p>对于本地域socket，参数<code>options</code>因为下列参数的对象：</p><ul><li><code>path</code>: 客户端连接到得路径(必须).</li></ul><p>通用选项:</p><ul><li><p>如果<code>allowHalfOpen</code>=<code>true</code>， 当另一端socket发送FIN包时socket不会自动发送FIN包。socket变为不可读，但仍可写。你需要显式的调用<code>end()</code>方法。更多信息参见<a href=\"#net_event_end\">'end'</a>事件。</p><p><code>connectListener</code>参数将会作为监听器添加到<a href=\"#net_event_connect\">'connect'</a>事件上。</p></li></ul><p>下面是一个用上述方法应答服务器的客户端例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var net = require('net');\nvar client = net.connect({port: 8124},\n    function() { //'connect' listener\n  console.log('connected to server!');\n  client.write('world!\\r\\n');\n});\nclient.on('data', function(data) {\n  console.log(data.toString());\n  client.end();\n});\nclient.on('end', function() {\n  console.log('disconnected from server');\n});</code></pre><p>要连接到socket<code>/tmp/echo.sock</code>，仅需将第二行代码改为如下的内容：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var client = net.connect({path: '/tmp/echo.sock'});</code></pre><h2 class=\"head2\">net.connect(port[, host][, connectListener])</h2><h2 class=\"head2\">net.createConnection(port[, host][, connectListener])</h2><p>创建一个到端口<code>port</code>和主机<code>host</code>的TCP连接。如果忽略主机<code>host</code>，则假定为<code>'localhost'</code>。参数<code>connectListener</code>将会作为监听器添加到<a href=\"#net_event_connect\">'connect'</a>事件。</p><p>这是工厂方法，返回一个新的<a href=\"#net_class_net_socket\">'net.Socket'</a>。</p><h2 class=\"head2\">net.connect(path[, connectListener])</h2><h2 class=\"head2\">net.createConnection(path[, connectListener])</h2><p>创建到<code>path</code>的unix socket连接。参数<code>connectListener</code>将会作为监听器添加到<a href=\"#net_event_connect\">'connect'</a>事件上。</p><p>这是工厂方法，返回一个新的<a href=\"#net_class_net_socket\">'net.Socket'</a>。</p><h2 class=\"head2\">Class: net.Server</h2><p>这个类用来创建一个TCP或本地服务器。</p><h3>server.listen(port[, host][, backlog][, callback])</h3><p>开始接受指定端口<code>port</code>和主机<code>host</code>的连接。如果忽略主机<code>host</code>， 服务器将会接受任何IPv4地址(<code>INADDR_ANY</code>)的直接连接。端口为0，则会分配一个随机端口。</p><p>积压量（Backlog）为连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设定，比如 linux 上的<code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。这个参数默认值是511(不是512)。  </p><p>这是异步函数。当服务器被绑定时会触发<a href=\"#net_event_listening\">'listening'</a>事件。最后一个参数<code>callback</code>将会作为<a href=\"#net_event_listening\">'listening'</a>事件的监听器。</p><p>有些用户会遇到<code>EADDRINUSE</code>错误，它表示另外一个服务器已经运行在所请求的端口上。处理这个情况的办法是等一段事件再重试：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">server.on('error', function (e) {\n  if (e.code == 'EADDRINUSE') {\n    console.log('Address in use, retrying...');\n    setTimeout(function () {\n      server.close();\n      server.listen(PORT, HOST);\n    }, 1000);\n  }\n});</code></pre><p>(注意：Node中的所有socket已设置了<code>SO_REUSEADDR</code>)</p><h3>server.listen(path[, callback])</h3><ul><li><code>path</code> {String}</li><li><code>callback</code> {Function}</li></ul><p>启动一个本地socket服务器，监听指定<code>path</code>的连接。</p><p>这是异步函数。绑定服务器后，会触发<a href=\"#net_event_listening\">'listening'</a>事件。最后一个参数<code>callback</code>将会作为<a href=\"#net_event_listening\">'listening'</a>事件的监听器。</p><p>UNIX上，本地域通常默认为UNIX域。参数<code>path</code>是文件系统路径，就和创建文件时一样，它也遵从命名规则和权限检查，并且在文件系统里可见，并持续到关闭关联。</p><p>Windows上，本地域通过命名管道实现。路径必须是以<code>\\\\?\\pipe\\</code>或<code>\\\\.\\pipe\\</code>入口。任意字符串都可以，不过之后进行相同的管道命名处理，比如解决<code>..</code>序列。管道命名空间是平的。管道不会一直持久，当最后一个引用关闭的时候，管道将会移除。不要忘记javascript字符字符串转义要求路径使用双反斜杠，比如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">net.createServer().listen(\n    path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'myctl'))</code></pre><h3>server.listen(handle[, callback])</h3><ul><li><code>handle</code> {Object}</li><li><p><code>callback</code> {Function}</p><p><code>handle</code> 对象可以设置成server或socket（任意以下划线<code>_handle</code>开头的类），或者是<code>{fd: &lt;n&gt;}</code>对象。</p></li></ul><p>这将是服务器用指定的句柄接收连接，前提是文件描述符或句柄已经绑定到端口或域socket。</p><p>Windows不支持监听文件句柄。</p><p>这是异步函数。当服务器已经被绑定，将会触发<a href=\"#net_event_listening\">'listening'</a>事件。最后一个参数<code>callback</code>将会作为<a href=\"#net_event_listening\">'listening'</a>事件的监听器。</p><h3>server.listen(options[, callback])</h3><ul><li><code>options</code> {Object} - 必须有。支持以下属性：<ul><li><code>port</code> {Number} - 可选。</li><li><code>host</code> {String} - 可选。</li><li><code>backlog</code> {Number} - 可选。</li><li><code>path</code> {String} - 可选。</li><li><code>exclusive</code> {Boolean} - 可选。</li></ul></li><li><code>callback</code> {Function} - 可选。</li></ul><p><code>options</code>的属性：端口<code>port</code>，主机<code>host</code>，和<code>backlog</code>，以及可选参数callback函数，他们在一起调用<a href=\"#net_server_listen_port_host_backlog_callback\">server.listen(port, [host], [backlog], [callback])</a>。还有，参数<code>path</code>可以用来指定UNIX socket。</p><p>如果参数<code>exclusive</code>是<code>false</code>（默认值），集群进程将会使用同一个句柄，允许连接共享。当参数<code>exclusive</code>是<code>true</code>时，句柄不会共享，如果共享端口会返回错误。监听独家端口例子如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">server.listen({\n  host: 'localhost',\n  port: 80,\n  exclusive: true\n});</code></pre><h3>server.close([callback])</h3><p>服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发<code>'close'</code>事件。你可以传一个回调函数来监听<code>'close'</code> 事件。如果存在，将会调用回调函数，错误（如果有）作为唯一参数。</p><h3>server.address()</h3><p>操作系统返回绑定的地址，协议族名和服务器端口。查找哪个端口已经被系统绑定时，非常有用。返回的对象有3个属性，比如：<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code></p><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var server = net.createServer(function (socket) {\n  socket.end(\"goodbye\\n\");\n});\n\n// grab a random port.\nserver.listen(function() {\n  address = server.address();\n  console.log(\"opened server on %j\", address);\n});</code></pre><p>在<code>'listening'</code>事件触发前，不要调用<code>server.address()</code>。</p><h3>server.unref()</h3><p>如果这是事件系统中唯一一个活动的服务器，调用<code>unref</code>将允许程序退出。如果服务器已被unref，则再次调用unref并不会产生影响。</p><h3>server.ref()</h3><p>与<code>unref</code>相反，如果这是唯一的服务器，在之前被<code>unref</code>了的服务器上调用<code>ref</code>将不会让程序退出（默认行为）。如果服务器已经被<code>ref</code>，则再次调用<code>ref</code>并不会产生影响。</p><h3>server.maxConnections</h3><p>设置这个选项后，当服务器连接数超过数量时拒绝新连接。</p><p>一旦已经用<code>child_process.fork()</code>方法将socket发送给子进程， 就不推荐使用这个选项。</p><h3>server.connections</h3><p>已经抛弃这个函数。请用<a href=\"#net_server_getconnections_callback\" target=\"_blank\">server.getConnections()</a>代替。服务器上当前连接的数量。</p><p>当调用<code>child_process.fork()</code>发送一个socket给子进程时，它将变为<code>null</code>。 要轮询子进程来获取当前活动连接的数量，请用<code>server.getConnections</code>代替。</p><h3>server.getConnections(callback)</h3><p>异步获取服务器当前活跃连接的数量。当socket发送给子进程后才有效；  </p><p>回调函数有2个参数<code>err</code>和<code>count</code>。</p><p><code>net.Server</code>是事件分发器<a href=\"aue11itf.html#events_class_events_eventemitter\" target=\"_blank\">EventEmitter</a>， 有以下事件:</p><h3>事件： 'listening'</h3><p>当服务器调用<code>server.listen</code>绑定后会触发。</p><p><a name=\"net_event_connection\"></a></p><h3>事件：'connection'</h3><ul><li>{Socket object} 连接对象</li></ul><p>当新连接创建后会被触发。<code>socket</code>是<code>net.Socket</code>实例。</p><h3>事件： 'close'</h3><p>服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。</p><h3>事件： 'error'</h3><ul><li>{Error Object}</li></ul><p>发生错误时触发。'close'事件将被下列事件直接调用。请查看<code>server.listen</code>例子。</p><h2 class=\"head2\">Class: net.Socket</h2><p>这个对象是TCP或UNIX Socket的抽象。<code>net.Socket</code>实例实现了一个双工流接口。他们可以在用户创建客户端（使用connect()）时使用，或者由Node创建它们，并通过<code>connection</code>服务器事件传递给用户。</p><h3>new net.Socket([options])</h3><p>构造一个新的socket对象。</p><p><code>options</code>对象有以下默认值：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">{ fd: null\n  allowHalfOpen: false,\n  readable: false,\n  writable: false\n}</code></pre><p>参数<code>fd</code>允许你指定一个存在的文件描述符。将<code>readable</code>和（或）<code>writable</code>设为<code>true</code>，允许在这个socket上读和（或）写（注意，仅在参数<code>fd</code>有效时）。关于<code>allowHalfOpen</code>，参见<code>createServer()</code>和<code>'end'</code>事件。</p><h3>socket.connect(port[, host][, connectListener])</h3><h3>socket.connect(path[, connectListener])</h3><p>使用传入的socket打开一个连接。如果指定了端口<code>port</code>和主机<code>host</code>，TCP socket将打开socket。如果忽略参数<code>host</code>，则默认为<code>localhost</code>。如果指定了 <code>path</code>，socket将会被指定路径的unix socket打开。</p><p>通常情况不需要使用这个函数，比如使用<code>net.createConnection</code>打开socket。只有你实现了自己的socket时才会用到。</p><p>这是异步函数。当<a href=\"#net_event_connect\">'connect'</a>事件被触发时，socket已经建立。如果这是问题连接，<code>'connect'</code>事件不会被触发，将会抛出<code>'error'</code>事件。</p><p>参数<code>connectListener</code>将会作为监听器添加到<a href=\"#net_event_connect\">'connect'</a>事件。</p><h3>socket.bufferSize</h3><p>socket.bufferSize是<code>net.Socket</code>的一个属性，用于<code>socket.write()</code>。它能够帮助用户获取更快的运行速度。计算机不能一直处于写入大量数据状态--网络连接可能太慢。Node在内部会将排队数据写入到socket，并在网络可用时发送。（内部实现：轮询socket的文件描述符直到变为可写）。</p><p>这种内部缓冲的缺点是会增加内存使用量。这个属性表示当前准备写的缓冲字符数。（字符的数量等于准备写入的字节的数量，但是缓冲区可能包含字符串，这些字符串是惰性编码的，所以准确的字节数还无法知道）。</p><p>遇到很大增长很快的<code>bufferSize</code>时，用户可用尝试用<code>pause()</code>和<code>resume()</code>来控制字符流。</p><h3>socket.setEncoding([encoding])</h3><p>设置socket的编码为可读流。更多信息参见<a href=\"ocq11itw.html#stream_stream_setencoding_encoding\" target=\"_blank\">stream.setEncoding()</a></p><h3>socket.write(data[, encoding][, callback])</h3><p>在socket上发送数据。第二个参数指定了字符串的编码，默认是UTF8编码。</p><p>如果所有数据成功刷新到内核缓冲区，返回<code>true</code>。如果数据全部或部分在用户内存里，返回<code>false</code>。当缓冲区为空的时候会触发<code>'drain'</code>。</p><p>当数据最终被完整写入的的时候，可选的<code>callback</code>参数会被执行，但不一定会马上执行。</p><p><a name=\"net_event_end\"></a></p><h3>socket.end([data][, encoding])</h3><p>半关闭socket。例如，它发送一个FIN包。可能服务器仍在发送数据。</p><p>如果参数<code>data</code>不为空，等同于调用<code>socket.write(data, encoding)</code>后再调用<code>socket.end()</code>。</p><h3>socket.destroy()</h3><p>确保没有I/O活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。  </p><h3>socket.pause()</h3><p>暂停读取数据。就是说，不会再触发<code>data</code>事件。对于控制上传非常有用。</p><h3>socket.resume()</h3><p>调用<code>pause()</code>后想恢复读取数据。</p><h3>socket.setTimeout(timeout[, callback])</h3><p>socket闲置时间超过<code>timeout</code>毫秒后 ，将socket设置为超时。</p><p>触发空闲超时事件时，socket将会收到<code>'timeout'</code>事件，但是连接不会被断开。用户必须手动调用<code>end()</code>或<code>destroy()</code>这个socket。</p><p>如果<code>timeout</code>= 0，那么现有的闲置超时会被禁用</p><p>可选的callback参数将会被添加成为'timeout'事件的一次性监听器。</p><h3>socket.setNoDelay([noDelay])</h3><p>禁用纳格（Nagle）算法。默认情况下TCP连接使用纳格算法，在发送前他们会缓冲数据。将<code>noDelay</code>设置为<code>true</code>将会在调用<code>socket.write()</code>时立即发送数据。<code>noDelay</code>默认值为<code>true</code>。</p><h3>socket.setKeepAlive([enable][, initialDelay])</h3><p>禁用/启用长连接功能，并在发送第一个在闲置socket上的长连接 probe 之前，可选地设定初始延时。默认为false。</p><p>设定<code>initialDelay</code>（毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将initialDelay设为0，将会保留默认（或者之前）的值。默认值为0。</p><h3>socket.address()</h3><p>操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有3个属性，比如<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>。</p><h3>socket.unref()</h3><p>如果这是事件系统中唯一一个活动的服务器，调用<code>unref</code>将允许程序退出。如果服务器已被unref，则再次调用unref并不会产生影响。</p><h3>socket.ref()</h3><p>与<code>unref</code>相反，如果这是唯一的服务器，在之前被<code>unref</code>了的服务器上调用<code>ref</code>将不会让程序退出（默认行为）。如果服务器已经被<code>ref</code>，则再次调用<code>ref</code>并不会产生影响。</p><h3>socket.remoteAddress</h3><p>远程的IP地址字符串，例如：<code>'74.125.127.100'</code>或者<code>'2001:4860:a005::68'</code>。</p><h3>socket.remoteFamily</h3><p>远程IP协议族字符串，比如<code>'IPv4'</code>或者<code>'IPv6'</code>。</p><h3>socket.remotePort</h3><p>远程端口，数字表示，例如：<code>80</code>或者<code>21</code>。</p><h3>socket.localAddress</h3><p>网络连接绑定的本地接口远程客户端正在连接的本地IP地址，字符串表示。例如，如果你在监听'0.0.0.0'而客户端连接在'192.168.1.1'，这个值就会是 '192.168.1.1'。</p><h3>socket.localPort</h3><p>本地端口地址，数字表示。例如：<code>80</code>或者<code>21</code>。</p><h3>socket.bytesRead</h3><p>接收到得字节数。</p><h3>socket.bytesWritten</h3><p>发送的字节数。</p><p><code>net.Socket</code>是事件分发器<a href=\"aue11itf.html#events_class_events_eventemitter\" target=\"_blank\">EventEmitter</a>的实例， 有以下事件：</p><h3>事件： 'lookup'</h3><p>在解析域名后，但在连接前，触发这个事件。对UNIX sokcet不适用。</p><ul><li><code>err</code> {Error | Null} 错误对象。参见<a href=\"653b1iu1.html#dns_dns_lookup_domain_family_callback\" target=\"_blank\">dns.lookup()</a>.</li><li><code>address</code> {String} IP地址。</li><li><code>family</code> {String | Null} 地址类型。参见<a href=\"653b1iu1.html#dns_dns_lookup_domain_family_callback\" target=\"_blank\">dns.lookup()</a>.</li></ul><h3>事件： 'connect'</h3><p>当成功建立socket连接时触发。参见<code>connect()</code>。</p><h3>事件： 'data'</h3><ul><li>{Buffer object}</li></ul><p>当接收到数据时触发。参数<code>data</code>可以是<code>Buffer</code>或<code>String</code>。使用<code>socket.setEncoding()</code>设定数据编码。(更多信息参见<a href=\"ocq11itw.html#stream_class_stream_readable\" target=\"_blank\">Readable Stream</a>)。</p><p>当<code>Socket</code>触发一个<code>'data'</code>事件时，如果没有监听器，数据将会丢失。</p><h3>事件： 'end'</h3><p>当socket另一端发送FIN包时，触发该事件。</p><p>默认情况下(<code>allowHalfOpen == false</code>)，一旦socket将队列里的数据写完毕，socket将会销毁它的文件描述符。如果<code>allowHalfOpen == true</code>，socket不会从它这边自动调用end()，使的用户可以随意写入数据，而让用户端自己调用end()。</p><h3>事件： 'timeout'</h3><p>当socket空闲超时时触发，仅是表明socket已经空闲。用户必须手动关闭连接。</p><p>参见：<code>socket.setTimeout()</code></p><h3>事件： 'drain'</h3><p>当写缓存为空得时候触发。可用来控制上传。</p><p>参见：<code>socket.write()</code>的返回值。</p><h3>事件： 'error'</h3><ul><li>{Error object}</li></ul><p>错误发生时触发。以下事件将会直接触发<code>'close'</code>事件。</p><h3>事件： 'close'</h3><ul><li><code>had_error</code> {Boolean} 如果socket传输错误，为<code>true</code></li></ul><p>当socket完全关闭时触发。参数<code>had_error</code>是boolean，它表示是否因为传输错误导致socket关闭。</p><h2 class=\"head2\">net.isIP(input)</h2><p>测试是否输入的为IP地址。字符串无效时返回0。IPV4情况下返回4，IPV6情况下返回6.</p><h2 class=\"head2\">net.isIPv4(input)</h2><p>如果输入的地址为IPV4，返回true，否则返回false。</p><h2 class=\"head2\">net.isIPv6(input)</h2><p>如果输入的地址为IPV6，返回true，否则返回false。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 21,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "596b4b475996c5be2d7eafb5e1658b28",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 流",
      "chapter_level_two_url": "/nodejs/ocq11itw.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>流</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 2 - 不稳定</code></pre><p>流用于处理Node.js中的流数据的抽象接口，在Node里被不同的对象实现。例如，<a href=\"1v9k1itp.html#http_http_incomingmessage\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">对HTTP服务器的请求</a>是流，<a href=\"qvcz1iu6.html#process_process_stdout\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">process.stdout</a> 是流。<br></p><p>流是可读的，可写的，或者是可读写的，所有的流是<a href=\"aue11itf.html#events_class_events_eventemitter\" target=\"_blank\">EventEmitter</a>的实例。</p><p>Node.js访问流模块的方法如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">const stream = require('stream');</code></pre><p>你可以通过<code>require('stream')</code>加载Stream基类。其中包括了<code>Readable</code>流、<code>Writable</code>流、<code>Duplex</code>流和<code>Transform</code>流的基类。</p><p>本文将分为3个部分进行介绍。</p><p>第一个部分解释了在你的程序中使用流时候需要了解的内容。如果你不用实现流式API，可以只看这个部分。</p><p>如果你想实现你自己的流，第二个部分解释了这部分API。这些API让你的实现更加简单。</p><p>第三个部分深入的解释了流是如何工作的，包括一些内部机制和函数，这些内容不要改动，除非你明确知道你要做什么。</p><h2 class=\"head2\">面向流消费者的API</h2><p>流可以是可读（Readable），可写（Writable），或者是可读可写的（Duplex，双工）。</p><p>所有的流都是事件分发器（EventEmitters），但是也有自己的方法和属性，这取决于他它们是可读（Readable），可写（Writable），或者兼具两者（Duplex，双工）的。</p><p>如果流是可读写的，则它实现了下面的所有方法和事件。因此，这个部分API完全阐述了<a href=\"#stream_class_stream_duplex\">Duplex</a>或<a href=\"#stream_class_stream_transform\">Transform</a>流，即便他们的实现有所不同。</p><p>没有必要为了消费流而在你的程序里实现流的接口。如果你正在你的程序里实现流接口，请同时参考下面的<a href=\"#stream_api_for_stream_implementors\">流实现程序API</a>。</p><p>基本所有的Node程序，无论多简单，都会使用到流。以下是一个使用流的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar http = require('http');\n\nvar server = http.createServer(function (req, res) {\n  // req is an http.IncomingMessage, which is 可读流（Readable stream）\n  // res is an http.ServerResponse, which is a Writable Stream\n\n  var body = '';\n  // we want to get the data as utf8 strings\n  // If you don't set an encoding, then you'll get Buffer objects\n  req.setEncoding('utf8');\n\n  // 可读流（Readable stream） emit 'data' 事件 once a 监听器（listener） is added\n  req.on('data', function (chunk) {\n    body += chunk;\n  });\n\n  // the end 事件 tells you that you have entire body\n  req.on('end', function () {\n    try {\n      var data = JSON.parse(body);\n    } catch (er) {\n      // uh oh!  bad json!\n      res.statusCode = 400;\n      return res.end('error: ' + er.message);\n    }\n\n    // write back something interesting to the user:\n    res.write(typeof data);\n    res.end();\n  });\n});\n\nserver.listen(1337);\n\n// $ curl localhost:1337 -d '{}'\n// object\n// $ curl localhost:1337 -d '\"foo\"'\n// string\n// $ curl localhost:1337 -d 'not json'\n// error: Unexpected token o</code></pre><h3>类： stream.Readable</h3><p>可读流（Readable stream）接口是对你正在读取的数据的来源的抽象。换句话说，数据来来自</p><p>可读流（Readable stream）不会分发数据，直到你表明准备就绪。  </p><p>可读流（Readable stream） 有2种模式: <strong>流动模式（flowing mode）</strong>和<strong>暂停模式（paused mode）</strong>。流动模式（flowing mode）时，尽快的从底层系统读取数据并提供给你的程序。暂停模式（paused mode）时，你必须明确的调用<code>stream.read()</code>来读取数据。暂停模式（paused mode）是默认模式。</p><p><strong>注意</strong>: 如果没有绑定数据处理函数，并且没有<a href=\"#stream_readable_pipe_destination_options\"><code>pipe()</code></a>目标，流会切换到流动模式（flowing mode），并且数据会丢失。</p><p>可以通过下面几个方法，将流切换到流动模式（flowing mode）。</p><ul><li>添加一个[<code>'data'</code> 事件][]事件处理器来监听数据.</li><li>调用<a href=\"#stream_readable_resume\"><code>resume()</code></a>方法来明确的开启数据流。</li><li>调用<a href=\"#stream_readable_pipe_destination_options\"><code>pipe()</code></a>方法来发送数据给<a href=\"#stream_class_stream_writable\" target=\"_blank\">Writable</a>.</li></ul><p>可以通过以下方法来切换到暂停模式（paused mode）:</p><ul><li>如果没有“导流（pipe）”目标，调用<a href=\"#stream_readable_pause\"><code>pause()</code></a>方法.</li><li>如果有“导流（pipe）”目标，移除所有的[<code>'data'</code>事件][]处理函数，调用<a href=\"#stream_readable_unpipe_destination\"><code>unpipe()</code></a>方法移除所有的“导流（pipe）”目标。</li></ul><p>注意：为了向后兼容考虑， 移除'data'事件监听器并不会自动暂停流。同样的，当有导流目标时，调用pause()并不能保证流在那些目标排空后，请求更多数据时保持暂停状态。</p><p>可读流（Readable stream）例子包括:</p><ul><li><a rel=\"nofollow\" href=\"https://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\">http responses, on the client</a></li><li><a rel=\"nofollow\" href=\"https://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\">http requests, on the server</a></li><li><a rel=\"nofollow\" href=\"https://nodejs.org/api/fs.html#fs_class_fs_readstream\" target=\"_blank\">fs read streams</a></li><li><a href=\"dyfg1iuf.html\" target=\"_blank\">zlib streams</a></li><li><a href=\"v9c81itv.html.html\" target=\"_blank\">crypto streams</a></li><li><a href=\"sbua1itx.html#net_class_net_socket\" target=\"_blank\">tcp sockets</a></li><li><a href=\"https://nodejs.org/api/child_process.html#child_process_child_stdout\" rel=\"external nofollow\" target=\"_blank\">child process stdout and stderr</a></li><li><a href=\"qvcz1iu6.html#process_process_stdin\" target=\"_blank\">process.stdin</a></li></ul><h4>事件: 'readable'</h4><p>当一个数据块可以从流中读出，将会触发<code>'readable'</code>事件.`</p><p>某些情况下, 如果没有准备好，监听一个<code>'readable'</code>事件将会导致一些数据从底层系统读取到内部缓存。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readble = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  // there is some data to read now\n});</code></pre><p>一旦内部缓存排空，一旦有更多数据将会再次触发<code>readable</code>事件。</p><h4>事件: 'data'</h4><ul><li><code>chunk</code> {Buffer | String} 数据块</li></ul><p>绑定一个<code>data</code>事件的监听器（listener）到一个未明确暂停的流，会将流切换到流动模式。数据会尽额能的传递。</p><p>如果你像尽快的从流中获取数据，以下的方法是最快的：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n});</code></pre><h4>事件: 'end'</h4><p>如果没有更多的可读数据，将会触发这个事件。</p><p>注意：只有数据已经被完全消费，<code>end</code>事件<strong>才会触发</strong>。可以通过切换到流动模式（flowing mode）来实现，或者通过调用重复调用<code>read()</code>获取数据，直到结束。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n    var readable = getReadableStreamSomehow();\n    readable.on('data', function(chunk) {\n        console.log('got %d bytes of data', chunk.length);\n    });\n    readable.on('end', function() {\n        console.log('there will be no more data.');\n    });  </code></pre><h4>事件: 'close'</h4><p>当底层资源（例如源头的文件描述符）关闭时触发。并不是所有流都会触发这个事件。</p><h4>事件: 'error'</h4><ul><li>{Error Object}</li></ul><p>当接收数据时发生错误触发。  </p><h4>readable.read([size])</h4><ul><li><code>size</code> {Number} 可选参数， 需要读入的数据量</li><li>返回 {String | Buffer | null}</li></ul><p><code>read()</code>方法从内部缓存中拉取数据。如果没有可用数据，将会返回<code>null</code></p><p>如果传了<code>size</code>参数，将会返回相当字节的数据。如果<code>size</code>不可用，将会返回<code>null</code>。</p><p>如果你没有指定<code>size</code>参数。将会返回内部缓存的所有数据。</p><p>这个方法仅能再暂停模式（paused mode）里调用。 流动模式（flowing mode）下这个方法会被自动调用直到内存缓存排空。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log('got %d bytes of data', chunk.length);\n  }\n});</code></pre><p>如果这个方法返回一个数据块, 它同时也会触发[<code>'data'</code>事件][].</p><h4>readable.setEncoding(encoding)</h4><ul><li><code>encoding</code> {String} 要使用的编码.</li><li>返回:<code>this</code></li></ul><p>调用此函数会使得流返回指定编码的字符串，而不是Buffer对象。例如，如果你调用<code>readable.setEncoding('utf8')</code>，输出数据将会是UTF-8编码，并且返回字符串。如果你调用<code>readable.setEncoding('hex')</code>，将会返回2进制编码的数据。</p><p>该方法能正确处理多字节字符。如果不想这么做，仅简单的直接拉取缓存并调<code>buf.toString(encoding)</code>，可能会导致字节错位。因此，如果你想以字符串读取数据，请使用下述的方法：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', function(chunk) {\n  assert.equal(typeof chunk, 'string');\n  console.log('got %d characters of string data', chunk.length);\n});</code></pre><h4>readable.resume()</h4><ul><li>返回:<code>this</code></li></ul><p>这个方法让可读流（Readable stream）继续触发<code>data</code>事件.</p><p>这个方法会将流切换到流动模式（flowing mode）。 如果你不想从流中消费数据，而想得到<code>end</code>事件，可以调用<a href=\"#stream_readable_resume\"><code>readable.resume()</code></a>来打开数据流，如下所示：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on('end', function(chunk) {\n  console.log('got to the end, but did not read anything');\n});</code></pre><h4>readable.pause()</h4><ul><li>返回:<code>this</code></li></ul><p>这个方法会使得流动模式（flowing mode）的流停止触发<code>data</code>事件，切换到流动模式（flowing mode）。并让后续可用数据留在内部缓冲区中。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n  readable.pause();\n  console.log('there will be no more data for 1 second');\n  setTimeout(function() {\n    console.log('now data will start flowing again');\n    readable.resume();\n  }, 1000);\n});</code></pre><h4>readable.isPaused()</h4><ul><li>返回:<code>Boolean</code></li></ul><p>这个方法返回<code>readable</code>是否被客户端代码<strong>明确</strong>的暂停（调用<code>readable.pause()</code>）。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var readable = new stream.Readable\n\nreadable.isPaused() // === false\nreadable.pause()\nreadable.isPaused() // === true\nreadable.resume()\nreadable.isPaused() // === false</code></pre><h4>readable.pipe(destination[, options])</h4><ul><li><code>destination</code> {<a href=\"#stream_class_stream_writable\" target=\"_blank\">Writable</a> Stream} 写入数据的目标</li><li><code>options</code> {Object} 导流（pipe）选项<ul><li><code>end</code> {Boolean} 读取到结束符时，结束写入者。默认 = <code>true</code></li></ul></li></ul><p>这个方法从可读流（Readable stream）拉取所有数据，并将数据写入到提供的目标中。自动管理流量，这样目标不会快速的可读流（Readable stream）淹没。</p><p>可以导流到多个目标。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt'\nreadable.pipe(writable);</code></pre><p>这个函数返回目标流, 因此你可以建立导流链：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar r = fs.createReadStream('file.txt');\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream('file.txt.gz');\nr.pipe(z).pipe(w);</code></pre><p>例如：模拟Unix的<code>cat</code>命令：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nprocess.stdin.pipe(process.stdout);</code></pre><p>默认情况下，当源数据流触发<code>end</code>的时候调用<a href=\"#stream_writable_end_chunk_encoding_callback\"><code>end()</code></a>，所以<code>destination</code>不可再写。传<code>{ end:false }</code>作为<code>options</code>，可以保持目标流打开状态。</p><p>这会让<code>writer</code>保持打开状态，可以在最后写入\"Goodbye\"：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nreader.pipe(writer, { end: false });\nreader.on('end', function() {\n  writer.end('Goodbye\\n');\n});</code></pre><p>注意：<code>process.stderr</code>和<code>process.stdout</code>直到进程结束才会关闭，无论是否指定它们。</p><h4>readable.unpipe([destination])</h4><ul><li><code>destination</code> {<a href=\"#stream_class_stream_writable\">Writable</a> Stream} 可选，指定解除导流的流</li></ul><p>这个方法会解除之前调用<code>pipe()</code> 设置的钩子（<code>pipe()</code>）。   </p><p>如果没有指定<code>destination</code>，则所有的导流（pipe）都会被移除。</p><p>如果指定了<code>destination</code>，但是没有建立如果没有指定<code>destination</code>，则什么事情都不会发生。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(function() {\n  console.log('stop writing to file.txt');\n  readable.unpipe(writable);\n  console.log('manually close the file stream');\n  writable.end();\n}, 1000);</code></pre><h4>readable.unshift(chunk)</h4><ul><li><code>chunk</code> {Buffer | String} 数据块插入到读队列中</li></ul><p>这个方法很有用，当一个流正被一个解析器消费，解析器可能需要将某些刚拉取出的数据“逆消费”，返回到原来的源，以便流能将它传递给其它消费者。</p><p>如果你在程序中必须经常调用<code>stream.unshift(chunk)</code> ，那你可以考虑实现<a href=\"#stream_class_stream_transform\">Transform</a>来替换（参见下文API for Stream Implementors）。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nvar StringDecoder = require('string_decoder').StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  var decoder = new StringDecoder('utf8');\n  var header = '';\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join('\\n\\n');\n        var buf = new Buffer(remaining, 'utf8');\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener('error', callback);\n        stream.removeListener('readable', onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}</code></pre><h4>readable.wrap(stream)</h4><ul><li><code>stream</code> {Stream} 一个旧式的可读流（Readable stream）</li></ul><p>v0.10版本之前的Node流并未实现现在所有流的API（更多信息详见下文“兼容性”部分）。</p><p>如果你使用的是旧的Node库，它触发<code>'data'</code>事件，并拥有仅做查询用的<a href=\"#stream_readable_pause\"><code>pause()</code></a>方法，那么你能使用<code>wrap()</code>方法来创建一个<a href=\"#stream_class_stream_readable\" target=\"_blank\">Readable</a>流来使用旧版本的流，作为数据源。</p><p>你应该很少需要用到这个函数，但它会留下方便和旧版本的Node程序和库交互。</p><p>例如:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});</code></pre><h3>类： stream.Writable</h3><p>可写流（Writable stream ）接口是你正把数据写到一个目标的抽象。  </p><p>可写流（Writable stream ）的例子包括:</p><ul><li><a href=\"1v9k1itp.html#http_class_http_clientrequest\" target=\"_blank\">http requests, on the client</a></li><li><a href=\"1v9k1itp.html#http_class_http_serverresponse\" target=\"_blank\">http responses, on the server</a></li><li><a href=\"fs.html#fs_class_fs_writestream\" target=\"_blank\">fs write streams</a></li><li><a href=\"dyfg1iuf.html\" target=\"_blank\">zlib streams</a></li><li><a href=\"v9c81itv.html\" target=\"_blank\">crypto streams</a></li><li><a href=\"sbua1itx.html#net_class_net_socket\" target=\"_blank\">tcp sockets</a></li><li><a href=\"https://nodejs.org/api/child_process.html#child_process_child_stdin\" rel=\"external nofollow\" target=\"_blank\">child process stdin</a></li><li><a href=\"qvcz1iu6.html#process_process_stdout\" target=\"_blank\">process.stdout</a>, <a href=\"qvcz1iu6.html#process_process_stderr\" target=\"_blank\">process.stderr</a></li></ul><h4>writable.write(chunk[, encoding][, callback])</h4><ul><li><code>chunk</code> {String | Buffer} 准备写的数据</li><li><code>encoding</code> {String} 编码方式（如果<code>chunk</code> 是字符串）</li><li><code>callback</code> {Function} 数据块写入后的回调</li><li>返回: {Boolean} 如果数据已被全部处理返回true</li></ul><p>这个方法向底层系统写入数据，并在数据处理完毕后调用所给的回调。</p><p>返回值表示你是否应该继续立即写入。如果数据要缓存在内部，将会返回<code>false</code>。否则返回<code>true</code>。</p><p>返回值仅供参考。即使返回<code>false</code>，你也可能继续写。但是写会缓存在内存里，所以不要做的太过分。最好的办法是等待<code>drain</code>事件后，再写入数据。</p><h4>事件: 'drain'</h4><p>如果调用<a href=\"#stream_writable_write_chunk_encoding_callback\"><code>writable.write(chunk)</code></a>返回 false，<code>drain</code>事件会告诉你什么时候将更多的数据写入到流中。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// Write the data to the supplied 可写流（Writable stream ） 1MM times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don't pass the callback, because we're not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i &gt; 0 &amp;&amp; ok);\n    if (i &gt; 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once('drain', write);\n    }\n  }\n}</code></pre><h4>writable.cork()</h4><p>强制缓存所有写入。</p><p>调用<code>.uncork()</code>或<code>.end()</code>后，会把缓存数据写入。</p><h4>writable.uncork()</h4><p>写入所有.cork()调用之后缓存的数据。</p><h4>writable.setDefaultEncoding(encoding)</h4><ul><li><code>encoding</code> {String} 新的默认编码</li><li>返回:<code>Boolean</code></li></ul><p>给写数据流设置默认编码方式，如编码有效，则返回<code>true</code> ，否则返回<code>false</code>。</p><h4>writable.end([chunk][, encoding][, callback])</h4><ul><li><code>chunk</code> {String | Buffer} 可选，要写入的数据</li><li><code>encoding</code> {String} 编码方式（如果<code>chunk</code>是字符串）</li><li><code>callback</code> {Function} 可选， stream结束时的回调函数  </li></ul><p>当没有更多的数据写入的时候调用这个方法。如果给出，回调会被用作finish事件的监听器。</p><p>调用<a href=\"#stream_writable_end_chunk_encoding_callback\"><code>end()</code></a>后调用<a href=\"#stream_writable_write_chunk_encoding_callback\"><code>write()</code></a>会产生错误。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// write 'hello, ' and then end with 'world!'\nvar file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// writing more now is not allowed!</code></pre><h4>事件: 'finish'</h4><p>调用<a href=\"#stream_writable_end_chunk_encoding_callback\"><code>end()</code></a>方法后，并且所有的数据已经写入到底层系统，将会触发这个事件。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar writer = getWritableStreamSomehow();\nfor (var i = 0; i &lt; 100; i ++) {\n  writer.write('hello, #' + i + '!\\n');\n}\nwriter.end('this is the end\\n');\nwriter.on('finish', function() {\n  console.error('all writes are now complete.');\n});</code></pre><h4>事件: 'pipe'</h4><ul><li><code>src</code> {<a href=\"#stream_class_stream_readable\">Readable</a> Stream} 是导流（pipe）到可写流的源流。</li></ul><p>无论何时在可写流（Writable stream ）上调用<code>pipe()</code>方法，都会触发'pipe'事件，添加这个流到目标。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('pipe', function(src) {\n  console.error('something is piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);</code></pre><h4>事件: 'unpipe'</h4><ul><li><code>src</code> {<a href=\"#stream_class_stream_readable\">Readable</a> Stream}未写入此可写的源流。</li></ul><p>无论何时在可写流（Writable stream ）上调用<code>unpipe()</code>方法，都会触发'unpipe'事件，将这个流从目标上移除。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('unpipe', function(src) {\n  console.error('something has stopped piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);</code></pre><h4>事件: 'error'</h4><ul><li>{Error object}</li></ul><p>写或导流（pipe）数据时，如果有错误会触发。</p><h3>类： stream.Duplex</h3><p>双工流（Duplex streams）是同时实现了<a href=\"#stream_class_stream_readable\">Readable</a>和<a href=\"#stream_class_stream_writable\">Writable</a> 接口。用法详见下文。</p><p>双工流（Duplex streams） 的例子包括:</p><ul><li><a href=\"sbua1itx.html#net_class_net_socket\" target=\"_blank\">tcp sockets</a></li><li><a href=\"dyfg1iuf.html\" target=\"_blank\">zlib streams</a></li><li><a href=\"v9c81itv.html\" target=\"_blank\">crypto streams</a></li></ul><h3>类： stream.Transform</h3><p>转换流（Transform streams）是双工<a href=\"#stream_class_stream_duplex\">Duplex</a>流，它的输出是从输入计算得来。 它实现了<a href=\"#stream_class_stream_readable\">Readable</a>和<a href=\"#stream_class_stream_writable\">Writable</a>接口.  用法详见下文.</p><p>转换流（Transform streams）的例子包括:</p><ul><li><a href=\"dyfg1iuf.html\" target=\"_blank\">zlib streams</a></li><li><a href=\"v9c81itv.html\" target=\"_blank\">crypto streams</a></li></ul><h2 class=\"head2\">流实现程序API</h2><p>无论实现什么形式的流，模式都是一样的:</p><ol><li>在你的子类中扩展适合的父类。  (<a href=\"util.html#util_util_inherits_constructor_superconstructor\"><code>util.inherits</code></a>方法很有帮助)</li><li>在你的构造函数中调用父类的构造函数，以确保内部的机制初始化正确。</li><li>实现一个或多个方法，如下所列。</li></ol><p>所扩展的类和要实现的方法取决于你要编写的流类。</p><table class=\"\"><thead><tr><th><p style=\"text-align: center;\">Use-case</p></th>      <th><p style=\"text-align: center;\">Class</p></th>      <th><p style=\"text-align: center;\">方法(s) to implement</p></th>    </tr></thead><tbody><tr><td><p>Reading only</p></td>    <td><p>[Readable](#stream_class_stream_readable_1)</p></td>    <td><p><code>[_read][]</code></p></td>  </tr><tr><td><p>Writing only</p></td>    <td><p>[Writable](#stream_class_stream_writable_1)</p></td>    <td><p><code>[_write][]</code></p></td>  </tr><tr><td><p>Reading and writing</p></td>    <td><p>[Duplex](#stream_class_stream_duplex_1)</p></td>    <td><p><code>[_read][]</code>, <code>[_write][]</code></p></td>  </tr><tr><td><p>Operate on written data, then read the result</p></td>    <td><p>[Transform](#stream_class_stream_transform_1)</p></td>    <td><p><code>_transform</code>, <code>_flush</code></p></td>  </tr></tbody></table><p>在你的代码里，千万不要调用<a href=\"https://www.w3cschool.cn/project/nodejs/ocq11itw.html#stream_api_for_stream_consumers\">流实现程序API</a>里的方法。否则可能会引起消费流的程序副作用。</p><h3>类： stream.Readable</h3><p><code>stream.Readable</code>是一个可被扩充的、实现了底层<code>_read(size)</code>方法的抽象类。  </p><p>参照之前的<a href=\"https://www.w3cschool.cn/project/nodejs/ocq11itw.html#stream_api_for_stream_consumers\" style=\"background-color: rgb(255, 255, 255);\">流实现程序API</a>查看如何在你的程序里消费流。以下内容解释了在你的程序里如何实现可读流（Readable stream）。</p><h4>Example: 计数流</h4><p>这是可读流（Readable stream）的基础例子，它将从1至1,000,000递增地触发数字，然后结束：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar Readable = require('stream').Readable;\nvar util = require('util');\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i &gt; this._max)\n    this.push(null);\n  else {\n    var str = '' + i;\n    var buf = new Buffer(str, 'ascii');\n    this.push(buf);\n  }\n};</code></pre><h4>Example: 简单协议 v1 (初始版)</h4><p>和之前描述的<code>parseHeader</code>函数类似，但它被实现为自定义流。注意这个实现不会将输入数据转换为字符串。</p><p>实际上，更好的办法是将他实现为<a href=\"#stream_class_stream_transform\">Transform</a>流，使用下面的实现方法会更好：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// A parser for a simple data protocol.\n// \"header\" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// 注意: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal.  See the\n// alternative example below under Transform section.\n\nvar Readable = require('stream').Readable;\nvar util = require('util');\n\nutil.inherits(SimpleProtocol, Readable);\n\n  function SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options;\n\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is 可读流（Readable stream）, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the 读取队列 so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is 可读流（Readable stream） that will emit 'header'\n// with the parsed header data.</code></pre><h4>new stream.Readable([options])</h4><ul><li><code>options</code>{Object}<ul><li><code>highWaterMark</code>{Number} 停止从底层资源读取数据前，存储在内部缓存的最大字节数；默认=16kb， <code>objectMode</code>流是16.</li><li><code>encoding</code>{String} 若指定，则Buffer会被解码成所给编码的字符串，默认为null。</li><li><code>objectMode</code>{Boolean} 该流是否为对象的流。意思是说stream.read(n)返回一个单独的值，而不是大小为n的Buffer。</li></ul></li></ul><p>Readable的扩展类中，确保调用了Readable的构造函数，这样才能正确初始化。</p><h4>readable._read(size)</h4><ul><li><code>size</code>{Number} 异步读取的字节数</li></ul><p>注意：<strong>实现这个函数，但不要直接调用。</strong></p><p>这个函数不要直接调用。在子类里实现，仅能被内部的Readable类调用。</p><p>所有可读流（Readable stream） 的实现必须停供一个<code>_read</code>方法，从底层资源里获取数据。</p><p>这个方法以下划线开头，是因为对于定义它的类是内部的，不会被用户程序直接调用。你可以在自己的扩展类中实现。</p><p>当数据可用时，通过调用<code>readable.push(chunk)</code>将之放到读取队列中。再次调用<code>_read</code>，需要继续推出更多数据。</p><p><code>size</code>参数仅供参考。调用“read”可以知道知道应当抓取多少数据；其余与之无关的实现，比如TCP或TLS，则可忽略这个参数，并在可用时返回数据。例如，没有必要“等到”size个字节可用时才调用stream.push(chunk)。</p><h4>readable.push(chunk[, encoding])</h4><ul><li><code>chunk</code> {Buffer | null | String} 推入到读取队列的数据块</li><li><code>encoding</code> {String} 字符串块的编码。必须是有效的Buffer编码，比如utf8或ascii。</li><li>返回{Boolean}是否应该继续推入</li></ul><p>注意: <strong>这个函数必须被 Readable 实现者调用, 而不是可读流（Readable stream）的消费者.</strong></p><p><code>_read()</code>函数直到调用<code>push(chunk)</code>后才能被再次调用。  </p><p><code>Readable</code>类将数据放到读取队列，当<code>'readable'</code>事件触发后，被<code>read()</code>方法取出。<code>push()</code>方法会插入数据到读取队列中。如果调用了<code>null</code>，会触发数据结束信号 (EOF)。</p><p>这个API被设计成尽可能地灵活。比如说，你可以包装一个低级别的，具备某种暂停/恢复机制，和数据回调的数据源。这种情况下，你可以通过这种方式包装低级别来源对象：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// source is an object with readStop() and readStart() 方法s,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n  var self = this;\n\n  // Every time there's data, we push it into the internal buffer.\n  this._source.ondata = function(chunk) {\n    // if push() 返回 false, then we need to stop reading from source\n    if (!self.push(chunk))\n      self._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signaling `null` chunk\n  this._source.onend = function() {\n    self.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size 参数 is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};</code></pre><h3>类： stream.Writable</h3><p><code>stream.Writable</code>是个抽象类，它扩展了一个底层的实现<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>_write(chunk, encoding, callback)</code></a>方法.</p><p>参考上面的<a href=\"#stream_api_for_stream_consumers\">流实现程序API</a>，来了解在你的程序里如何消费可写流。下面内容介绍了如何在你的程序里实现可写流。</p><h4>new stream.Writable([options])</h4><ul><li><code>options</code> {Object}<ul><li><code>highWaterMark</code> {Number} 当<a href=\"#stream_writable_write_chunk_encoding_callback\"><code>write()</code></a>返回false时的缓存级别。默认=16kb，<code>objectMode</code>流是16。</li><li><code>decodeStrings</code> {Boolean} 传给<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>_write()</code></a>前是否解码为字符串。默认=true</li><li><code>objectMode</code> {Boolean}<code>write(anyObj)</code>是否是有效操作；如果为true，可以写任意数据，而不仅仅是<code>Buffer</code>/<code>String</code>。默认=false</li></ul></li></ul><p>请确保Writable类的扩展类中，调用构造函数以便缓冲设定能被正确初始化。</p><h4>writable._write(chunk, encoding, callback)</h4><ul><li><code>chunk</code> {Buffer | String} 要写入的数据块。总是buffer， 除非<code>decodeStrings</code>选项为<code>false</code>。</li><li><code>encoding</code> {String} 如果数据块是字符串，这个参数就是编码方式。如果是缓存，则忽略。注意，除非<code>decodeStrings</code>被设置为<code>false</code>，否则这个数据块一直是buffer。</li><li><code>callback</code>{函数} 当你处理完数据后调用这个函数 (错误参数为可选参数)。</li></ul><p>所以可写流（Writable stream ） 实现必须提供一个<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>_write()</code></a>方法，来发送数据给底层资源。 </p><p>注意: <strong>这个函数不能直接调用</strong>，由子类实现，仅内部可写方法可以调用。</p><p>使用标准的<code>callback(error)</code>方法调用回调函数，来表明写入完成或遇到错误。</p><p>如果构造函数选项中设定了<code>decodeStrings</code>标识，则<code>chunk</code>可能会是字符串而不是Buffer，<code>encoding</code>表明了字符串的格式。这种设计是为了支持对某些字符串数据编码提供优化处理的实现。如果你没有明确的设置<code>decodeStrings</code>为<code>false</code>，这样你就可以安不管<code>encoding</code>参数，并假定<code>chunk</code>一直是一个缓存。</p><p>该方法以下划线开头，是因为对于定义它的类来说，这个方法是内部的，并且不应该被用户程序直接调用。你应当在你的扩充类中重写这个方法。</p><h3>writable._writev(chunks, callback)</h3><ul><li><code>chunks</code> {Array} 准备写入的数据块，每个块格式如下:<code>{ chunk: ..., encoding: ... }</code>.</li><li><code>callback</code> {函数} 当你处理完数据后调用这个函数 (错误参数为可选参数)。</li></ul><p>注意: <strong>这个函数不能直接调用。</strong>由子类实现，仅内部可写方法可以调用.</p><p>这个函数的实现是可选的。多数情况下，没有必要实现。如果实现，将会在所有数据块缓存到写队列后调用。</p><h3>类： stream.Duplex</h3><p>双工流（duplex stream）同时兼具可读和可写特性，比如一个TCP socket连接。</p><p>注意<code>stream.Duplex</code>可以像Readable或Writable一样被扩充，实现了底层_read(sise) 和_write(chunk, encoding, callback) 方法的抽象类。</p><p>由于JavaScript并没有多重继承能力，因此这个类继承自Readable，寄生自Writable.从而让用户在双工扩展类中同时实现低级别的<code>_read(n)</code>方法和低级别的<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>_write(chunk, encoding, callback)</code></a>方法。</p><h4>new stream.Duplex(options)</h4><ul><li><code>options</code> {Object} 传递Writable and Readable构造函数，有以下的内容：<ul><li><code>allowHalfOpen</code> {Boolean} 默认=true。 如果设置为<code>false</code>，当写端结束的时候，流会自动的结束读端，反之亦然。</li><li><code>readableObjectMode</code> {Boolean} 默认=false。将<code>objectMode</code>设为读端的流，如果为<code>true</code>，将没有效果。</li><li><code>writableObjectMode</code> {Boolean} 默认=false。将<code>objectMode</code>设为写端的流，如果为<code>true</code>，将没有效果。</li></ul></li></ul><p>扩展自Duplex的类，确保调用了父亲的构造函数，保证缓存设置能正确初始化。</p><h3>类： stream.Transform</h3><p>转换流（transform class) 是双工流（duplex stream），输入输出端有因果关系，比如，<a href=\"dyfg1iuf.html\" target=\"_blank\">zlib</a>流或<a href=\"v9c81itv.html\" target=\"_blank\">crypto</a>流。</p><p>输入输出没有要求大小相同，块数量相同，到达时间相同。例如，一个Hash流只会在输入结束时产生一个数据块的输出；一个zlib流会产生比输入小得多或大得多的输出。</p><p>转换流（transform class) 必须实现<code>_transform()</code>方法，而不是<a href=\"#stream_readable_read_size_1\"><code>_read()</code></a>和<a href=\"#stream_writable_write_chunk_encoding_callback_1\"><code>_write()</code></a>方法，也可以实现<code>_flush()</code>方法（参见如下）。</p><h4>new stream.Transform([options])</h4><ul><li><code>options</code> {Object} 传递给Writable和Readable构造函数。</li></ul><p>扩展自转换流（transform class) 的类，确保调用了父亲的构造函数，保证缓存设置能正确初始化。</p><h4>transform._transform(chunk, encoding, callback)</h4><ul><li><code>chunk</code> {Buffer | String} 准备转换的数据块。是buffer，除非<code>decodeStrings</code>选项设置为<code>false</code>。</li><li><code>encoding</code> {String} 如果数据块是字符串, 这个参数就是编码方式，否则就忽略这个参数  </li><li><code>callback</code> {函数} 当你处理完数据后调用这个函数 (错误参数为可选参数)。</li></ul><p>注意：<strong>这个函数不能直接调用。</strong>由子类实现，仅内部可写方法可以调用.</p><p>所有的转换流（transform class) 实现必须提供 <code>_transform</code>方法来接收输入，并生产输出。</p><p><code>_transform</code>可以做转换流（transform class)里的任何事，处理写入的字节，传给接口的写端，异步I/O，处理事情等等。</p><p>调用<code>transform.push(outputChunk)</code>0次或多次，从这个输入块里产生输出，依赖于你想要多少数据作为输出。</p><p>仅在当前数据块完全消费后调用这个回调。</p><p>注意，输入块可能有，也可能没有对应的输出块。如果你提供了第二个参数，将会传给push方法。如下述的例子：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\ntransform.prototype._transform = function (data, encoding, callback) {\n  this.push(data);\n  callback();\n}\n\ntransform.prototype._transform = function (data, encoding, callback) {\n  callback(null, data);\n}</code></pre><p>该方法以下划线开头，是因为对于定义它的类来说，这个方法是内部的，并且不应该被用户程序直接调用。你应当在你的扩充类中重写这个方法。</p><h4>transform._flush(callback)</h4><ul><li><code>callback</code> {函数} 当你处理完数据后调用这个函数 (错误参数为可选参数)</li></ul><p>注意：<strong>这个函数不能直接调用。</strong>由子类实现，仅内部可写方法可以调用.</p><p>某些情况下，转换操作可能需要分发一点流最后的数据。例如，<code>Zlib</code>流会存储一些内部状态，以便优化压缩输出。</p><p>有些时候，你可以实现<code>_flush</code>方法，它可以在最后面调用，当所有的写入数据被消费后，分发<code>end</code>告诉读端。和<code>_transform</code>一样，当刷新操作完毕， <code>transform.push(chunk)</code>为0次或更多次数。</p><p>该方法以下划线开头，是因为对于定义它的类来说，这个方法是内部的，并且不应该被用户程序直接调用。你应当在你的扩充类中重写这个方法。</p><h4>事件: 'finish' and 'end'</h4><p><a href=\"#stream_event_finish\"><code>finish</code></a>和<a href=\"#stream_event_end\"><code>end</code></a>事件 分别来自Writable和Readable类。<code>.end()</code>事件结束后调用<code>finish</code>事件，所有的数据已经被<code>_transform</code>处理完毕，调用<code>_flush</code>后，所有的数据输出完毕，触发<code>end</code>。</p><h4>Example:<code>SimpleProtocol</code>parser v2</h4><p>上面的简单协议分析例子列子可以通过使用高级别的<a href=\"#stream_class_stream_transform\">Transform</a>流来实现，和<code>parseHeader</code> ，<code>SimpleProtocol v1</code>列子类似。</p><p>在这个示例中，输入会被导流到解析器中，而不是作为参数提供。这种做法更符合Node流的惯例。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar util = require('util');\nvar Transform = require('stream').Transform;\nutil.inherits(SimpleProtocol, Transform);\n\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i &lt; chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(chunk.slice(split));\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(chunk);\n  }\n  done();\n};\n\n// Usage:\n// var parser = new SimpleProtocol();\n// source.pipe(parser)\n// Now parser is 可读流（Readable stream） that will emit 'header'\n// with the parsed header data.</code></pre><h3>类： stream.PassThrough</h3><p>这是<a href=\"#stream_class_stream_transform\">Transform</a>流的简单实现，将输入的字节简单的传递给输出。它的主要用途是测试和演示。偶尔要构建某种特殊流时也会用到。</p><h2 class=\"head2\">流: 内部细节</h2><h3>缓冲</h3><p>可写流（Writable streams ）和可读流（Readable stream）都会缓存数据到内部对象上，叫做<code>_writableState.buffer</code>或<code>_readableState.buffer</code>。  </p><p>缓存的数据量，取决于构造函数是传入的<code>highWaterMark</code>参数。</p><p>调用<a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(chunk)</code></a>时，缓存数据到可读流（Readable stream）。在数据消费者调用<code>stream.read()</code>前，数据会一直缓存在内部队列中。</p><p>调用<a href=\"#stream_writable_write_chunk_encoding_callback\"><code>stream.write(chunk)</code></a>时，缓存数据到可写流（Writable stream）。即使<code>write()</code>返回<code>false</code>。</p><p>流（尤其是<code>pipe()</code>方法）得目的是限制数据的缓存量到一个可接受的水平，使得不同速度的源和目的不会淹没可用内存。</p><h3><code>stream.read(0)</code></h3><p>某些时候，你可能想不消费数据的情况下，触发底层可读流（Readable stream）机制的刷新。这种情况下可以调用stream.read(0)，它总会返回null。</p><p>如果内部读取缓冲低于<code>highWaterMark</code>，并且流当前不在读取状态，那么调用<code>read(0)</code>会触发一个低级<code>_read</code>调用。</p><p>虽然基本上没有必要这么做。但你在Node内部的某些地方看到它确实这么做了，尤其是在Readable流类的内部。</p><h3><code>stream.push('')</code></h3><p>推一个0字节的字符串或缓存 (不在<a href=\"#stream_object_mode\" target=\"_blank\">Object mode</a>时)会发送有趣的副作用。 因为它是一个对<a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push()</code></a>的调用，它将会结束<code>reading</code>进程。然而，它没有添加任何数据到可读缓冲区中，所以没有东西可供用户消费。  </p><p>少数情况下，你当时没有提供数据，但你的流的消费者（或你的代码的其它部分）会通过调用<code>stream.read(0)</code>得知何时再次检查。在这种情况下，你可以调用 <code>stream.push('')</code>。  </p><p>到目前为止，这个功能唯一一个使用情景是在<a href=\"a18q1iu5.html#tls_class_cryptostream\" target=\"_blank\">tls.CryptoStream</a>类中，但它将在Node v0.12中被废弃。如果你发现你不得不使用<code>stream.push('')</code>，请考虑另一种方式。</p><p><a name=\"stream_compatibility_with_older_node_versions\"></a></p><h3>和老版本的兼容性</h3><p>v0.10版本前，可读流（Readable stream）接口比较简单，因此功能和用处也小。</p><ul><li><code>'data'</code>事件会立即开始触发，而不会等待你调用<code>read()</code>方法。如果你需要进行某些I/O来决定如何处理数据，那么你只能将数据块储存到某种缓冲区中以防它们流失。   </li><li><a href=\"#stream_readable_pause\"><code>pause()</code></a>方法仅供参考，而不保证生效。这意味着，即便流处于暂停状态时，你仍然需要准备接收'data'事件。</li></ul><p>在Node v0.10中, 加入了下文所述的Readable类。为了考虑向后兼容，添加了'data'事件监听器或resume()方法被调用时，可读流（Readable stream）会切换到 \"流动模式（flowing mode）\"。其作用是，即便你不使用新的<code>read()</code>方法和<code>'readable'</code>事件，你也不必担心丢失<code>'data'</code>数据块。</p><p>大多数程序会维持正常功能。然而，下列条件下也会引入边界情况：</p><ul><li>没有添加 [<code>'data'</code>事件][]处理器</li><li>从来没有调用<a href=\"#stream_readable_resume\"><code>resume()</code></a>方法</li><li>流从来没有被倒流（pipe）到任何可写目标上、  </li></ul><p>例如：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' 方法, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);</code></pre><p>v0.10版本前的Node，流入的消息数据会被简单的抛弃。之后的版本，socket会一直保持暂停。  </p><p>这种情形下，调用<code>resume()</code>方法来开始工作：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\n// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);</code></pre><p>可读流（Readable stream）切换到流动模式（flowing mode），v0.10 版本前，可以使用<code>wrap()</code>方法将风格流包含在一个可读类里。</p><h3>Object Mode</h3><p>通常情况下，流仅操作字符串和缓存。</p><p>处于<strong>object mode</strong>的流，除了缓存和字符串，还可以可以读出普通JavaScript值。</p><p>在对象模式里，可读流（Readable stream） 调用<code>stream.read(size)</code>总会返回单个项目，无论是什么参数。</p><p>在对象模式里， 可写流（Writable stream ） 总会忽略传给<code>stream.write(data, encoding)</code>的<code>encoding</code>参数。</p><p>特殊值<code>null</code>在对象模式里，依旧保持它的特殊性。也就说，对于对象模式的可读流（Readable stream），<code>stream.read()</code>返回null意味着没有更多数据，同时<a href=\"#stream_readable_push_chunk_encoding\"><code>stream.push(null)</code></a>会告知流数据结束（EOF）。</p><p>Node核心不存在对象模式的流，这种设计只被某些用户态流式库所使用。</p><p>应该在你的子类构造函数里，设置<code>objectMode</code>。在过程中设置不安全。</p><p>对于双工流（Duplex streams），<code>objectMode</code>可以用<code>readableObjectMode</code>和<code>writableObjectMode</code>分别为读写端分别设置。这些选项，被转换流（Transform streams）用来实现解析和序列化。</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">javascript\nvar util = require('util');\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar Transform = require('stream').Transform;\nutil.inherits(JSONParseStream, Transform);\n\n// Gets \\n-delimited JSON  string data, and emits the parsed objects\nfunction JSONParseStream() {\n  if (!(this instanceof JSONParseStream))\n    return new JSONParseStream();\n\n  Transform.call(this, { readableObjectMode : true });\n\n  this._buffer = '';\n  this._decoder = new StringDecoder('utf8');\n}\n\nJSONParseStream.prototype._transform = function(chunk, encoding, cb) {\n  this._buffer += this._decoder.write(chunk);\n  // split on newlines\n  var lines = this._buffer.split(/\\r?\\n/);\n  // keep the last partial line buffered\n  this._buffer = lines.pop();\n  for (var l = 0; l &lt; lines.length; l++) {\n    var line = lines[l];\n    try {\n      var obj = JSON.parse(line);\n    } catch (er) {\n      this.emit('error', er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};\n\nJSONParseStream.prototype._flush = function(cb) {\n  // Just handle any leftover\n  var rem = this._buffer.trim();\n  if (rem) {\n    try {\n      var obj = JSON.parse(rem);\n    } catch (er) {\n      this.emit('error', er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};</code></pre></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 20,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "c1c06fe36c9a2f68a52fb9cd1f33c4a0",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 加密",
      "chapter_level_two_url": "/nodejs/v9c81itv.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>加密</h2><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">稳定性: 2 - 不稳定; 正在讨论未来版本的 API 改进，会尽量减少重大变化。详见后文。</code></pre><p>顾名思义，Node.js加密模块允许你使用加密的功能，Node.js加密模块通过使用<code>require('crypto')</code>来访问。</p><p>Node.js加密模块提供了HTTP或HTTPS连接过程中封装安全凭证的方法。</p><p>Node.js加密模块还提供了OpenSSL的哈希，hmac、加密（cipher）、解密（decipher）、签名（sign）和验证（verify）方法的封装。</p><h2 class=\"head2\">crypto.setEngine(engine[, flags])</h2><p>为某些/所有OpenSSL函数加载并设置引擎（根据参数flags来设置）。</p><p><code>engine</code>可能是id，或者是指向引擎共享库的路径。</p><p><code>flags</code>是可选参数，默认值是<code>ENGINE_METHOD_ALL</code>，它可以是以下一个或多个参数的组合（在<code>constants</code>里定义）:</p><ul><li><code>ENGINE_METHOD_RSA</code></li><li><code>ENGINE_METHOD_DSA</code></li><li><code>ENGINE_METHOD_DH</code></li><li><code>ENGINE_METHOD_RAND</code></li><li><code>ENGINE_METHOD_ECDH</code></li><li><code>ENGINE_METHOD_ECDSA</code></li><li><code>ENGINE_METHOD_CIPHERS</code></li><li><code>ENGINE_METHOD_DIGESTS</code></li><li><code>ENGINE_METHOD_STORE</code></li><li><code>ENGINE_METHOD_PKEY_METH</code></li><li><code>ENGINE_METHOD_PKEY_ASN1_METH</code></li><li><code>ENGINE_METHOD_ALL</code></li><li><code>ENGINE_METHOD_NONE</code></li></ul><h2 class=\"head2\">crypto.getCiphers()</h2><p>返回支持的加密算法名数组。</p><p>例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var ciphers = crypto.getCiphers();\nconsole.log(ciphers); // ['AES-128-CBC', 'AES-128-CBC-HMAC-SHA1', ...]</code></pre><h2 class=\"head2\">crypto.getHashes()</h2><p>返回支持的哈希算法名数组。</p><p>例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var hashes = crypto.getHashes();\nconsole.log(hashes); // ['sha', 'sha1', 'sha1WithRSAEncryption', ...]</code></pre><h2 class=\"head2\">crypto.createCredentials(details)</h2><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">稳定性: 0 - 抛弃。用 [tls.createSecureContext][] 替换</code></pre><p>根据参数details，创建一个加密凭证对象。参数为字典，key包括:</p><ul><li><code>pfx</code>: 字符串或者buffer对象，表示经PFX或PKCS12编码产生的私钥、证书以及CA证书</li><li><code>key</code>: 进过 PEM 编码的私钥</li><li><code>passphrase</code>: 私钥或pfx的密码</li><li><code>cert</code>: PEM编码的证书</li><li><code>ca</code>: 字符串或字符串数组，PEM编码的可信任的CA证书。</li><li><code>crl</code>: 字符串或字符串数组，PEM编码的CRLs（证书吊销列表Certificate Revocation List）。</li><li><code>ciphers</code>: 字符串，使用或者排除的加密算法。参见<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\" target=\"_blank\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>。</li></ul><p>如果没有指定'ca'，Node.js将会使用下面列表中的CA<a rel=\"nofollow\" href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\" target=\"_blank\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>。</p><h2 class=\"head2\">crypto.createHash(algorithm)</h2><p>创建并返回一个哈希对象，使用指定的算法来生成哈希摘要。</p><p>参数<code>algorithm</code>取决于平台的OpenSSL版本所支持的算法。例如，<code>'sha1'</code>、<code>'md5'</code>、<code>'sha256'</code>、<code>'sha512'</code>等等。在最近的版本中，<code>openssllist-message-digest-algorithms</code>会显示所有算法。</p><p>例如： 这个程序会计算文件的sha1的和。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var filename = process.argv[2];\nvar crypto = require('crypto');\nvar fs = require('fs');\n\nvar shasum = crypto.createHash('sha1');\n\nvar s = fs.ReadStream(filename);\ns.on('data', function(d) {\n  shasum.update(d);\n});\n\ns.on('end', function() {\n  var d = shasum.digest('hex');\n  console.log(d + '  ' + filename);\n});</code></pre><h2 class=\"head2\">类：Hash</h2><p>Hase用来生成数据的哈希值。</p><p>它是可读写的流<a href=\"ocq11itw.html\" target=\"_blank\">stream</a>。写入的数据来用计算哈希值。当写入流结束后，使用<code>read()</code>方法来获取计算后的哈希值。也支持旧的<code>update</code>和<code>digest</code>方法。</p><p>通过<code>crypto.createHash</code>返回。</p><h3>hash.update(data[, input_encoding])</h3><p>根据<code>data</code>来更新哈希内容，编码方式根据<code>input_encoding</code>来定，有<code>'utf8'</code>、<code>'ascii'</code>或<code>'binary'</code>。如果没有传入值，默认编码方式是<code>'binary'</code>。如果 <code>data</code>是<code>Buffer</code>，则<code>input_encoding</code>将会被忽略。  </p><p>因为它是流式数据，所以可以使用不同的数据调用很多次。  </p><h3>hash.digest([encoding])</h3><p>计算传入的数据的哈希摘要。</p><p><code>encoding</code>可以是<code>'hex'</code>、<code>'binary'</code>或<code>'base64'</code>，如果没有指定<code>encoding</code>，将返回buffer。<br>注意：调用<code>digest()</code>后不能再用<code>hash</code>对象。</p><h2 class=\"head2\">crypto.createHmac(algorithm, key)</h2><p>创建并返回一个hmac对象，用指定的算法和秘钥生成hmac图谱。</p><p>它是可读写的流<a href=\"ocq11itw.html\" target=\"_blank\">stream</a>。写入的数据来用计算hmac。当写入流结束后，使用<code>read()</code>方法来获取计算后的值。也支持旧的<code>update</code>和<code>digest</code>方法。</p><p>参数<code>algorithm</code>取决于平台上OpenSSL版本所支持的算法，参见前面的createHash。<code>key</code>是hmac算法中用的key。  </p><h2 class=\"head2\">类：Hmac</h2><p>用来创建hmac加密图谱。</p><p>通过<code>crypto.createHmac</code>返回。</p><h3>hmac.update(data)</h3><p>根据<code>data</code>更新hmac对象。因为它是流式数据，所以可以使用新数据调用多次。</p><h3>hmac.digest([encoding])</h3><p>计算传入数据的hmac值。<code>encoding</code>可以是<code>'hex'</code>、<code>'binary'</code>或<code>'base64'</code>，如果没有指定<code>encoding</code>，将返回buffer。 </p><p>注意：调用<code>digest()</code>后不能再用<code>hmac</code>对象。</p><h2 class=\"head2\">crypto.createCipher(algorithm, password)</h2><p>使用传入的算法和秘钥来生成并返回加密对象。    </p><p><code>algorithm</code>取决于OpenSSL，例如<code>'aes192'</code>等。最近发布的版本中，<code>openssl list-cipher-algorithms</code>将会展示可用的加密算法。<code>password</code>用来派生key 和IV，它必须是一个<code>'binary'</code>编码的字符串或者一个<a href=\"x1u41ith.html\" target=\"_blank\">buffer</a>。</p><p>它是可读写的<a href=\"ocq11itw.html\" target=\"_blank\">stream</a>流。写入的数据来用计算hmac。当写入流结束后，使用<code>read()</code>方法来获取计算后的值。也支持老的<code>update</code>和<code>digest</code>方法。</p><p>注意，OpenSSL函数<a rel=\"nofollow\" href=\"https://www.openssl.org/docs/crypto/EVP_BytesToKey.html\" target=\"_blank\">EVP_BytesToKey</a>摘要算法如果是一次迭代（one iteration），无需盐值（no salt）的MD5时，<code>createCipher</code>为它派生秘钥。缺少盐值使得字典攻击，相同的密码总是生成相同的key，低迭代次数和非加密的哈希算法，使得密码测试非常迅速。  </p><p>OpenSSL推荐使用pbkdf2来替换EVP_BytesToKey，推荐使用<a href=\"#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback\">crypto.pbkdf2</a>来派生key和iv ，推荐使用<a href=\"#crypto_crypto_createcipheriv_algorithm_key_iv\">createCipheriv()</a>来创建加密流。</p><h2 class=\"head2\">crypto.createCipheriv(algorithm, key, iv)</h2><p>创建并返回一个加密对象，用指定的算法，key和iv。</p><p><code>algorithm</code>参数和<code>createCipher()</code>一致。<code>key</code>在算法中用到。<code>iv</code>是一个<a rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/Initialization_vector\" target=\"_blank\">initialization vector</a>.</p><p><code>key</code>和<code>iv</code>必须是<code>'binary'</code>的编码字符串或<a href=\"x1u41ith.html\" target=\"_blank\">buffers</a>.</p><h2 class=\"head2\">类： Cipher</h2><p>加密数据的类。.</p><p>通过<code>crypto.createCipher</code>和<code>crypto.createCipheriv</code>返回。  </p><p>它是可读写的<a href=\"ocq11itw.html\" target=\"_blank\">stream</a>流。写入的数据来用计算hmac。当写入流结束后，使用<code>read()</code>方法来获取计算后的值。也支持旧的<code>update</code>和<code>digest</code>方法。  </p><h3>cipher.update(data[, input_encoding][, output_encoding])</h3><p>根据<code>data</code>来更新哈希内容，编码方式根据<code>input_encoding</code>来定，有<code>'utf8'</code>、<code>'ascii'</code>或者<code>'binary'</code>。如果没有传入值，默认编码方式是<code>'binary'</code>。如果<code>data</code>是<code>Buffer</code>，<code>input_encoding</code>将会被忽略。  </p><p><code>output_encoding</code>指定了输出的加密数据的编码格式，它可用是<code>'binary'</code>、<code>'base64'</code>或<code>'hex'</code>。如果没有提供编码，将返回buffer。</p><p>返回加密后的内容，因为它是流式数据，所以可以使用不同的数据调用很多次。</p><h3>cipher.final([output_encoding])</h3><p>返回加密后的内容，编码方式是由<code>output_encoding</code>指定，可以是<code>'binary'</code>、<code>'base64'</code>或<code>'hex'</code>。如果没有传入值，将返回buffer。</p><p>注意：<code>cipher</code>对象不能在<code>final()</code>方法之后调用。</p><h3>cipher.setAutoPadding(auto_padding=true)</h3><p>你可以禁用输入数据自动填充到块大小的功能。如果<code>auto_padding</code>是false， 那么输入数据的长度必须是加密器块大小的整倍数，否则<code>final</code>会失败。这对非标准的填充很有用，例如使用0x0而不是PKCS的填充。这个函数必须在<code>cipher.final</code>之前调用。</p><h3>cipher.getAuthTag()</h3><p>加密认证模式（目前支持：GCM），这个方法返回经过计算的认证标志<code>Buffer</code>。必须使用<code>final</code>方法完全加密后调用。</p><h3>cipher.setAAD(buffer)</h3><p>加密认证模式（目前支持：GCM），这个方法设置附加认证数据（ AAD ）。</p><h2 class=\"head2\">crypto.createDecipher(algorithm, password)</h2><p>根据传入的算法和密钥，创建并返回一个解密对象。这是<a href=\"#crypto_crypto_createcipher_algorithm_password\">createCipher()</a>的镜像。</p><h2 class=\"head2\">crypto.createDecipheriv(algorithm, key, iv)</h2><p>根据传入的算法，密钥和iv，创建并返回一个解密对象。这是<a href=\"#crypto_crypto_createcipheriv_algorithm_key_iv\">createCipheriv()</a>的镜像。</p><h2 class=\"head2\">类：Decipher</h2><p>解密数据类。</p><p>通过<code>crypto.createDecipher</code>和<code>crypto.createDecipheriv</code>返回。</p><p>解密对象是可读写的<a href=\"ocq11itw.html\" target=\"_blank\">streams</a>流。用写入的加密数据生成可读的纯文本数据。也支持老的<code>update</code>和<code>digest</code>方法。 </p><h3>decipher.update(data[, input_encoding][, output_encoding])</h3><p>使用参数<code>data</code>更新需要解密的内容，其编码方式是<code>'binary'</code>、<code>'base64'</code>或<code>'hex'</code>。如果没有指定编码方式，则把<code>data</code>当成<code>buffer</code>对象。</p><p>如果<code>data</code>是<code>Buffer</code>，则忽略<code>input_encoding</code>参数。</p><p>参数<code>output_decoding</code>指定返回文本的格式，是<code>'binary'</code>、<code>'ascii'</code>或<code>'utf8'</code>之一。如果没有提供编码格式，则返回buffer。</p><h3>decipher.final([output_encoding])</h3><p>返回剩余的解密过的内容，参数<code>output_encoding</code>是<code>'binary'</code>、<code>'ascii'</code>或<code>'utf8'</code>，如果没有指定编码方式，返回buffer。</p><p>注意：<code>decipher</code>对象不能在<code>final()</code>方法之后使用。</p><h3>decipher.setAutoPadding(auto_padding=true)</h3><p>如果加密的数据是非标准块，可以禁止其自动填充，防止<code>decipher.final</code>检查并移除。仅在输入数据长度是加密块长度的整数倍的时才有效。你必须在 <code>decipher.update</code>前调用。</p><h3>decipher.setAuthTag(buffer)</h3><p>对于加密认证模式（目前支持：GCM），必须用这个方法来传递接收到的认证标志。如果没有提供标志，或者密文被篡改，将会抛出<code>final</code>标志，认证失败，密文会被抛弃。</p><h3>decipher.setAAD(buffer)</h3><p>对于加密认证模式（目前支持：GCM），用这个方法设置附加认证数据（ AAD ）。</p><h2 class=\"head2\">crypto.createSign(algorithm)</h2><p>根据传入的算法创建并返回一个签名数据。 OpenSSL的最近版本里，<code>openssl list-public-key-algorithms</code>会列出所有算法，比如<code>'RSA-SHA256'</code>。</p><h2 class=\"head2\">类：Sign</h2><p>生成数字签名的类。</p><p>通过<code>crypto.createSign</code>返回。</p><p>签名对象是可读写的<a href=\"ocq11itw.html\" target=\"_blank\">streams</a>流。可写数据用来生成签名。当所有的数据写完，<code>sign</code>签名方法会返回签名。也支持老的<code>update</code>和<code>digest</code>方法。 </p><h3>sign.update(data)</h3><p>用参数<code>data</code>来更新签名对象。因为是流式数据，它可以被多次调用。</p><h3>sign.sign(private_key[, output_format])</h3><p>根据传送给sign的数据来计算电子签名。  </p><p><code>private_key</code>可以是一个对象或者字符串。如果是字符串，将会被当做没有密码的key。</p><p><code>private_key</code>:</p><ul><li><code>key</code>: 包含 PEM 编码的私钥</li><li><code>passphrase</code>: 私钥的密码</li></ul><p>返回值<code>output_format</code>包含数字签名， 格式是<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>之一。如果没有指定<code>encoding</code>，将返回buffer。  </p><p>注意：<code>sign</code>对象不能在<code>sign()</code>方法之后调用。</p><h2 class=\"head2\">crypto.createVerify(algorithm)</h2><p>根据传入的算法，创建并返回验证对象。是签名对象（signing object）的镜像。</p><h2 class=\"head2\">类： Verify</h2><p>用来验证签名的类。</p><p>通过<code>crypto.createVerify</code>返回。</p><p>是可写<a href=\"ocq11itw.html\" target=\"_blank\">streams</a>流。可写数据用来验证签名。一旦所有数据写完后，如签名正确<code>verify</code>方法会返回<code>true</code>。  </p><p>也支持老的<code>update</code>方法。</p><h3>verifier.update(data)</h3><p>用参数<code>data</code>来更新验证对象。因为是流式数据，它可以被多次调用。</p><h3>verifier.verify(object, signature[, signature_format])</h3><p>使用<code>object</code>和<code>signature</code>验证签名数据。参数<code>object</code>是包含了PEM编码对象的字符串，它可以是RSA公钥，DSA公钥，或X.509证书。<code>signature</code>是之前计算出来的数字签名。<code>signature_format</code>可以是<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>之一，如果没有指定编码方式 ，则默认是buffer对象。 </p><p>根据数据和公钥验证签名有效性，来返回true或false。  </p><p>注意：<code>verifier</code>对象不能在<code>verify()</code>方法之后调用。</p><h2 class=\"head2\">crypto.createDiffieHellman(prime_length[, generator])</h2><p>创建一个Diffie-Hellman密钥交换(Diffie-Hellman key exchange)对象，并根据给定的位长度生成一个质数。如果没有指定参数<code>generator</code>，默认为<code>2</code>。</p><h2 class=\"head2\">crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])</h2><p>使用传入的<code>prime</code>和<code>generator</code>创建Diffie-Hellman秘钥交互对象。  </p><p><code>generator</code>可以是数字，字符串或Buffer。  </p><p>如果没有指定<code>generator</code>，使用<code>2</code>.  </p><p><code>prime_encoding</code>和<code>generator_encoding</code>可以是<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。</p><p>如果没有指定<code>prime_encoding</code>， 则Buffer为<code>prime</code>。</p><p>如果没有指定<code>generator_encoding</code> ，则Buffer为<code>generator</code>。</p><h2 class=\"head2\">类：DiffieHellman</h2><p>创建Diffie-Hellman秘钥交换的类。</p><p>通过<code>crypto.createDiffieHellman</code>返回。 </p><h3>diffieHellman.verifyError</h3><p>在初始化的时候，如果有警告或错误，将会反应到这。它是以下值（定义在<code>constants</code>模块）：</p><ul><li><code>DH_CHECK_P_NOT_SAFE_PRIME</code></li><li><code>DH_CHECK_P_NOT_PRIME</code></li><li><code>DH_UNABLE_TO_CHECK_GENERATOR</code></li><li><code>DH_NOT_SUITABLE_GENERATOR</code></li></ul><h3>diffieHellman.generateKeys([encoding])</h3><p>生成秘钥和公钥，并返回指定格式的公钥。这个值必须传给其他部分。编码方式：<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式，将返回buffer。 </p><h3>diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])</h3><p>使用<code>other_public_key</code>作为第三方公钥来计算并返回共享秘密（shared secret）。秘钥用<code>input_encoding</code>编码。编码方式为：<code>'binary'</code>、<code>'hex'</code>或 <code>'base64'</code>。如果没有指定编码方式 ，默认为buffer。   </p><p>如果没有指定返回编码方式，将返回buffer。</p><h3>diffieHellman.getPrime([encoding])</h3><p>用参数encoding指明的编码方式返回Diffie-Hellman质数，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式，将返回buffer。</p><h3>diffieHellman.getGenerator([encoding])</h3><p>用参数encoding指明的编码方式返回Diffie-Hellman生成器，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式 ，将返回buffer。</p><h3>diffieHellman.getPublicKey([encoding])</h3><p>用参数encoding指明的编码方式返回Diffie-Hellman公钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>, 或<code>'base64'</code>。如果没有指定编码方式 ，将返回buffer。  </p><h3>diffieHellman.getPrivateKey([encoding])</h3><p>用参数encoding指明的编码方式返回Diffie-Hellman私钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式 ，将返回buffer。 </p><h3>diffieHellman.setPublicKey(public_key[, encoding])</h3><p>设置Diffie-Hellman的公钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>，如果没有指定编码方式 ，默认为buffer。 </p><h3>diffieHellman.setPrivateKey(private_key[, encoding])</h3><p>设置Diffie-Hellman的私钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>，如果没有指定编码方式 ，默认为buffer。 </p><h2 class=\"head2\">crypto.getDiffieHellman(group_name)</h2><p>创建一个预定义的Diffie-Hellman秘钥交换对象。支持的组： <code>'modp1'</code>、<code>'modp2'</code>、<code>'modp5'</code>(定义于<a rel=\"nofollow\" href=\"http://www.rfc-editor.org/rfc/rfc2412.txt\" target=\"_blank\">RFC 2412</a>)，并且<code>'modp14'</code>、<code>'modp15'</code>、<code>'modp16'</code>、<code>'modp17'</code>、<code>'modp18'</code>(定义于<a rel=\"nofollow\" href=\"http://www.rfc-editor.org/rfc/rfc3526.txt\" target=\"_blank\">RFC 3526</a>)。返回对象模仿了上述创建的<a href=\"#crypto_crypto_creatediffiehellman_prime_encoding\">crypto.createDiffieHellman()</a>对象，但是不允许修改秘钥交换（例如，<a href=\"#crypto_diffiehellman_setpublickey_public_key_encoding\">diffieHellman.setPublicKey()</a>）。使用这套流程的好处是，双方不需要生成或交换组组余数，节省了计算和通讯时间。</p><p>例如 (获取一个共享秘密):</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var crypto = require('crypto');\nvar alice = crypto.getDiffieHellman('modp5');\nvar bob = crypto.getDiffieHellman('modp5');\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, 'hex');\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, 'hex');\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre><h2 class=\"head2\">crypto.createECDH(curve_name)</h2><p>使用传入的参数<code>curve_name</code>，创建一个Elliptic Curve (EC) Diffie-Hellman秘钥交换对象。</p><h2 class=\"head2\">类：ECDH</h2><p>这个类用来创建EC Diffie-Hellman秘钥交换。</p><p>通过<code>crypto.createECDH</code>返回。</p><h3>ECDH.generateKeys([encoding[, format]])</h3><p>生成EC Diffie-Hellman的秘钥和公钥，并返回指定格式和编码的公钥，它会传递给第三方。</p><p>参数<code>format</code>是<code>'compressed'</code>、 <code>'uncompressed'</code>或 <code>'hybrid'</code>。如果没有指定，将返回<code>'uncompressed'</code>格式.</p><p>参数<code>encoding</code>是<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式，将返回buffer。 </p><h3>ECDH.computeSecret(other_public_key[, input_encoding][, output_encoding])</h3><p>以<code>other_public_key</code>作为第三方公钥计算共享秘密，并返回。秘钥会以<code>input_encoding</code>来解读。编码是：<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式，默认为buffer。</p><p>如果没有指定编码方式，将返回buffer。</p><h3>ECDH.getPublicKey([encoding[, format]])</h3><p>用参数encoding指明的编码方式返回EC Diffie-Hellman公钥，编码方式为: <code>'compressed'</code>、<code>'uncompressed'</code>或<code>'hybrid'</code>。如果没有指定编码方式 ，将返回<code>'uncompressed'</code>。</p><p>编码是：<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式 ，默认为buffer。   </p><h3>ECDH.getPrivateKey([encoding])</h3><p>用参数encoding指明的编码方式返回EC Diffie-Hellman私钥，编码是：<code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>。如果没有指定编码方式 ，默认为buffer。</p><h3>ECDH.setPublicKey(public_key[, encoding])</h3><p>设置EC Diffie-Hellman的公钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>，如果没有指定编码方式，默认为buffer。</p><h3>ECDH.setPrivateKey(private_key[, encoding])</h3><p>设置EC Diffie-Hellman的私钥，编码方式为: <code>'binary'</code>、<code>'hex'</code>或<code>'base64'</code>，如果没有指定编码方式，默认为buffer。</p><p>例如 (包含一个共享秘密):</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var crypto = require('crypto');\nvar alice = crypto.createECDH('secp256k1');\nvar bob = crypto.createECDH('secp256k1');\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, 'hex');\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, 'hex');\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre><h2 class=\"head2\">crypto.pbkdf2(password, salt, iterations, keylen[, digest], callback)</h2><p>异步PBKDF2提供了一个伪随机函数HMAC-SHA1，根据给定密码的长度，salt和iterations来得出一个密钥。回调函数得到两个参数 (err, derivedKey)。</p><p>例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">crypto.pbkdf2('secret', 'salt', 4096, 512, 'sha256', function(err, key) {\n  if (err)\n    throw err;\n  console.log(key.toString('hex'));  // 'c5e478d...1469e50'\n});</code></pre><p>在<a href=\"#crypto_crypto_gethashes\">crypto.getHashes()</a>里有支持的摘要函数列表。</p><h2 class=\"head2\">crypto.pbkdf2Sync(password, salt, iterations, keylen[, digest])</h2><p>异步PBKDF2函数， 返回derivedKey或抛出错误。</p><h2 class=\"head2\">crypto.randomBytes(size[, callback])</h2><p>生成一个密码强度随机的数据：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">// async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log('Have %d bytes of random data: %s', buf.length, buf);\n});\n\n// sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log('Have %d bytes of random data: %s', buf.length, buf);\n} catch (ex) {\n  // handle error\n  // most likely, entropy sources are drained\n}</code></pre><p>注意：如果没有足够积累的熵来生成随机强度的密码，将会抛出错误，或调用回调函数返回错误。换句话说，没有回调函数的<code>crypto.randomBytes</code>不会阻塞，即使耗尽所有的熵。</p><h2 class=\"head2\">crypto.pseudoRandomBytes(size[, callback])</h2><p>生成非密码学强度的伪随机数据。如果数据足够长会返回一个唯一数据，但是这个数可能是可以预期的。因此，当不可预期很重要的时候，不要用这个函数。例如，在生成加密的秘钥时。</p><p>用法和<code>crypto.randomBytes</code>相同。</p><h2 class=\"head2\">类： Certificate</h2><p>这个类和签过名的公钥打交道。最重要的场景是处理<code>&lt;keygen&gt;</code>元素，<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/apps/spkac.html\" target=\"_blank\">http://www.openssl.org/docs/apps/spkac.html</a>。</p><p>通过<code>crypto.Certificate</code>返回.</p><h3>Certificate.verifySpkac(spkac)</h3><p>根据SPKAC返回true或false。</p><h3>Certificate.exportChallenge(spkac)</h3><p>根据提供的SPKAC，返回加密的公钥。</p><h3>Certificate.exportPublicKey(spkac)</h3><p>输出和SPKAC关联的编码challenge。  </p><h2 class=\"head2\">crypto.publicEncrypt(public_key, buffer)</h2><p>使用<code>public_key</code>加密<code>buffer</code>。目前仅支持RSA。</p><p><code>public_key</code>可以是对象或字符串。如果<code>public_key</code>是一个字符串，将会当做没有密码的key，并会用<code>RSA_PKCS1_OAEP_PADDING</code>。</p><p><code>public_key</code>:</p><ul><li><code>key</code>: 包含有PEM编码的私钥。</li><li><code>padding</code>: 填充值，如下<ul><li><code>constants.RSA_NO_PADDING</code></li><li><code>constants.RSA_PKCS1_PADDING</code></li><li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li></ul></li></ul><p>注意：所有的填充值定义在<code>constants</code>模块.</p><h2 class=\"head2\">crypto.privateDecrypt(private_key, buffer)</h2><p>使用<code>private_key</code>来解密<code>buffer</code>.</p><p><code>private_key</code>:</p><ul><li><code>key</code>: 包含有 PEM 编码的私钥</li><li><code>passphrase</code>: 私钥的密码</li><li><code>padding</code>: 填充值，如下:<ul><li><code>constants.RSA_NO_PADDING</code></li><li><code>constants.RSA_PKCS1_PADDING</code></li><li><code>constants.RSA_PKCS1_OAEP_PADDING</code></li></ul></li></ul><p>注意：所有的填充值定义于<code>constants</code>模块.</p><h2 class=\"head2\">crypto.DEFAULT_ENCODING</h2><p>函数所用的编码方式可以是字符串或buffer ，默认值是'buffer'。这是为了加密模块兼容默认'binary'为编码方式的遗留程序。</p><p>注意：新程序希望用buffer对象，所以这是暂时手段。</p><h2 class=\"head2\">Recent API Changes</h2><p>在统一的流API概念出现前，在引入Buffer对象来处理二进制数据之前，Crypto模块就已经添加到Node。    </p><p>因此，流相关的类里没有其他的Node类里的典型方法，并且很多方法接收并返回二级制编码的字符串，而不是Buffers。在最近的版本中，这些函数改成默认使用 Buffers。</p><p>对于一些场景来说这是重大变化。  </p><p>例如，如果你使用默认参数给签名类，将结果返回给认证类，中间没有验证数据，程序会正常工作。之前你会得到二进制编码的字符串，并传递给验证类，现在则是 Buffer。</p><p>如果你之前使用的字符串数据在Buffers对象不能正常工作（比如，连接数据，并存储在数据库里 ）。或者你传递了二进制字符串给加密函数，但是没有指定编码方式，现在就需要提供编码参数。如果想切换回原来的风格，将<code>crypto.DEFAULT_ENCODING</code>设置为'binary'。注意，新的程序希望是buffers，所以之前的方法只能作为临时的办法。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 19,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "5f7f1df8649e59a96d32f0e264c0bccf",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 模块",
      "chapter_level_two_url": "/nodejs/p93z1itu.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>模块</h2><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">稳定性: 5 - 锁定</code></pre><p>本节介绍Node.js的模块系统。</p><p>Node.js有简单的模块加载系统。在Node.js模块系统中，每个文件都可以被当作单独的模块。下面例子里，<code>foo.js</code>对同一个文件夹里的<code>circle.js</code>模块进行加载。这是<code>foo.js</code>内容:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var circle = require('./circle.js');\nconsole.log( 'The area of a circle of radius 4 is '\n           + circle.area(4));</code></pre><p>这是<code>circle.js</code>内容:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var PI = Math.PI;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};</code></pre><p><code>circle.js</code>模块输出了<code>area()</code>和<code>circumference()</code>函数。想要给根模块添加函数和对象，你可以将他们添加到特定的<code>exports</code>对象。</p><p>加载到模块的变量是私有的，仿佛模块是包含在一个函数里。在这个例子里，<code>PI</code>是<code>circle.js</code>的私有变量。</p><p>如果你想模块里的根像一个函数一样的输出（比如，构造函数），或者你想输出一个完整对象，那就分派给<code>module.exports</code>，而不是<code>exports</code>。</p><p><code>bar.js</code>使用<code>square</code>模块，它输出了构造函数:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var square = require('./square.js');\nvar mySquare = square(2);\nconsole.log('The area of my square is ' + mySquare.area());</code></pre><p><code>square</code>定义在<code>square.js</code>文件里:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">// assigning to exports will not modify module, must use module.exports\nmodule.exports = function(width) {\n  return {\n    area: function() {\n      return width * width;\n    }\n  };\n}</code></pre><p>模块系统在<code>require(\"module\")</code>模块里实现。</p><h2 class=\"head2\">Cycles</h2><p>环形调用<code>require()</code>，当返回时模块可能都没执行结束。</p><p>考虑以下场景:</p><p><code>a.js</code>:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">console.log('a starting');\nexports.done = false;\nvar b = require('./b.js');\nconsole.log('in a, b.done = %j', b.done);\nexports.done = true;\nconsole.log('a done');</code></pre><p><code>b.js</code>:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">console.log('b starting');\nexports.done = false;\nvar a = require('./a.js');\nconsole.log('in b, a.done = %j', a.done);\nexports.done = true;\nconsole.log('b done');</code></pre><p><code>main.js</code>:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">console.log('main starting');\nvar a = require('./a.js');\nvar b = require('./b.js');\nconsole.log('in main, a.done=%j, b.done=%j', a.done, b.done);</code></pre><p>当<code>main.js</code>加载<code>a.js</code>，<code>a.js</code>加载<code>b.js</code>。此时，<code>b.js</code>试着加载<code>a.js</code>。为了阻止循环调用，<code>a.js</code>输出对象的不完全拷贝返回给<code>b.js</code>模块。<code>b.js</code>会结束加载，并且它的<code>exports</code>对象提供给<code>a.js</code>模块。</p><p><code>main.js</code>加载完两个模块时，它们都会结束。这个程序的输出如下：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">$ node main.js\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a.done=true, b.done=true</code></pre><p>如果你的程序有环形模块依赖，需要保证是线性的。</p><h2 class=\"head2\">核心模块</h2><p>Node有很多模块编译成二进制。这些模块在本文档的其他地方有更详细的描述。</p><p>核心模块定义在Node的源代码<code>lib/</code>目录里。</p><p><code>require()</code>总是会优先加载核心模块。例如，<code>require('http')</code>总是返回编译好的HTTP模块，而不管这个文件的名字。</p><h2 class=\"head2\">文件模块</h2><p>如果按照文件名没有找到模块，那么Node会试着加载添加了<code>.js</code>和<code>.json</code>后缀的文件，如果还没好到，再试着加载添加了后缀<code>.node</code>的文件。</p><p><code>.js</code>会解析为JavaScript的文本文件，<code>.json</code>会解析为JSON文本文件，<code>.node</code>会解析为编译过的插件模块，由<code>dlopen</code>负责加载。</p><p>模块的前缀<code>'/'</code>表示绝对路径。例如<code>require('/home/marco/foo.js')</code>将会加载 <code>/home/marco/foo.js</code>文件。</p><p>模块的前缀<code>'./'</code>表示相对于调用<code>require()</code>的路径。就是说，<code>circle.js</code>必须和<code>foo.js</code>在同一个目录里，<code>require('./circle')</code>才能找到。</p><p>文件前没有<code>/</code>或<code>./</code>前缀，表示模块可能是<code>core module</code>，或者已经从<code>node_modules</code>文件夹里加载过了。</p><p>如果指定的路径不存在，<code>require()</code>将会抛出一个<code>code</code>属性为<code>'MODULE_NOT_FOUND'</code>的异常。</p><h2 class=\"head2\">从<code>node_modules</code>目录里加载</h2><p>如传递给<code>require()</code>的模块不是一个本地模块，并且不以<code>'/'</code>,<code>'../'</code>或<code>'./'</code>开头，那么Node会从当前模块的父目录开始，尝试在它的<code>node_modules</code>文件夹里加载模块。</p><p>如果没有找到，那么会到父目录，直到到文件系统的根目录里找。</p><p>例如，如果<code>'/home/ry/projects/foo.js'</code>里的文件加载<code>require('bar.js')</code>，那么Node将会按照下面的顺序查找:</p><ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul><p>这样允许程序独立，不会产生冲突。</p><p>可以请求指定的文件或分布子目录里的模块，在模块名后添加路径后缀。例如，<code>require('example-module/path/to/file')</code>会解决<code>path/to/file</code>相对于<code>example-module</code>的加载位置。路径后缀使用相同语法。</p><h2 class=\"head2\">文件夹作为模块</h2><p>可以把程序和库放到独立的文件夹里，并提供单一的入口指向他们。有三种方法可以将文件夹作为参数传给<code>require()</code>。</p><p>第一个方法是，在文件夹的根创建一个<code>package.json</code>文件，它指定了<code>main</code>模块。<code>package.json</code>的例子如下：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">{ \"name\" : \"some-library\",\n  \"main\" : \"./lib/some-library.js\" }</code></pre><p>如果这是在<code>./some-library</code>里的文件夹，<code>require('./some-library')</code>将会试着加载<code>./some-library/lib/some-library.js</code>。</p><p>如果文件夹里没有<code>package.json</code>文件，Node会试着加载<code>index.js</code>或<code>index.node</code>文件。例如，如果上面的例子里没有package.json文件。那么  <code>require('./some-library')</code>将会试着加载：</p><ul><li><code>./some-library/index.js</code></li><li><code>./some-library/index.node</code></li></ul><h2 class=\"head2\">缓存</h2><p>模块第一次加载后会被被缓存。这就是说，每次调用<code>require('foo')</code>都会返回同一个对象，当然，必须每次都要解析到同一个文件。</p><p>多次调用<code>require('foo')</code>也许不会导致模块代码多次执行。这是很重要的特性，这样就可以返回\"partially done\"对象，允许加载过渡性的依赖关系，即使可能会引起环形调用。</p><p>如果你希望多次调用一个模块，那么就输出一个函数，然后调用这个函数。</p><h3>模块换成预警</h3><p>模块的缓存依赖于解析后的文件名。因此随着调用位置的不同，模块可能解析到不同的文件（例如，从<code>node_modules</code>文件夹加载）。如果解析为不同的文件，<code>require('foo')</code>可能会返回不同的对象。  </p><h2 class=\"head2\"><code>module</code> 对象</h2><ul><li>{Object}</li></ul><p>在每个模块中，变量<code>module</code>是一个代表当前模块的对象的引用。为了方便，<code>module.exports</code>可以通过<code>exports</code>全局模块访问。<code>module</code>不是事实上的全局对象，而是每个模块内部的。</p><h3>module.exports</h3><ul><li>{Object}</li></ul><p>模块系统创建<code>module.exports</code>对象。很多人希望自己的模块是某个类的实例。因此，把将要导出的对象赋值给<code>module.exports</code>。注意，将想要的对象赋值给 <code>exports</code>，只是简单的将它绑定到本地<code>exports</code>变量，这可能并不是你想要的。</p><p>例如，假设我们有一个模块叫<code>a.js</code>。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var EventEmitter = require('events').EventEmitter;\n\nmodule.exports = new EventEmitter();\n\n// Do some work, and after some time emit\n// the 'ready' event from the module itself.\nsetTimeout(function() {\n  module.exports.emit('ready');\n}, 1000);</code></pre><p>另一个文件可以写成如下的形式：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var a = require('./a');\na.on('ready', function() {\n  console.log('module a is ready');\n});</code></pre><p>注意：赋给<code>module.exports</code>必须马上执行，并且不能在回调中执行。</p><p>x.js:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">setTimeout(function() {\n  module.exports = { a: \"hello\" };\n}, 0);</code></pre><p>y.js:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var x = require('./x');\nconsole.log(x.a);</code></pre><h4>exports alias</h4><p><code>exports</code>变量在引用到<code>module.exports</code>的模块里可用。和其他变量一样，如果你给他赋一个新的值，它不再指向老的值。</p><p>为了展示这个特性，假设实现：<code>require()</code>:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">function require(...) {\n  // ...\n  function (module, exports) {\n    // Your module code here\n    exports = some_func;        // re-assigns exports, exports is no longer\n                                // a shortcut, and nothing is exported.\n    module.exports = some_func; // makes your module export 0\n  } (module, module.exports);\n  return module;\n}</code></pre><p>如果你对<code>exports</code>和<code>module.exports</code>间的关系感到迷糊，那就只用<code>module.exports</code>就好。</p><h3>module.require(id)</h3><ul><li><code>id</code> {String}</li><li>返回: {Object} 已经解析模块的<code>module.exports</code> </li></ul><p><code>module.require</code>方法提供了一种像<code>require()</code>一样从最初的模块加载一个模块的方法。</p><p>为了能这样做，你必须获得<code>module</code>对象的引用。<code>require()</code>返回<code>module.exports</code>，并且<code>module</code>是一个典型的只能在特定模块作用域内有效的变量，如果要使用它，就必须明确的导出。</p><h3>module.id</h3><ul><li>{String}</li></ul><p>模块的标识符。通常是完全解析的文件名。</p><h3>module.filename</h3><ul><li>{String}</li></ul><p>模块完全解析的文件名。</p><h3>module.loaded</h3><ul><li>{Boolean}</li></ul><p>模块是已经加载完毕，还是在加载中。</p><h3>module.parent</h3><ul><li>{Module Object}</li></ul><p>引入这个模块的模块。</p><h3>module.children</h3><ul><li>{Array}</li></ul><p>由这个模块引入的模块。</p><h2 class=\"head2\">其他...</h2><p>为了获取即将用<code>require()</code>加载的准确文件名，可以使用<code>require.resolve()</code>函数。</p><p>综上所述，下面用伪代码的高级算法形式演示了require.resolve的工作流程：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">require(X) from module at path Y\n1. If X is a core module,\n   a. return the core module\n   b. STOP\n2. If X begins with './' or '/' or '../'\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n3. LOAD_NODE_MODULES(X, dirname(Y))\n4. THROW \"not found\"\n\nLOAD_AS_FILE(X)\n1. If X is a file, load X as JavaScript text.  STOP\n2. If X.js is a file, load X.js as JavaScript text.  STOP\n3. If X.json is a file, parse X.json to a JavaScript Object.  STOP\n4. If X.node is a file, load X.node as binary addon.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. If X/package.json is a file,\n   a. Parse X/package.json, and look for \"main\" field.\n   b. let M = X + (json main field)\n   c. LOAD_AS_FILE(M)\n2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP\n3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n4. If X/index.node is a file, load X/index.node as binary addon.  STOP\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I &gt;= 0,\n   a. if PARTS[I] = \"node_modules\" CONTINUE\n   c. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n   b. DIRS = DIRS + DIR\n   c. let I = I - 1\n5. return DIRS</code></pre><h2 class=\"head2\">从全局文件夹加载</h2><p>如果环境变量<code>NODE_PATH</code>设置为冒号分割的绝对路径列表，并且在模块在其他地方没有找到，Node将会搜索这些路径。（注意，在Windows系统中，<code>NODE_PATH</code>用分号分割 ）。</p><p>另外，Node将会搜索这些路径。</p><ul><li>1:<code>$HOME/.node_modules</code></li><li>2:<code>$HOME/.node_libraries</code></li><li>3:<code>$PREFIX/lib/node</code></li></ul><p><code>$HOME</code>是用户的home文件夹，<code>$PREFIX</code>是Node里配置的<code>node_prefix</code>。</p><p>这大多是历史原因照成的。强烈建议将所以来的模块放到<code>node_modules</code>文件夹里。这样加载会更快。</p><h2 class=\"head2\">访问主模块</h2><p>当Node运行一个文件时，<code>require.main</code>就会设置为它的<code>module</code>。也就是说你可以通过测试判断文件是否被直接运行。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">require.main === module</code></pre><p>对于<code>foo.js</code>文件。 如果直接运行<code>node foo.js</code>，返回<code>true</code>，如果通过<code>require('./foo')</code>是间接运行。</p><p>因为<code>module</code>提供了<code>filename</code>属性（通常等于<code>__filename</code>），程序的入口点可以通过检查<code>require.main.filename</code>来获得。</p><h2 class=\"head2\">附录: 包管理技巧</h2><p>Node的<code>require()</code>函数语义定义的足够通用，它能支持各种常规目录结构。诸如<code>dpkg</code>,<code>rpm</code>和<code>npm</code>包管理程序，不用修改就可以从Node模块构建本地包。</p><p>下面我们介绍一个可行的目录结构：</p><p>假设我们有一个<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>文件夹，它包含指定版本的包内容。</p><p>一个包可以依赖于其他包。为了安装包foo，可能需要安装特定版本的<code>bar</code>包。<code>bar</code>包可能有自己的包依赖，某些条件下，依赖关系可能会发生冲突或形成循环。</p><p>因为Node会查找他所加载的模块的<code>realpath</code>（也就是说会解析符号链接），然后按照上文描述的方式在node_modules目录中寻找依赖关系，这种情形跟以下体系结构非常相像：</p><ul><li><code>/usr/lib/node/foo/1.2.3/</code> -  <code>foo</code>包，version 1.2.3。</li><li><code>/usr/lib/node/bar/4.3.2/</code> -   <code>foo</code>依赖的<code>bar</code>包内容。</li><li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>- 指向<code>/usr/lib/node/bar/4.3.2/</code>的符号链接。</li><li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code>- 指向<code>bar</code>包所依赖的包的符号链接。</li></ul><p>因此，即使存在循环依赖或依赖冲突，每个模块还可以获得他所依赖的包得可用版本。</p><p>当<code>foo</code>包里的代码调用<code>foo</code> ，将会获得符号链接<code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>指向的版本。然后，当bar包中的代码调用 <code>require('queue')</code>，将会获得符号链接<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>指向的版本。</p><p>另外，为了让模块搜索更快些，不要将包直接放在<code>/usr/lib/node</code>目录中，而是将它们放在<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>目录中。这样在依赖的包找不到的情况下，就不会一直寻找/<code>usr/node_modules</code>目录或<code>/node_modules</code>目录了。基于调用require()的文件所在真实路径，因此包本身可以放在任何位置。</p><p>为了让Node模块对<a href=\"https://www.w3cschool.cn/nodejs/yw6r1ito.html\" target=\"_blank\">Node REPL</a>可用，可能需要将<code>/usr/lib/node_modules</code>文件夹路径添加到环境变量<code>$NODE_PATH</code>。由于模块查找<code>$NODE_PATH</code>文件夹都是相对路径，因此包可以放到任何位置。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 18,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "4b2c3640f90f1e19272a5a932f7f265e",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 控制台",
      "chapter_level_two_url": "/nodejs/of871itt.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>控制台</h2><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">稳定性: 4 - 冻结</code></pre><ul><li>{Object}</li></ul><p>Node.js的console模块提供了一个简单的调试控制台。<br></p><p>Node.js控制台的作用是可以将输出字符打印到stdout（标准输出）和stderr（标准错误）。类似于大部分浏览器提供的console对象函数，Node也是输出到stdout和 stderr。</p><p>如果输出目标是终端或文件的时候，console函数是同步的（这是为了防止意外的退出而导致数据丢失），输出是管道的时候是异步的（防止阻塞时间太长）。</p><p>下面的例子里，stdout是非阻塞的，而stderr是阻塞的：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">$ node script.js 2&gt; error.log | tee info.log</code></pre><p>平常使用过程中，只有发现大批量的数据时，才会考虑阻塞或非阻塞问题。</p><h2 class=\"head2\">console.log([data][, ...])</h2><p>输出到stdout并新起一行。和<code>printf()</code>类似，stdout可以传入多个参数，例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var count = 5;\nconsole.log('count: %d', count);\n// prints 'count: 5'</code></pre><p>如果第一个字符里没有找到格式化的元素，<code>util.inspect</code>将会应用到各个参数，参见<a rel=\"nofollow\" href=\"https://nodejs.org/api/util.html#util_util_format_format\" target=\"_blank\">util.format()</a></p><h2 class=\"head2\">console.info([data][, ...])</h2><p>参见<code>console.log</code>。</p><h2 class=\"head2\">console.error([data][, ...])</h2><p>参见<code>console.log</code>，不同的是打印到stderr。</p><h2 class=\"head2\">console.warn([data][, ...])</h2><p>参见<code>console.error</code>。</p><h2 class=\"head2\">console.dir(obj[, options])</h2><p>在<code>obj</code>使用<code>util.inspect</code>，并打印结果到stdout，而这个函数绕过<code>inspect()</code>。<code>options</code>参数可能传入以下几种：</p><ul><li><p><code>showHidden</code>-  如果是<code>true</code>，将会展示对象的非枚举属性，默认是<code>false</code> 。</p></li><li><p><code>depth</code>- <code>inspect</code>对象递归的次数，对于复杂对象的扫描非常有用。默认是<code>2</code>。想要严格递归，传入<code>null</code>。</p></li><li><code>colors</code>- 如果是<code>true</code>，输出会格式化为 ANSI 颜色代码。默认是<code>false</code>。颜色可以定制，下面会介绍。</li></ul><h2 class=\"head2\">console.time(label)</h2><p>标记一个时间点。</p><h2 class=\"head2\">console.timeEnd(label)</h2><p>计时器结束的时候，记录输出，例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">console.time('100-elements');\nfor (var i = 0; i &lt; 100; i++) {\n  ;\n}\nconsole.timeEnd('100-elements');\n// prints 100-elements: 262ms</code></pre><h2 class=\"head2\">console.trace(message[, ...])</h2><p>输出当前位置的栈跟踪到stderr<code>'Trace :'</code>。</p><h2 class=\"head2\">console.assert(value[, message][, ...])</h2><p>和<a rel=\"nofollow\" href=\"https://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message\" target=\"_blank\">assert.ok()</a>类似, 但是错误的输出格式为：<code>util.format(message...)</code>。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 17,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "1d82ffa71e164192348b7abbd4984e5d",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js HTTPS",
      "chapter_level_two_url": "/nodejs/85n21its.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>HTTPS</h2><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">稳定性: 3 - 稳定</code></pre><p>HTTPS是什么？HTTPS是基于TLS/SSL的HTTP协议，在Node.js里它可以作为单独的模块来实现。在本文中，你将了解HTTPS的使用方法。</p><h2 class=\"head2\">类: https.Server</h2><p>https.Server是<code>tls.Server</code>的子类，并且和<code>http.Server</code>一样触发事件。更多信息参见<code>http.Server</code>。</p><h3>server.setTimeout(msecs, callback)</h3><p>详情参见<a href=\"1v9k1itp.html\" http_server_settimeout_msecs_callback=\"\" target=\"_blank\">http.Server#setTimeout()</a>.</p><h3>server.timeout</h3><p>详情参见<a href=\"1v9k1itp.html\" http_server_timeout=\"\" target=\"_blank\">http.Server#timeout</a>.</p><h2 class=\"head2\">https.createServer(options[, requestListener])</h2><p>返回一个新的HTTPS服务器对象。其中<code>options</code>类似于 [tls.createServer()][tls.md#tls_tls_createserver_options_secureconnectionlistener]。 <code>requestListener</code>函数自动加到<code>'request'</code>事件里。</p><p>例如:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">// curl -k https://localhost:8000/\nvar https = require('https');\nvar fs = require('fs');\n\nvar options = {\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')\n};\n\nhttps.createServer(options, function (req, res) {\n  res.writeHead(200);\n  res.end(\"hello world\\n\");\n}).listen(8000);</code></pre><p>或：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var https = require('https');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('server.pfx')\n};\n\nhttps.createServer(options, function (req, res) {\n  res.writeHead(200);\n  res.end(\"hello world\\n\");\n}).listen(8000);</code></pre><h3>server.listen(port[, host][, backlog][, callback])</h3><h3>server.listen(path[, callback])</h3><h3>server.listen(handle[, callback])</h3><p>详情参见<a href=\"1v9k1itp.html\" http_server_listen_port_hostname_backlog_callback=\"\" target=\"_blank\">http.listen()</a>。</p><h3>server.close([callback])</h3><p>详情参见<a href=\"1v9k1itp.html\" http_server_close_callback=\"\" target=\"_blank\">http.close()</a>。</p><p><a name=\"https_https_request_options_callback\"></a></p><h2 class=\"head2\">https.request(options, callback)</h2><p>可以给安全web服务器发送请求。<br></p><p><code>options</code>可以是一个对象或字符串。如果<code>options</code>是字符串，则会被<a href=\"eq9c1iu9.html\" url=\"\" parse=\"\" target=\"_blank\">url.parse()</a>解析。</p><p>所有来自<a href=\"1v9k1itp.html\" http_http_request_options_callback=\"\" target=\"_blank\">http.request()</a>选项都是经过验证的。</p><p>例如:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var https = require('https');\n\nvar options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET'\n};\n\nvar req = https.request(options, function(res) {\n  console.log(\"statusCode: \", res.statusCode);\n  console.log(\"headers: \", res.headers);\n\n  res.on('data', function(d) {\n    process.stdout.write(d);\n  });\n});\nreq.end();\n\nreq.on('error', function(e) {\n  console.error(e);\n});</code></pre><p>option参数具有以下的值：</p><ul><li><code>host</code>: 请求的服务器域名或IP地址，默认：<code>'localhost'</code></li><li><code>hostname</code>: 用于支持<code>url.parse()</code>。<code>hostname</code>优于<code>host</code></li><li><code>port</code>: 远程服务器端口。默认： 443。</li><li><code>method</code>: 指定HTTP请求方法。默认：<code>'GET'</code>。</li><li><code>path</code>: 请求路径。默认：<code>'/'</code>。如果有查询字符串，则需要包含。比如<code>'/index.html?page=12'</code></li><li><code>headers</code>: 包含请求头的对象</li><li><code>auth</code>: 用于计算认证头的基本认证，即<code>user:password</code></li><li><code>agent</code>: 控制Agent的行为。当使用了一个Agent的时候，请求将默认为<code>Connection: keep-alive</code>。可能的值为：<ul><li><code>undefined</code> (default): 在这个主机和端口上使用[global Agent][]</li><li><code>Agent</code> object: 在<code>Agent</code>中显式使用passed.</li><li><code>false</code>: 选择性停用连接池,默认请求为：<code>Connection: close</code></li></ul></li></ul><p><a href=\"a18q1iu5.html\" tls_tls_connect_options_callback=\"\" target=\"_blank\">tls.connect()</a>的参数也能指定。但是，<a href=\"85n21its.html\" https_https_globalagent=\"\" target=\"_blank\">globalAgent</a>会忽略他们。</p><ul><li><code>pfx</code>: SSL使用的证书，私钥，和证书Certificate，默认为<code>null</code>.</li><li><code>key</code>: SSL使用的私钥. 默认为<code>null</code>.</li><li><code>passphrase</code>: 私钥或pfx的口令字符串. 默认为<code>null</code>.</li><li><code>cert</code>: 所用公有x509证书. 默认为<code>null</code>.</li><li><code>ca</code>: 用于检查远程主机的证书颁发机构或包含一系列证书颁发机构的数组。</li><li><code>ciphers</code>: 描述要使用或排除的密码的字符串，格式请参阅<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\" target=\"_blank\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a></li><li><code>rejectUnauthorized</code>: 如为<code>true</code>则服务器证书会使用所给CA列表验证。如果验证失败则会触发<code>error</code>事件。验证过程发生于连接层，在<code>HTTP</code>请求发送之前。默认为<code>true</code>.</li><li><code>secureProtocol</code>: 所用的SSL方法，比如<code>TLSv1_method</code>强制使用TLS version 1。可取值取决于您安装的OpenSSL，和定义于<a rel=\"nofollow\" href=\"http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS\" target=\"_blank\">SSL_METHODS</a>的常量。</li></ul><p>要指定这些选项，使用一个自定义<code>Agent</code>。</p><p>例如:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')\n};\noptions.agent = new https.Agent(options);\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre><p>或者不使用<code>Agent</code>.</p><p>例如:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),\n  agent: false\n};\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre><h2 class=\"head2\">https.get(options, callback)</h2><p>和<code>http.get()</code>类似，不过是HTTPS版本的.</p><p><code>options</code>可以是字符串对象. 如果<code>options</code>是字符串, 会自动使用<a href=\"eq9c1iu9.html#url.parse\" target=\"_blank\">url.parse()</a>解析。</p><p>例如:</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var https = require('https');\n\nhttps.get('https://encrypted.google.com/', function(res) {\n  console.log(\"statusCode: \", res.statusCode);\n  console.log(\"headers: \", res.headers);\n\n  res.on('data', function(d) {\n    process.stdout.write(d);\n  });\n\n}).on('error', function(e) {\n  console.error(e);\n});</code></pre><p><a name=\"https_class_https_agent\"></a></p><h2 class=\"head2\">类: https.Agent</h2><p>HTTPS的Agent对象，和<a href=\"1v9k1itp.html\" http_class_http_agent=\"\" target=\"_blank\">http.Agent</a>类似。详情参见<a href=\"85n21its.html\" https_https_request_options_callback=\"\" target=\"_blank\">https.request()</a>。</p><p><a name=\"https_https_globalagent\"></a></p><h2 class=\"head2\">https.globalAgent</h2><p>所有HTTPS客户端请求的<a href=\"85n21its.html\" https_class_https_agent=\"\" target=\"_blank\">https.Agent</a>全局实例。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 16,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "617e515e80c9301340fe61824efbea52",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js Smalloc",
      "chapter_level_two_url": "/nodejs/95fo1itr.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Smalloc</h2><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">稳定性: 1 - 试验</code></pre><h2 class=\"head2\">类: smalloc</h2><p>表示能够通过简单的内存分配器（处理扩展原始内存的分配）支持的缓存，可供Smalloc使用的函数如下所示：</p><h3>smalloc.alloc(length[, receiver][, type])</h3><ul><li><code>length</code> {Number} <code>&lt;= smalloc.kMaxLength</code></li><li><code>receiver</code> {Object} 默认: <code>new Object</code></li><li><code>type</code> {Enum} 默认: <code>Uint8</code></li></ul><p>此函数的作用为返回包含分配的外部数组数据的<code>receiver</code>对象。如果没有传入<code>receiver</code>，则将会创建并返回一个新的对象。</p><p>这可以用来创建你自己的类似buffer的类。不会设置其他属性，因此使用者需要跟踪其他所需信息（比如分配的长度）。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">function SimpleData(n) {\n  this.length = n;\n  smalloc.alloc(this.length, this);\n}\n\nSimpleData.prototype = { /* ... */ };</code></pre><p>仅检查<code>receiver</code>是否是非数组的对象。因此，可以分配扩展数据数据，不仅是普通对象。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">function allocMe() { }\nsmalloc.alloc(3, allocMe);\n\n// { [Function allocMe] '0': 0, '1': 0, '2': 0 }</code></pre><p>v8不支持给数组分配扩展数组对象，如果这么做，将会抛出。</p><p>你可以指定外部数组数据的类型，在<code>smalloc.Types</code>列出了可供使用的外部数组数据的类型，例如：</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var doubleArr = smalloc.alloc(3, smalloc.Types.Double);\n\nfor (var i = 0; i &lt; 3; i++)\n  doubleArr = i / 10;\n\n// { '0': 0, '1': 0.1, '2': 0.2 }</code></pre><p>使用<code>Object.freeze</code>,<code>Object.seal</code>和<code>Object.preventExtensions</code>不能冻结、封锁、阻止对象的使用扩展数据扩展。</p><h3>smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);</h3><ul><li><code>source</code> {Object} 分配了外部数组的对象</li><li><code>sourceStart</code> {Number} 负责的起始位置</li><li><code>dest</code> {Object} 分配了外部数组的对象</li><li><code>destStart</code> {Number} 拷贝到目标的起始位置</li><li><code>copyLength</code> {Number} 需要拷贝的长度</li></ul><p>将内存从一个外部数组分配复制到另一个数组中，任何参数都是可选的，否则会抛出异常。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var a = smalloc.alloc(4);\nvar b = smalloc.alloc(4);\n\nfor (var i = 0; i &lt; 4; i++) {\n  a[i] = i;\n  b[i] = i * 2;\n}\n\n// { '0': 0, '1': 1, '2': 2, '3': 3 }\n// { '0': 0, '1': 2, '2': 4, '3': 6 }\n\nsmalloc.copyOnto(b, 2, a, 0, 2);\n\n// { '0': 4, '1': 6, '2': 2, '3': 3 }</code></pre><p><code>copyOnto</code>将自动检测内部分配的长度，因此不需要设置任何附加参数。</p><h3>smalloc.dispose(obj)</h3><ul><li><code>obj</code> Object</li></ul><p>释放通过<code>smalloc.alloc</code>给对象分配的内存。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var a = {};\nsmalloc.alloc(3, a);\n\n// { '0': 0, '1': 0, '2': 0 }\n\nsmalloc.dispose(a);\n\n// {}</code></pre><p>这对于减轻垃圾回收器的负担是有效的，但是在开发的时候还是要小心，程序里可能会出现难以跟踪的错误。</p><pre lang=\"html\" style=\"max-width: 100%;\"><code class=\"html\">var a = smalloc.alloc(4);\nvar b = smalloc.alloc(4);\n\n// perform this somewhere along the line\nsmalloc.dispose(b);\n\n// now trying to copy some data out\nsmalloc.copyOnto(b, 2, a, 0, 2);\n\n// now results in:\n// RangeError: copy_length &gt; source_length</code></pre><p>调用<code>dispose()</code>，对象依旧拥有外部数据，例如<code>smalloc.hasExternalData()</code>会返回<code>true</code>。<code>dispose()</code>不支持缓存，如果传入将会抛出。</p><h3>smalloc.hasExternalData(obj)</h3><ul><li><code>obj</code> {Object}</li></ul><p>如果<code>obj</code>拥有外部分配的内存，返回<code>true</code>。</p><h3>smalloc.kMaxLength</h3><p>可分配的最大数量。则同样适用于缓冲区的创建。</p><h3>smalloc.Types</h3><p>外部数组的类型，包含：</p><ul><li><code>Int8</code></li><li><code>Uint8</code></li><li><code>Int16</code></li><li><code>Uint16</code></li><li><code>Int32</code></li><li><code>Uint32</code></li><li><code>Float</code></li><li><code>Double</code></li><li><code>Uint8Clamped</code></li></ul></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 15,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "9fabcbdc8244877b4e40be9b6b77f2c7",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 集群",
      "chapter_level_two_url": "/nodejs/i8321itq.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>集群</h2><pre><code class=\"hljs\">稳定性: 2 - 不稳定</code></pre><p>单个Node.js实例在单线程中运行，在某些情况下，它可能出现负载，因此为了能够更好的利用多核系统的能力，你可以使用Node.js内置的集群（cluster）功能来处理负载。<br></p><p>在集群模块里很容易就能创建一个共享所有服务器接口的进程。  </p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> cluster = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'cluster'</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> http = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> numCPUs = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'os'</span></span>).cpus().length;\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isMaster) {\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Fork workers.</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'exit'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, code, signal</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'worker '</span></span> + worker.process.pid + <span class=\"hljs-string\"><span class=\"hljs-string\">' died'</span></span>);\n  });\n} <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> {\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Workers can share any TCP connection</span></span>\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// In this case its a HTTP server</span></span>\n  http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, res</span></span></span><span class=\"hljs-function\">) </span></span>{\n    res.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>);\n    res.end(<span class=\"hljs-string\"><span class=\"hljs-string\">\"hello world\\n\"</span></span>);\n  }).listen(<span class=\"hljs-number\"><span class=\"hljs-number\">8000</span></span>);\n}</code></pre><p>运行Node后，将会在所有工作进程里共享8000端口。  </p><pre><code class=\"hljs\">% NODE_DEBUG=cluster node server.js\n23521,Master Worker 23524 online\n23521,Master Worker 23526 online\n23521,Master Worker 23523 online\n23521,Master Worker 23528 online</code></pre><p>这个特性是最近才引入的，大家可以试试并提供反馈。</p><p>还要注意，在Windows系统里还不能在工作进程中创建一个被命名的管道服务器。  </p><h2 class=\"head2\">如何工作</h2><p><code>child_process.fork</code>方法派生工作进程，所以它能通过IPC和父进程通讯，并相互传递句柄。</p><p>集群模块通过以下的两种分发模式来处理连接：  </p><p>第一种（默认方法，除了Windows平台）为循环式。主进程监听一个端口，接收新的连接，再轮流的分发给工作进程。</p><p>第二种，主进程监听socket，并发送给感兴趣的工作进程，工作进程直接接收连接。  </p><p>比较上述两种方法，第二种方法理论上性能最高。实际上，由于操作系统各式各样，分配往往分配不均。比如，70%的连接终止于2个进程，实际上共有8个进程。</p><p>因为<code>server.listen()</code>将大部分工作交给了主进程，所以一个普通的Node.js进程和一个集群工作进程会在三种情况下有所区别：</p><ol><li><code>server.listen({fd: 7})</code>由于消息被传回主进程，所以将会监听<strong>主进程</strong>里的文件描述符，而不是其他工作进程里的文件描述符 7。</li><li><code>server.listen(handle)</code>监听一个明确地句柄，会使得工作进程使用指定句柄，而不是与主进程通讯。如果工作进程已经拥有了该句柄，前提是您知道在做什么。</li><li><code>server.listen(0)</code>通常它会让服务器随机监听端口。然而在集群里每个工作进程<code>listen(0)</code>时会收到相同的端口。实际上仅第一次是随机的，之后是可预测的。如果你想监听一个特定的端口，可以根据集群的工作进程的ID生产一个端口ID 。 </li></ol><p>在Node.js或你的程序里没有路由逻辑，工作进程见也没有共享状态。因此，像登录和会话这样的工作，不要设计成过度依赖内存里的对象。</p><p>因为工作线程都是独立的，你可以根据需求来杀死或者派生而不会影响其他进程。只要仍然有工作进程，服务器还会接收连接。Node不会自动管理工作进程的数量，这是你的责任，你可以根据自己需求来管理。</p><h2 class=\"head2\">cluster.schedulingPolicy</h2><p>调度策略<code>cluster.SCHED_RR</code>表示轮流制，<code>cluster.SCHED_NONE</code>表示操作系统处理。这是全局性的设定，一旦你通过<code>cluster.setupMaster()</code>派生了第一个工作进程，它就不可更改了。</p><p><code>SCHED_RR</code>是除Windows外所有系统的默认设置。只要libuv能够有效地分配IOCP句柄并且不产生巨大的性能损失，Windows也会改为SCHED_RR方式。</p><p><code>cluster.schedulingPolicy</code>也可通过环境变量<code>NODE_CLUSTER_SCHED_POLICY</code>来更改。有效值为<code>\"rr\"</code>和<code>\"none\"</code>。</p><h2 class=\"head2\">cluster.settings</h2><ul><li>{Object}<ul><li><code>execArgv</code> {Array} 传给可执行的Node的参数列表(默认=<code>process.execArgv</code>)</li><li><code>exec</code> {String} 执行文件的路径。  (默认=<code>process.argv[1]</code>)</li><li><code>args</code> {Array} 传给工作进程的参数列表(默认=<code>process.argv.slice(2)</code>)</li><li><code>silent</code> {Boolean}是否将输出发送给父进程的stdio。(默认=<code>false</code>)</li><li><code>uid</code> {Number} 设置用户进程的ID。 (参考setuid(2)。)</li><li><code>gid</code> {Number} 设置进程组的ID。 (参考setgid(2)。)</li></ul></li></ul><p>调用<code>.setupMaster()</code>(或<code>.fork()</code>)方法后，这个settings对象会包含设置内容，包括默认值。 </p><p>设置后会立即冻结，因为<code>.setupMaster()</code>只能调用一次。  </p><p>这个对象不应该被手动改变或设置。  </p><h2 class=\"head2\">cluster.isMaster</h2><ul><li>{Boolean}</li></ul><p>如果是主进程，返回true。如果<code>process.env.NODE_UNIQUE_ID</code>未定义，则<code>isMaster</code>为<code>true</code>。</p><h2 class=\"head2\">cluster.isWorker</h2><ul><li>{Boolean}</li></ul><p>如果不是主进程返回true(和<code>cluster.isMaster</code>相反)。</p><h2 class=\"head2\">事件: 'fork'</h2><ul><li><code>worker</code> {Worker object}</li></ul><p>当一个新的工作进程被分支出来，集群模块会产生'fork'事件。它可用于记录工作进程，并创建自己的超时管理。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> timeouts = [];\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">errorMsg</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.error(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Something must be wrong with the connection ...\"</span></span>);\n}\n\ncluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'fork'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker</span></span></span><span class=\"hljs-function\">) </span></span>{\n  timeouts[worker.id] = setTimeout(errorMsg, <span class=\"hljs-number\"><span class=\"hljs-number\">2000</span></span>);\n});\ncluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'listening'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, address</span></span></span><span class=\"hljs-function\">) </span></span>{\n  clearTimeout(timeouts[worker.id]);\n});\ncluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'exit'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, code, signal</span></span></span><span class=\"hljs-function\">) </span></span>{\n  clearTimeout(timeouts[worker.id]);\n  errorMsg();\n});</code></pre><h2 class=\"head2\">事件: 'online'</h2><ul><li><code>worker</code> {Worker object}</li></ul><p>分支出一个新的工作进程后，它会响应在线消息。当主线程接收到在线消息后，它会触发这个事件。'fork'和'online'之间的区别在于，主进程分支一个工作进程后会调用 fork，而工作进程运行后会调用emitted。  </p><pre><code class=\"hljs javascript\">cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'online'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Yay, the worker responded after it was forked\"</span></span>);\n});</code></pre><h2 class=\"head2\">事件: 'listening'</h2><ul><li><code>worker</code> {Worker object}</li><li><code>address</code> {Object}</li></ul><p>工作进程调用<code>listen()</code>时，服务器会触发'listening'事件，同时也会在主进程的集群里触发。</p><p>事件处理函数有两个参数，<code>worker</code>包含工作进程对象，<code>address</code>包含以下属性：<code>address</code>, <code>port</code>和<code>addressType</code>。如果工作进程监听多个地址的时候，这些东西非常有用。</p><pre><code class=\"hljs javascript\">cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'listening'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, address</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"A worker is now connected to \"</span></span> + address.address + <span class=\"hljs-string\"><span class=\"hljs-string\">\":\"</span></span> + address.port);\n});</code></pre><p><code>addressType</code>是以下内容:</p><ul><li><code>4</code> (TCPv4)</li><li><code>6</code> (TCPv6)</li><li><code>-1</code> (unix domain socket)</li><li><code>\"udp4\"</code> 或者<code>\"udp6\"</code>(UDP v4或者v6)*  </li></ul><h2 class=\"head2\">事件: 'disconnect'</h2><ul><li><code>worker</code> {Worker object}</li></ul><p>当一个工作进程的IPC通道关闭时会触发这个事件。当工作进程正常退出，被杀死，或者手工关闭（例如worker.disconnect()）时会调用。</p><p><code>disconnect</code>和<code>exit</code>事件间可能存在延迟。 这些事件可以用来检测进程是否卡在清理过程中，或者存在长连接。</p><pre><code class=\"hljs javascript\">cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'disconnect'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'The worker #'</span></span> + worker.id + <span class=\"hljs-string\"><span class=\"hljs-string\">' has disconnected'</span></span>);\n});</code></pre><h2 class=\"head2\">事件: 'exit'</h2><ul><li><code>worker</code> {Worker object}</li><li><code>code</code> {Number} 如果正常退出，则为退出代码.</li><li><code>signal</code> {String} 使得进程被杀死的信号名 (比如，<code>'SIGHUP'</code>)  </li></ul><p>当任意一个工作进程终止的时候，集群模块会触发'exit'事件。  </p><p>可以调用<code>.fork()</code>重新启动工作进程。</p><pre><code class=\"hljs javascript\">cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'exit'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, code, signal</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'worker %d died (%s). restarting...'</span></span>,\n    worker.process.pid, signal || code);\n  cluster.fork();\n});</code></pre><p>参见<a rel=\"nofollow\" href=\"https://nodejs.org/api/child_process.html#child_process_event_exit\" target=\"_blank\">child_process event: 'exit'</a>.</p><h2 class=\"head2\">事件: 'setup'</h2><ul><li><code>settings</code>{Object}</li></ul><p>调用<code>.setupMaster()</code>后会被触发。</p><p><code>settings</code>对象就是<code>cluster.settings</code>对象。</p><p>详细内容参见<code>cluster.settings</code>。</p><h2 class=\"head2\">cluster.setupMaster([settings])</h2><ul><li><code>settings</code> {Object}<ul><li><code>exec</code> {String} 执行文件的路径。  (默认=<code>process.argv[1]</code>)</li><li><code>args</code> {Array}传给工作进程的参数列表(默认=<code>process.argv.slice(2)</code>)</li><li><code>silent</code> {Boolean} 是否将输出发送给父进程的stdio.</li></ul></li></ul><p><code>setupMaster</code>用来改变默认的'fork' 。 一旦调用，settings值将会出现在<code>cluster.settings</code>里。</p><p>你需要注意如下事项:</p><ul><li>改变任何设置，仅会对未来的工作进程产生影响，不会影响对目前已经运行的进程</li><li>工作进程里，仅能改变传递给<code>.fork()</code>的<code>env</code>属性。  </li><li>以上的默认值，仅在第一次调用的时候有效，之后的默认值是调用<code>cluster.setupMaster()</code>后的值。 </li></ul><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> cluster = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'cluster'</span></span>);\ncluster.setupMaster({\n  exec: <span class=\"hljs-string\"><span class=\"hljs-string\">'worker.js'</span></span>,\n  args: [<span class=\"hljs-string\"><span class=\"hljs-string\">'--use'</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'https'</span></span>],\n  silent: <span class=\"hljs-literal\"><span class=\"hljs-literal\">true</span></span>\n});\ncluster.fork(); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// https worker</span></span>\ncluster.setupMaster({\n  args: [<span class=\"hljs-string\"><span class=\"hljs-string\">'--use'</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>]\n});\ncluster.fork(); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// http worker</span></span></code></pre><p>仅能在主进程里调用。</p><h2 class=\"head2\">cluster.fork([env])</h2><ul><li><code>env</code>{Object} 添加到子进程环境变量中的键值。</li><li>return {Worker object}</li></ul><p>派生一个新的工作进程。</p><p>仅能在主进程里调用。</p><h2 class=\"head2\">cluster.disconnect([callback])</h2><ul><li><code>callback</code> {Function} 当所有工作进程都断开连接，并且关闭句柄后被调用。</li></ul><p><code>cluster.workers</code>里的每个工作进程可调用<code>.disconnect()</code>关闭。</p><p>关闭所有的内部句柄连接，并且没有任何等待处理的事件时，允许主进程优雅的退出。</p><p>这个方法有一个可选参数，会在完成时被调用。</p><p>仅能在主进程里调用。</p><h2 class=\"head2\">cluster.worker</h2><ul><li>{Object}</li></ul><p>对当前工作进程对象的引用。主进程中不可用。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> cluster = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'cluster'</span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isMaster) {\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'I am master'</span></span>);\n  cluster.fork();\n  cluster.fork();\n} <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isWorker) {\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'I am worker #'</span></span> + cluster.worker.id);\n}</code></pre><h2 class=\"head2\">cluster.workers</h2><ul><li>{Object}</li></ul><p>存储活跃工作对象的哈希表，主键是<code>id</code>，能方便的遍历所有工作进程，仅在主进程可用。</p><p>当工作进程关闭连接并退出后，将会从cluster.workers里移除。这两个事件的次序无法确定，仅能保证从cluster.workers移除会发生在<code>'disconnect'</code>或<code>'exit'</code>之后。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Go through all workers</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">eachWorker</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">callback</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> id <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">in</span></span> cluster.workers) {\n    callback(cluster.workers[id]);\n  }\n}\neachWorker(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker</span></span></span><span class=\"hljs-function\">) </span></span>{\n  worker.send(<span class=\"hljs-string\"><span class=\"hljs-string\">'big announcement to all workers'</span></span>);\n});</code></pre><p>如果希望通过通讯通道引用工作进程，那么使用工作进程的 id 来查询最简单。</p><pre><code class=\"hljs javascript\">socket.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">id</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> worker = cluster.workers[id];\n});</code></pre><h2 class=\"head2\">Class: Worker</h2><p>一个Worker对象包含工作进程所有公开的信息和方法。在主进程里可用通过<code>cluster.workers</code>来获取，在工作进程里可以通过<code>cluster.worker</code>来获取。</p><h3>worker.id</h3><ul><li>{String}</li></ul><p>每一个新的工作进程都有独立的唯一标示，它就是<code>id</code>。</p><p>当工作进程可用时，<code>id</code>就是cluster.workers里的主键。 </p><h3>worker.process</h3><ul><li>{ChildProcess object}</li></ul><p>所有工作进程都是通用child_process.fork()创建的，该函数返回的对象被储存在process中。  </p><p>参见: <a href=\"d7c21itn.html\" target=\"_blank\">Child Process module</a></p><p>注意：当<code>process</code>和<code>.suicide</code>不是<code>true</code>的时候，会触发<code>'disconnect'</code>事件，并使得工作进程调用<code>process.exit(0)</code>。它会保护意外的连接关闭。</p><h3>worker.suicide</h3><ul><li>{Boolean}</li></ul><p>调用<code>.kill()</code>或<code>.disconnect()</code>后设置，在这之前是<code>undefined</code>。</p><p><code>worker.suicide</code>能让你区分出是自愿的还是意外退出，主进程可以根据这个值，来决定是否是重新派生成工作进程。</p><pre><code class=\"hljs javascript\">cluster.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'exit'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">worker, code, signal</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (worker.suicide === <span class=\"hljs-literal\"><span class=\"hljs-literal\">true</span></span>) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'Oh, it was just suicide\\' – no need to worry'</span></span>).\n  }\n});\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// kill worker</span></span>\nworker.kill();</code></pre><h3>worker.send(message[, sendHandle])</h3><ul><li><code>message</code> {Object}</li><li><code>sendHandle</code> {Handle object}</li></ul><p>这个函数和child_process.fork()提供的send方法相同。主进程里你必须使用这个函数给指定工作进程发消息。 </p><p>在工作进程里，你也可以用<code>process.send(message)</code>。</p><p>这个例子会回应所有来自主进程的消息:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isMaster) {\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> worker = cluster.fork();\n  worker.send(<span class=\"hljs-string\"><span class=\"hljs-string\">'hi there'</span></span>);\n\n} <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isWorker) {\n  process.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">msg</span></span></span><span class=\"hljs-function\">) </span></span>{\n    process.send(msg);\n  });\n}</code></pre><h3>worker.kill([signal='SIGTERM'])</h3><ul><li><code>signal</code>{String}发送给工作进程的杀死信号的名称</li></ul><p>这个函数会杀死工作进程。在主进程里，它会关闭<code>worker.process</code>，一旦关闭会发送杀死信号。在工作进程里，关闭通道，退出，返回代码<code>0</code>。</p><p>会导致<code>.suicide</code>被设置。  </p><p>为了保持兼容性，这个方法的别名是<code>worker.destroy()</code>。</p><p>注意，在工作进程里有<code>process.kill()</code>，于此不同。</p><h3>worker.disconnect()</h3><p>在工作进程里，这个函数会关闭所有服务器，等待 'close' 事件，关闭IPC通道。</p><p>在主进程里，发给工作进程一个内部消息，用来调用<code>.disconnect()</code></p><p>会导致<code>.suicide</code>被设置。</p><p>注意，服务器关闭后，不再接受新的连接，但可以接受新的监听。已经存在的连接允许正常退出。当连接为空得时候，工作进程的IPC通道运行优雅的退出。</p><p>以上仅能适用于服务器的连接，客户端的连接由工作进程关闭。</p><p>注意，在工作进程里，存在<code>process.disconnect</code>，但并不是这个函数，它是disconnect。</p><p>由于长连接可能会阻塞进程关闭连接，有一个较好的办法是发消息给应用，这样应用会想办法关闭它们。超时管理也是不错，如果超过一定时间后还没有触发 <code>disconnect</code>事件，将会杀死进程。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isMaster) {\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> worker = cluster.fork();\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> timeout;\n\n  worker.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'listening'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">address</span></span></span><span class=\"hljs-function\">) </span></span>{\n    worker.send(<span class=\"hljs-string\"><span class=\"hljs-string\">'shutdown'</span></span>);\n    worker.disconnect();\n    timeout = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n      worker.kill();\n    }, <span class=\"hljs-number\"><span class=\"hljs-number\">2000</span></span>);\n  });\n\n  worker.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'disconnect'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n    clearTimeout(timeout);\n  });\n\n} <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isWorker) {\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> net = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'net'</span></span>);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> server = net.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">socket</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// connections never end</span></span>\n  });\n\n  server.listen(<span class=\"hljs-number\"><span class=\"hljs-number\">8000</span></span>);\n\n  process.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">msg</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span>(msg === <span class=\"hljs-string\"><span class=\"hljs-string\">'shutdown'</span></span>) {\n      <span class=\"hljs-comment\"><span class=\"hljs-comment\">// initiate graceful close of any connections to server</span></span>\n    }\n  });\n}</code></pre><h3>worker.isDead()</h3><p>工作进程结束，返回<code>true</code>， 否则返回<code>false</code>。</p><h3>worker.isConnected()</h3><p>当工作进程通过IPC通道连接主进程时，返回<code>true</code> ，否则<code>false</code>。工作进程创建后会连接到主进程。当<code>disconnect</code>事件触发后会关闭连接。</p><h3>事件: 'message'</h3><ul><li><code>message</code>{Object}</li></ul><p>该事件和<code>child_process.fork()</code>所提供的一样。在主进程中您应当使用该事件，而在工作进程中您也可以使用<code>process.on('message')</code>。</p><p>例如，有一个集群使用消息系统在主进程中统计请求的数量:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> cluster = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'cluster'</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> http = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (cluster.isMaster) {\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Keep track of http requests</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> numReqs = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>;\n  setInterval(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"numReqs =\"</span></span>, numReqs);\n  }, <span class=\"hljs-number\"><span class=\"hljs-number\">1000</span></span>);\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Count requestes</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">messageHandler</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">msg</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span> (msg.cmd &amp;&amp; msg.cmd == <span class=\"hljs-string\"><span class=\"hljs-string\">'notifyRequest'</span></span>) {\n      numReqs += <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>;\n    }\n  }\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Start workers and listen for messages containing notifyRequest</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> numCPUs = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'os'</span></span>).cpus().length;\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">Object</span></span>.keys(cluster.workers).forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">id</span></span></span><span class=\"hljs-function\">) </span></span>{\n    cluster.workers[id].on(<span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span>, messageHandler);\n  });\n\n} <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> {\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Worker processes have a http server.</span></span>\n  http.Server(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, res</span></span></span><span class=\"hljs-function\">) </span></span>{\n    res.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>);\n    res.end(<span class=\"hljs-string\"><span class=\"hljs-string\">\"hello world\\n\"</span></span>);\n\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// notify master about the request</span></span>\n    process.send({ cmd: <span class=\"hljs-string\"><span class=\"hljs-string\">'notifyRequest'</span></span> });\n  }).listen(<span class=\"hljs-number\"><span class=\"hljs-number\">8000</span></span>);\n}</code></pre><h3>事件: 'online'</h3><p>和<code>cluster.on('online')</code>事件类似, 仅能在特定工作进程里触发。</p><pre><code class=\"hljs javascript\">cluster.fork().on(<span class=\"hljs-string\"><span class=\"hljs-string\">'online'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Worker is online</span></span>\n});</code></pre><p>不会在工作进程里触发。</p><h3>事件: 'listening'</h3><ul><li><code>address</code>{Object}</li></ul><p>和<code>cluster.on('listening')</code>事件类似, 仅能在特定工作进程里触发。</p><pre><code class=\"hljs javascript\">cluster.fork().on(<span class=\"hljs-string\"><span class=\"hljs-string\">'listening'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">address</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Worker is listening</span></span>\n});</code></pre><p>不会在工作进程里触发。</p><h3>事件: 'disconnect'</h3><p>和<code>cluster.on('disconnect')</code>事件类似, 仅能在特定工作进程里触发。</p><pre><code class=\"hljs javascript\">cluster.fork().on(<span class=\"hljs-string\"><span class=\"hljs-string\">'disconnect'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Worker has disconnected</span></span>\n});</code></pre><h3>事件: 'exit'</h3><ul><li><code>code</code> {Number} 正常退出时的退出代码.</li><li><code>signal</code> {String}  使得进程被终止的信号的名称（比如<code>SIGHUP</code>）。</li></ul><p>和<code>cluster.on('exit')</code>事件类似, 仅能在特定工作进程里触发。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> worker = cluster.fork();\nworker.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'exit'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">code, signal</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span>( signal ) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"worker was killed by signal: \"</span></span>+signal);\n  } <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span>( code !== <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> ) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"worker exited with error code: \"</span></span>+code);\n  } <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span> {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"worker success!\"</span></span>);\n  }\n});</code></pre><h3>事件: 'error'</h3><p>和<code>child_process.fork()</code>事件类似。</p><p>工作进程里，你也可以用<code>process.on('error')</code>。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 14,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "d51842d23e9e7b0ea04f1e2ddd2d354a",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js HTTP",
      "chapter_level_two_url": "/nodejs/1v9k1itp.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>HTTP</h2><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>如果要在Node.js中使用HTTP服务器或客户端功能，则必须调用<code>require('http')</code>。</p><p>Node里的HTTP接口支持协议里原本比较难用的特性。特别是很大的或块编码的消息。这些接口不会完全缓存整个请求或响应，这样用户可以在请求或响应中使用数据流。</p><p>HTTP消息头对象和下面的例子类似：  </p><pre><code class=\"hljs javascript\">{ <span class=\"hljs-string\"><span class=\"hljs-string\">'content-length'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'123'</span></span>,\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'content-type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span>,\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'connection'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'keep-alive'</span></span>,\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'host'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'mysite.com'</span></span>,\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'accept'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'*/*'</span></span> }</code></pre><p>Keys都是小写，值不能修改。</p><p>为了能支持尽可能多的HTTP应用程序，Node提供的HTTP API接口都是底层的。仅能处理流和消息。它把消息解析成报文头和报文体，但是不解析实际的报文头和报文体内容。</p><p>定义报文头的时候，多个值间可用<code>,</code>分隔。除了<code>set-cookie</code>和<code>cookie</code>头，因为它们表示值的数组。诸如<code>content-length</code>的只有一个值的报文头，直接解析，并且只有单值可以表示成已经解析好的对象。</p><p>接收到的原始头信息以数组（<code>[key, value, key2, value2, ...]</code>）的形式保存在<code>rawHeaders</code>里。例如，之前提到的消息对象会有如下的<code>rawHeaders</code>：</p><pre><code class=\"hljs json\">[ 'ConTent-Length', '<span class=\"hljs-number\"><span class=\"hljs-number\">123456</span></span>',\n  'content-LENGTH', '<span class=\"hljs-number\"><span class=\"hljs-number\">123</span></span>',\n  'content-type', 'text/plain',\n  'CONNECTION', 'keep-alive',\n  'Host', 'mysite.com',\n  'accepT', '*/*' ]</code></pre><h2 class=\"head2\">http.METHODS</h2><ul><li>{Array}</li></ul><p>解析器支持的HTTP方法列表。</p><h2 class=\"head2\">http.STATUS_CODES</h2><ul><li>{Object}</li></ul><p>全部标准HTTP响应状态码的和描述的集合。例如，<code>http.STATUS_CODES[404] === 'Not Found'</code>。</p><h2 class=\"head2\">http.createServer([requestListener])</h2><p>返回<a href=\"#http_class_http_server\">http.Server</a>的新实例。</p><p><code>requestListener</code>函数自动加到<code>'request'</code>事件里。</p><h2 class=\"head2\">http.createClient([port][, host])</h2><p>这个函数已经被抛弃，用<a href=\"#http_http_request_options_callback\">http.request()</a>替换。创建一个新的HTTP客户端，连接到服务器的<code>port</code>和<code>host</code>。</p><h2 class=\"head2\">类： http.Server</h2><p>这是事件分发器<a href=\"aue11itf.html\" target=\"_blank\">EventEmitter</a>，有以下事件：</p><h3>事件： 'request'</h3><p><code>function (request, response) { }</code></p><p>每当有请求的时候触发。注意：每个连接可以有多个请求（在keep-alive连接中）。<code>request</code>是<a href=\"#http_http_incomingmessage\">http.IncomingMessage</a>实例，<code>response</code>是<a href=\"#http_class_http_serverresponse\">http.ServerResponse</a> 的实例。</p><h3>事件： 'connection'</h3><p><code>function (socket) { }</code></p><p>当建立新的TCP流的时候。<code>socket</code>是一个<code>net.Socket</code>对象。通常用户不会访问这个事件。协议解析器绑定套接字时采用的方式使套接字不会出发readable事件。也能通过<code>request.connection</code>访问<code>socket</code>。</p><h3>事件： 'close'</h3><p><code>function () { }</code></p><p>服务器关闭的时候触发。</p><h3>事件： 'checkContinue'</h3><p><code>function (request, response) { }</code></p><p>当http收到100-continue的http请求时会触发。如果没有监听这个事件，服务器将会自动发送100 Continue的响应。</p><p>如果客户端需要继续发送请求主题，或者生成合适的HTTP响应（如，400请求无效），可以通过调用<a href=\"#http_response_writecontinue\">response.writeContinue()</a>来处理。</p><p>注意：触发并处理这个事件的时候，不会再触发<code>request</code>事件。 </p><h3>事件： 'connect'</h3><p><code>function (request, socket, head) { }</code></p><p>当客户端请求http连接时触发。如果没有监听这个事件，客户端请求连接的时候会被关闭。</p><ul><li><code>request</code>是http请求的参数，与request事件参数相同。</li><li><code>socket</code>是服务器和客户端间的socket。</li><li><code>head</code>是buffer的实例。网络隧道的第一个包，可能为空。</li></ul><p>这个事件触发后，请求的socket不会有<code>data</code>事件监听器，也就是说你需要绑定一个监听器到<code>data</code>上，来处理在发送到服务器上的socket数据。</p><h3>事件： 'upgrade'</h3><p><code>function (request, socket, head) { }</code></p><p>当客户端请求http upgrage时候会触发。如果没有监听这个事件，客户端请求一个连接的时候会被关闭。</p><ul><li><code>request</code>是http请求的参数，与request事件参数相同。</li><li><code>socket</code>是服务器和客户端间的socket。</li><li><code>head</code>是buffer的实例。网络隧道的第一个包，可能为空。</li></ul><p>这个事件触发后，请求的socket不会有<code>data</code>事件监听器，也就是说你需要绑定一个监听器到<code>data</code>上，来处理在发送到服务器上的socket数据。</p><h3>事件： 'clientError'</h3><p><code>function (exception, socket) { }</code></p><p>如果一个客户端连接触发了一个'error'事件，它就会转发到这里.</p><p><code>socket</code>是导致错误的<code>net.Socket</code>对象。</p><p><a name=\"http_server_listen_port_hostname_backlog_callback\"></a></p><h3>server.listen(port[, hostname][, backlog][, callback])</h3><p>在指定的的端口和主机名上开始接收连接。如果忽略主机名，服务器将会接收指向任意的IPv4地址(<code>INADDR_ANY</code>)。</p><p>监听一个unix socket，需要提供一个文件名而不是主机名和端口。</p><p>积压量backlog为等待连接队列的最大长度。实际的长度由你的操作系统的sysctl设置决定（比如linux上的<code>tcp_max_syn_backlog</code>和<code>somaxconn</code>）。默认参数值为 511 (不是512)</p><p>这是异步函数。最后一个参数<code>callback</code>会作为事件监听器添加到<code>listening</code>事件。参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.listen(port)</a>。</p><h3>server.listen(path[, callback])</h3><p>启动一个UNIX socket服务器所给路径<code>path</code>   </p><p>这是异步函数。最后一个参数<code>callback</code>会作为事件监听器添加到<code>listening</code>事件。参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.listen(port)</a>。</p><h3>server.listen(handle[, callback])</h3><ul><li><code>handle</code> {Object}</li><li><p><code>callback</code> {Function}</p><p><code>handle</code> 对象可以是server或socket（任意以下划线<code>_handle</code>开头的成员），或者<code>{fd: &lt;n&gt;}</code>对象。</p></li></ul><p>这会导致server用参数<code>handle</code>接收连接，前提条件是文件描述符或句柄已经连接到端口或域socket。</p><p>Windows不能监听文件句柄。  </p><p>这是异步函数。最后一个参数<code>callback</code>会作为事件监听器添加到<code>listening</code>事件。参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.listen(port)</a>。</p><p><a name=\"http_server_close_callback\"></a></p><h3>server.close([callback])</h3><p>用于禁止server接收连接。参见<a href=\"sbua1itx.html\" target=\"_blank\">net.Server.close()</a>.</p><h3>server.maxHeadersCount</h3><p>最大请求头的数量限制，默认为1000。如果设置为0，则不做任何限制。</p><p><a name=\"http_server_settimeout_msecs_callback\"></a></p><h3>server.setTimeout(msecs, callback)</h3><ul><li><code>msecs</code>{Number}</li><li><code>callback</code>{Function}</li></ul><p>为socket设置超时时间，单位为毫秒，如果发生超时，在server对象上触发<code>'timeout'</code>事件，参数为socket。</p><p>如果在Server对象上有一个<code>'timeout'</code>事件监听器，超时的时候，将会调用它，参数为socket。</p><p>默认情况下，Server的超时为2分钟，如果超时将会销毁socket。如果你给Server的超时事件设置了回调函数，那你就得负责处理socket超时。</p><p><a name=\"http_server_timeout\"></a></p><h3>server.timeout</h3><ul><li>{Number} Default = 120000 (2 minutes)</li></ul><p>超时的时长，单位为毫秒。</p><p>注意，socket的超时逻辑在连接时设定，所以有新的连接时才能改变这个值。</p><p>设为0时，建立连接的自动超时将失效。</p><h2 class=\"head2\">类： http.ServerResponse</h2><p>这是一个由HTTP服务器（而不是用户）内部创建的对象。作为第二个参数传递给<code>'request'</code>事件。</p><p>该响应实现了<a href=\"ocq11itw.html\" target=\"_blank\">Writable Stream</a>接口。这是一个包含下列事件的<a href=\"aue11itf.html\" target=\"_blank\">EventEmitter</a> ：</p><h3>事件： 'close'</h3><p><code>function () { }</code></p><p>在调用<a href=\"#http_response_end_data_encoding\">response.end()</a>，或准备flush前，底层连接结束。</p><h3>事件： 'finish'</h3><p><code>function () { }</code></p><p>发送完响应触发。响应头和响应体最后一段数据被剥离给操作系统后，通过网络来传输时被触发。这并不代表客户端已经收到数据。</p><p>这个事件之后，响应对象不会再触发任何事件。</p><h3>response.writeContinue()</h3><p>发送HTTP/1.1 100 Continue消息给客户端，表示请求体可以发送。可以在服务器上查看<a href=\"#http_event_checkcontinue\">'checkContinue'</a>事件。</p><h3>response.writeHead(statusCode[, statusMessage][, headers])</h3><p>发送一个响应头给请求。状态码是3位数字，如<code>404</code>。最后一个参数<code>headers</code>是响应头。建议第二个参数设置为可以看的懂的消息。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> body = <span class=\"hljs-string\"><span class=\"hljs-string\">'hello world'</span></span>;\nresponse.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>, {\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Length'</span></span>: body.length,\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span> });</code></pre><p>这个方法仅能在消息中调用一次，而且必须在<a href=\"#http_response_end_data_encoding\">response.end()</a>前调用。</p><p>如果你在这之前调用<a href=\"#http_response_write_chunk_encoding\">response.write()</a>或<a href=\"#http_response_end_data_encoding\">response.end()</a>，将会计算出不稳定的头。</p><p>Content-Length是字节数，而不是字符数。上面的例子<code>'hello world'</code>仅包含一个字节字符。如果body包含高级编码的字符，则<code>Buffer.byteLength()</code>就必须确定指定编码的字符数。Node不会检查Content-Length和body的长度是否相同。</p><h3>response.setTimeout(msecs, callback)</h3><ul><li><code>msecs</code> {Number}</li><li><code>callback</code> {Function}</li></ul><p>设置socket超时时间，单位为毫秒。如果提供了回调函数，将会在response对象的<code>'timeout'</code>事件上添加监听器。  </p><p>如果没有给请求、响应、服务器添加<code>'timeout'</code>监视器，超时的时候将会销毁socket。如果你给请求、响应、服务器加了处理函数，就需要负责处理socket超时。</p><h3>response.statusCode</h3><p>使用默认的headers 时（没有显式的调用<a href=\"#http_response_writehead_statuscode_reasonphrase_headers\">response.writeHead()</a>），这个属性表示将要发送给客户端状态码。</p><p>例如:</p><pre><code class=\"hljs\">response.statusCode = 404;</code></pre><p>响应头发送给客户端的后，这个属性表示状态码已经发送。</p><h3>response.statusMessage</h3><p>使用默认headers时（没有显式的调用<a href=\"#http_response_writehead_statuscode_reasonphrase_headers\">response.writeHead()</a>），这个属性表示将要发送给客户端状态信息。如果这个没有定义，将会使用状态码的标准消息。</p><p>例如:</p><pre><code class=\"hljs javascript\">response.statusMessage = <span class=\"hljs-string\"><span class=\"hljs-string\">'Not found'</span></span>;</code></pre><p>当响应头发送给客户端的时候，这个属性表示状态消息已经发送。</p><h3>response.setHeader(name, value)</h3><p>设置默认头某个字段内容。如果这个头即将被发送，内容会被替换。如果你想设置更多的头， 就使用一个相同名字的字符串数组。</p><p>例如:</p><pre><code class=\"hljs javascript\">response.setHeader(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Content-Type\"</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">\"text/html\"</span></span>);</code></pre><p>或</p><pre><code class=\"hljs sql\">response.setHeader(\"<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">Set</span></span>-Cookie<span class=\"hljs-string\"><span class=\"hljs-string\">\", [\"</span></span><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">type</span></span>=ninja<span class=\"hljs-string\"><span class=\"hljs-string\">\", \"</span></span><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">language</span></span>=javascript<span class=\"hljs-string\"><span class=\"hljs-string\">\"]);</span></span></code></pre><h3>response.headersSent</h3><p>Boolean(只读)。如果headers发送完毕，则为true，反之为false。</p><h3>response.sendDate</h3><p>默认值为true。若为true，当headers里没有Date值时，自动生成Date并发送。</p><p>只有在测试环境才能禁用，因为HTTP要求响应包含Date头.</p><h3>response.getHeader(name)</h3><p>读取一个在队列中但是还没有被发送至客户端的header。名字是大小写敏感的。仅能再头被flushed前调用。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> contentType = response.getHeader(<span class=\"hljs-string\"><span class=\"hljs-string\">'content-type'</span></span>);</code></pre><h3>response.removeHeader(name)</h3><p>从即将发送的队列里移除头。</p><p>例如:</p><pre><code class=\"hljs javascript\">response.removeHeader(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Content-Encoding\"</span></span>);</code></pre><h3>response.write(chunk[, encoding][, callback])</h3><p>如果调用了这个方法，且还没有调用<a href=\"#http_response_writehead_statuscode_reasonphrase_headers\">response.writeHead()</a>，将会切换到默认的header，并更新这个header。</p><p>这个方法将发送响应体数据块。可能会多次调用这个方法，以提供body成功的部分内容。</p><p><code>chunk</code>可以是字符串或 buffer。如果<code>chunk</code> 是字符串，第二个参数表明如何将它编码成字节流。<code>encoding</code>的默认值是<code>'utf8'</code>。最后一个参数在刷新这个数据块时调用。</p><p>注意：这个是原始的HTTP body，和高级的multi-part body编码无关。</p><p>第一次调用<code>response.write()</code>的时候，将会发送缓存的头信息和第一个body给客户端。第二次，将会调用<code>response.write()</code>。Node认为你将会独立发送流数据。这意味着，响应缓存在第一个数据块中。</p><p>如果成功的刷新全部数据到内核缓冲区，返回<code>true</code> 。如果部分或全部数据在用户内存中还处于排队状况，返回<code>false</code>。当缓存再次释放的时候，将会触发 <code>'drain'</code>。</p><h3>response.addTrailers(headers)</h3><p>这个方法给响应添加HTTP的尾部header（消息末尾的header）。</p><p><strong>只有</strong>数据块编码用于响应体时，才会触发Trailers；如果不是（例如，请求是HTTP/1.0），它们将会被自动丢弃。</p><p>如果你想触发trailers， HTTP会要求发送<code>Trailer</code>头，它包含一些信息，比如：</p><pre><code class=\"hljs ruby\">response.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>, { <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span>,\n                          <span class=\"hljs-string\"><span class=\"hljs-string\">'Trailer'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-MD5'</span></span> });\nresponse.write(fileData);\nresponse.addTrailers({<span class=\"hljs-string\"><span class=\"hljs-string\">'Content-MD5'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">\"7895bf4b8828b55ceaf47747b4bca667\"</span></span>});\nresponse.<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">end</span></span>();</code></pre><h3>response.end([data][, encoding][, callback])</h3><p>这个方法告诉服务器，所有的响应头和响应体已经发送；服务器可以认为消息结束。<code>response.end()</code>方法必须在每个响应中调用。</p><p>如果指定了参数<code>data</code>，将会在响应流结束的时候调用。</p><p><a name=\"http_http_request_options_callback\"></a></p><h2 class=\"head2\">http.request(options[, callback])</h2><p>Node维护每个服务器的连接来生成HTTP请求。这个函数让你可以发布请求。</p><p>参数<code>options</code>是对象或字符串。如果<code>options</code>是字符串，会通过<a href=\"eq9c1iu9.html\" target=\"_blank\">url.parse()</a>自动解析。</p><p><code>options</code>值:</p><ul><li><code>host</code>: 请求的服务器域名或 IP 地址，默认：<code>'localhost'</code></li><li><code>hostname</code>: 用于支持<code>url.parse()</code>。<code>hostname</code>优于<code>host</code></li><li><code>port</code>: 远程服务器端口。 默认为：80.</li><li><code>localAddress</code>: 用于绑定网络连接的本地接口</li><li><code>socketPath</code>: Unix域socket（使用host:port或socketPath）</li><li><code>method</code>: 指定 HTTP 请求方法。 默认： <code>'GET'</code>.</li><li><code>path</code>: 请求路径。 默认为：<code>'/'</code>。如果有查询字符串，则需要包含。例如，'/index.html?page=12'。请求路径包含非法字符时抛出异常。目前，只有空格不行，不过在未来可能改变。</li><li><code>headers</code>: 包含请求头的对象</li><li><code>auth</code>: 用于计算认证头的基本认证，即<code>user:password</code></li><li><code>agent</code>: 控制Agent的行为。当使用了一个Agent的时候，请求将默认为<code>Connection: keep-alive</code>。可能的值为：<ul><li><code>undefined</code> (default): 在这个主机和端口上使用<a href=\"#http_http_globalagent\">global Agent</a></li><li><code>Agent</code> object: 在<code>Agent</code>中显式使用passed .</li><li><code>false</code>: 选择性停用连接池,默认请求为：<code>Connection: close</code>.</li><li><code>keepAlive</code>: {Boolean} 持资源池周围的socket，用于未来其它请求。默认值为<code>false</code>。</li><li><code>keepAliveMsecs</code>: {Integer} 使用HTTP KeepAlive的时候，通过正在保持活动的sockets发送TCP KeepAlive包的频繁程度。默认值为1000。仅当keepAlive为true时才相关。  </li></ul></li></ul><p>可选参数<code>callback</code>将会作为一次性的监视器，添加给 <a href=\"#http_event_response\">'response'</a> 事件。</p><p>http.request()返回一个http.ClientRequest类的实例。ClientRequest实例是一个可写流对象。如果需要用POST请求上传一个文件的话，就将其写入到ClientRequest对象。</p><p>例如：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> postData = querystring.stringify({\n  <span class=\"hljs-string\"><span class=\"hljs-string\">'msg'</span></span> : <span class=\"hljs-string\"><span class=\"hljs-string\">'Hello World!'</span></span>\n});\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> options = {\n  hostname: <span class=\"hljs-string\"><span class=\"hljs-string\">'www.google.com'</span></span>,\n  port: <span class=\"hljs-number\"><span class=\"hljs-number\">80</span></span>,\n  path: <span class=\"hljs-string\"><span class=\"hljs-string\">'/upload'</span></span>,\n  method: <span class=\"hljs-string\"><span class=\"hljs-string\">'POST'</span></span>,\n  headers: {\n    <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'application/x-www-form-urlencoded'</span></span>,\n    <span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Length'</span></span>: postData.length\n  }\n};\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> req = http.request(options, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'STATUS: '</span></span> + res.statusCode);\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'HEADERS: '</span></span> + <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">JSON</span></span>.stringify(res.headers));\n  res.setEncoding(<span class=\"hljs-string\"><span class=\"hljs-string\">'utf8'</span></span>);\n  res.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">chunk</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'BODY: '</span></span> + chunk);\n  });\n});\n\nreq.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'error'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">e</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'problem with request: '</span></span> + e.message);\n});\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// write data to request body</span></span>\nreq.write(postData);\nreq.end();</code></pre><p>注意，例子里调用了<code>req.end()</code>。<code>http.request()</code>必须调用<code>req.end()</code>来表明请求已经完成，即使没有数据写入到请求body里。</p><p>如果在请求的时候遇到错误（DNS解析、TCP级别的错误或实际HTTP解析错误），在返回的请求对象时会触发一个'error'事件。</p><p>有一些特殊的头需要注意：</p><ul><li><p>发送<code>Connection: keep-alive</code>告诉服务器保持连接，直到下一个请求到来。</p></li><li><p>发送<code>Content-length</code>头将会禁用chunked编码。</p></li><li><p>发送一个<code>Expect</code>头，会立即发送请求头，一般来说，发送<code>Expect: 100-continue</code>，你必须设置超时，并监听<code>continue</code>事件。更多细节参见RFC2616 Section 8.2.3。</p></li><li>发送一个授权头，将会使用<code>auth</code>参数重写，来计算基本的授权。</li></ul><h2 class=\"head2\">http.get(options[, callback])</h2><p>因为多数请求是没有报文体的GET请求，Node提供了这个简便的方法。和<code>http.request()</code>唯一不同点在于，这个方法自动设置GET，并自动调用<code>req.end()</code>。</p><p>例如：</p><pre><code class=\"hljs javascript\">http.get(<span class=\"hljs-string\"><span class=\"hljs-string\">\"http://www.google.com/index.html\"</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Got response: \"</span></span> + res.statusCode);\n}).on(<span class=\"hljs-string\"><span class=\"hljs-string\">'error'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">e</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">\"Got error: \"</span></span> + e.message);\n});</code></pre><p><a name=\"http_class_http_agent\"></a></p><h2 class=\"head2\">类： http.Agent</h2><p>HTTP Agent用于socket池，用于HTTP客户端请求。</p><p>HTTP Agent也把客户端请求默认为使用Connection:keep-alive 。如果没有HTTP请求正在等着成为空闲socket的话，那么socket将关闭。这意味着，Node的资源池在负载的情况下对keep-alive有利，但是仍然不需要开发人员使用KeepAlive来手动关闭HTTP客户端。</p><p>如果你选择使用HTTP KeepAlive， 可以创建一个Agent对象，将 flag 设置为<code>true</code>.  (参见下面的<a href=\"#http_new_agent_options\">constructor options</a> ) ，这样Agent会把没用到的socket放到池里，以便将来使用。他们会被显式的标志，让Node不运行。但是，当不再使用它的时候，需要显式的调用<a href=\"#http_agent_destroy\"><code>destroy()</code></a>，这样socket将会被关闭。</p><p>当socket事件触发<code>close</code>事件或特殊的<code>agentRemove</code>事件时，socket将会从agent池里移除。如果你要保持HTTP请求保持长时间打开，并且不希望他们在池里，可以参考以下代码：</p><pre><code class=\"hljs javascript\">http.get(options, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Do stuff</span></span>\n}).on(<span class=\"hljs-string\"><span class=\"hljs-string\">\"socket\"</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">socket</span></span></span><span class=\"hljs-function\">) </span></span>{\n  socket.emit(<span class=\"hljs-string\"><span class=\"hljs-string\">\"agentRemove\"</span></span>);\n});</code></pre><p>另外，你可以使用<code>agent:false</code>让资源池停用：</p><pre><code class=\"hljs javascript\">http.get({\n  hostname: <span class=\"hljs-string\"><span class=\"hljs-string\">'localhost'</span></span>,\n  port: <span class=\"hljs-number\"><span class=\"hljs-number\">80</span></span>,\n  path: <span class=\"hljs-string\"><span class=\"hljs-string\">'/'</span></span>,\n  agent: <span class=\"hljs-literal\"><span class=\"hljs-literal\">false</span></span>  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// create a new agent just for this one request</span></span>\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// Do stuff with response</span></span>\n})</code></pre><h3>new Agent([options])</h3><ul><li><code>options</code> {Object} agent上的设置选项集合，有以下字段内容:<ul><li><code>keepAlive</code> {Boolean} 持资源池周围的socket，用于未来其它请求。默认值为<code>false</code>。</li><li><code>keepAliveMsecs</code> {Integer} 使用HTTP KeepAlive的时候，通过正在保持活动的sockets发送TCP KeepAlive包的频繁程度。默认值为1000。仅当 keepAlive为true时才相关。</li><li><code>maxSockets</code> {Number}在空闲状态下，还依然开启的socket的最大值。仅当<code>keepAlive</code>设置为true的时候有效。默认值为256。</li></ul></li></ul><p>被<code>http.request</code>使用的默认的<code>http.globalAgent</code>，会设置全部的值为默认。</p><p>必须在创建你自己的<code>Agent</code>对象后，才能配置这些值。</p><pre><code class=\"language-javascript hljs\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> http = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> keepAliveAgent = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> http.Agent({ keepAlive: <span class=\"hljs-literal\"><span class=\"hljs-literal\">true</span></span> });\noptions.agent = keepAliveAgent;\nhttp.request(options, onResponseCallback);</code></pre><h3>agent.maxSockets</h3><p>默认值为Infinity。决定了每台主机上的agent可以拥有的并发socket的打开数量，主机可以是<code>host:port</code>或<code>host:port:localAddress</code>。</p><h3>agent.maxFreeSockets</h3><p>默认值256.对于支持HTTP KeepAlive的Agent而言，这个方法设置了空闲状态下仍然打开的套接字数的最大值。 </p><h3>agent.sockets</h3><p>这个对象包含了当前Agent使用中的socket数组。不要修改它。</p><h3>agent.freeSockets</h3><p>使用HTTP KeepAlive的时候，这个对象包含等待当前Agent使用的socket数组。不要修改它。</p><h3>agent.requests</h3><p>这个对象包含了还没分配给socket的请求数组。不要修改它。</p><h3>agent.destroy()</h3><p>销毁任意一个被agent使用的socket。</p><p>通常情况下不要这么做。如果你正在使用一个允许KeepAlive的agent，当你知道不在使用它的时候，最好关闭agent。否则，socket会一直保存打开状态，直到服务器关闭。</p><h3>agent.getName(options)</h3><p>获取一组请求选项的唯一名，来确定某个连接是否可重用。在http agent里，它会返回<code>host:port:localAddress</code>。在http agent里， name包括CA，cert, ciphers, 和其他HTTPS/TLS特殊选项来决定socket是否可以重用。</p><h2 class=\"head2\">http.globalAgent</h2><p>Agent的全局实例，是http客户端的默认请求。</p><h2 class=\"head2\">类：http.ClientRequest</h2><p>该对象在内部创建并从<code>http.request()</code>返回。他是正在处理的请求，其头部已经在队列中。使用<code>setHeader(name, value)</code>,<code>getHeader(name)</code>, <code>removeHeader(name)</code>API可以改变header。当关闭连接的时候，header将会和第一个数据块一起发送。</p><p>为了获取响应，可以给请求对象的<code>'response'</code>添加监听器。当接收到响应头的时候将会从请求对象里触发<code>'response'</code>。<code>'response'</code>事件执行时有一个参数，该参数为<a href=\"#http_http_incomingmessage\">http.IncomingMessage</a>的实例。</p><p>在<code>'response'</code>事件期间，可以给响应对象添加监视器，监听<code>'data'</code>事件。</p><p>如果没有添加<code>'response'</code>处理函数，响应将被完全忽略。如果你添加了<code>'response'</code>事件处理函数，那你<strong>必须</strong>消费掉从响应对象获取的数据，可以在 <code>'readable'</code>事件里调用<code>response.read()</code>，或者添加一个<code>'data'</code>处理函数，或者调用<code>.resume()</code>方法。如果未读取数据，它将会消耗内存，最终产生 <code>process out of memory</code>错误。</p><p>Node不会检查Content-Length和body的长度是否相同。</p><p>该请求实现了<a href=\"ocq11itw.html\" target=\"_blank\">Writable Stream</a>接口。这是一个包含下列事件的<a href=\"aue11itf.html\" target=\"_blank\">EventEmitter</a>。</p><h3>事件： 'response'</h3><p><code>function (response) { }</code></p><p>当接收到请求的时候会触发，仅会触发一次。<code>response</code>的参数是<a href=\"#http_http_incomingmessage\">http.IncomingMessage</a>的实例。</p><p>Options:</p><ul><li><code>host</code>: 要请求的服务器域名或IP地址</li><li><code>port</code>: 远程服务器的端口</li><li><code>socketPath</code>: Unix域Socket (使用host:port或socketPath之一)</li></ul><h3>事件： 'socket'</h3><p><code>function (socket) { }</code></p><p>Socket附加到这个请求的时候触发。</p><h3>事件： 'connect'</h3><p><code>function (response, socket, head) { }</code></p><p>每次服务器使用CONNECT方法响应一个请求时触发。如果这个这个事件未被监听，接收CONNECT方法的客户端将关闭他们的连接。</p><p>下面的例子展示了一对匹配的客户端/服务器如何监听<code>connect</code>事件。var http = require('http');var net = require('net');var url = require('url');</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Create an HTTP tunneling proxy</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> proxy = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  res.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>, {<span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span>});\n  res.end(<span class=\"hljs-string\"><span class=\"hljs-string\">'okay'</span></span>);\n});\nproxy.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'connect'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, cltSocket, head</span></span></span><span class=\"hljs-function\">) </span></span>{\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// connect to an origin server</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> srvUrl = url.parse(<span class=\"hljs-string\"><span class=\"hljs-string\">'http://'</span></span> + req.url);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> srvSocket = net.connect(srvUrl.port, srvUrl.hostname, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n    cltSocket.write(<span class=\"hljs-string\"><span class=\"hljs-string\">'HTTP/1.1 200 Connection Established\\r\\n'</span></span> +\n                    <span class=\"hljs-string\"><span class=\"hljs-string\">'Proxy-agent: Node-Proxy\\r\\n'</span></span> +\n                    <span class=\"hljs-string\"><span class=\"hljs-string\">'\\r\\n'</span></span>);\n    srvSocket.write(head);\n    srvSocket.pipe(cltSocket);\n    cltSocket.pipe(srvSocket);\n  });\n});\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// now that proxy is running</span></span>\nproxy.listen(<span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'127.0.0.1'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// make a request to a tunneling proxy</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> options = {\n    port: <span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span>,\n    hostname: <span class=\"hljs-string\"><span class=\"hljs-string\">'127.0.0.1'</span></span>,\n    method: <span class=\"hljs-string\"><span class=\"hljs-string\">'CONNECT'</span></span>,\n    path: <span class=\"hljs-string\"><span class=\"hljs-string\">'www.google.com:80'</span></span>\n  };\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> req = http.request(options);\n  req.end();\n\n  req.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'connect'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res, socket, head</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'got connected!'</span></span>);\n\n    <span class=\"hljs-comment\"><span class=\"hljs-comment\">// make a request over an HTTP tunnel</span></span>\n    socket.write(<span class=\"hljs-string\"><span class=\"hljs-string\">'GET / HTTP/1.1\\r\\n'</span></span> +\n                 <span class=\"hljs-string\"><span class=\"hljs-string\">'Host: www.google.com:80\\r\\n'</span></span> +\n                 <span class=\"hljs-string\"><span class=\"hljs-string\">'Connection: close\\r\\n'</span></span> +\n                 <span class=\"hljs-string\"><span class=\"hljs-string\">'\\r\\n'</span></span>);\n    socket.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">chunk</span></span></span><span class=\"hljs-function\">) </span></span>{\n      <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(chunk.toString());\n    });\n    socket.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'end'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n      proxy.close();\n    });\n  });\n});</code></pre><h3>事件： 'upgrade'</h3><p><code>function (response, socket, head) { }</code></p><p>每当服务器响应upgrade请求时触发。如果没有监听这个事件，客户端会收到upgrade头后关闭连接。</p><p>下面的例子展示了一对匹配的客户端/服务器如何监听<code>upgrade</code>事件。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> http = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// Create an HTTP server</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> srv = http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, res</span></span></span><span class=\"hljs-function\">) </span></span>{\n  res.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>, {<span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span>});\n  res.end(<span class=\"hljs-string\"><span class=\"hljs-string\">'okay'</span></span>);\n});\nsrv.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'upgrade'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">req, socket, head</span></span></span><span class=\"hljs-function\">) </span></span>{\n  socket.write(<span class=\"hljs-string\"><span class=\"hljs-string\">'HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n'</span></span> +\n               <span class=\"hljs-string\"><span class=\"hljs-string\">'Upgrade: WebSocket\\r\\n'</span></span> +\n               <span class=\"hljs-string\"><span class=\"hljs-string\">'Connection: Upgrade\\r\\n'</span></span> +\n               <span class=\"hljs-string\"><span class=\"hljs-string\">'\\r\\n'</span></span>);\n\n  socket.pipe(socket); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// echo back</span></span>\n});\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// now that server is running</span></span>\nsrv.listen(<span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">'127.0.0.1'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// make a request</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> options = {\n    port: <span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span>,\n    hostname: <span class=\"hljs-string\"><span class=\"hljs-string\">'127.0.0.1'</span></span>,\n    headers: {\n      <span class=\"hljs-string\"><span class=\"hljs-string\">'Connection'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'Upgrade'</span></span>,\n      <span class=\"hljs-string\"><span class=\"hljs-string\">'Upgrade'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'websocket'</span></span>\n    }\n  };\n\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> req = http.request(options);\n  req.end();\n\n  req.on(<span class=\"hljs-string\"><span class=\"hljs-string\">'upgrade'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">res, socket, upgradeHead</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'got upgraded!'</span></span>);\n    socket.end();\n    process.exit(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n  });\n});</code></pre><h3>事件： 'continue'</h3><p><code>function () { }</code></p><p>当服务器发送'100 Continue'  HTTP响应的时候触发，通常因为请求包含'Expect: 100-continue'。该指令表示客户端应发送请求体。</p><h3>request.flushHeaders()</h3><p>刷新请求的头。</p><p>考虑效率因素，Node.js通常会缓存请求的头直到你调用<code>request.end()</code>，或写入请求的第一个数据块。然后，包装请求的头和数据到一个独立的TCP包里。</p><h3>request.write(chunk[, encoding][, callback])</h3><p>发送一个请求体的数据块。通过多次调用这个函数，用户能流式的发送请求给服务器，这种情况下，建议使用<code>['Transfer-Encoding', 'chunked']</code>头。</p><p><code>chunk</code>参数必须是<a href=\"buffer.html#buffer_buffer\">Buffer</a>或字符串。</p><p>回调参数可选，当这个数据块被刷新的时候会被调用。</p><h3>request.end([data][, encoding][, callback])</h3><p>发送请求完毕。如果body的数据没被发送，将会将他们刷新到流里。如果请求是分块的，该方法会发送终结符0\\r\\n\\r\\n 。</p><p>如果指定了<code>data</code>，等同于先调用<code>request.write(data, encoding)</code>，再调用<code>request.end(callback)</code>。</p><p>如果有<code>callback</code>，将会在请求流结束的时候调用。</p><h3>request.abort()</h3><p>终止一个请求. (v0.3.8开始新加入)。</p><h3>request.setTimeout(timeout[, callback])</h3><p>如果socket被分配给这个请求，并完成连接，将会调用<a href=\"sbua1itx.html\" target=\"_blank\">socket.setTimeout()</a> 。</p><h3>request.setNoDelay([noDelay])</h3><p>如果socket被分配给这个请求，并完成连接，将会调用<a href=\"sbua1itx.html\" target=\"_blank\">socket.setNoDelay()</a>。</p><h3>request.setSocketKeepAlive([enable][, initialDelay])</h3><p>如果socket被分配给这个请求，并完成连接，将会调用<a href=\"sbua1itx.html\" target=\"_blank\">socket.setKeepAlive()</a>。</p><h2 class=\"head2\">http.IncomingMessage</h2><p><a href=\"#http_class_http_server\">http.Server</a>或<a href=\"#http_class_http_clientrequest\">http.ClientRequest</a>创建了<code>IncomingMessage</code>对象，作为第一个参数传递给<code>'response'</code>。它可以用来访问应答的状态，头文件和数据。</p><p>它实现了<a href=\"ocq11itw.html\" target=\"_blank\">Readable Stream</a>接口，以及以下额外的事件，方法和属性。</p><h3>事件： 'close'</h3><p><code>function () { }</code></p><p>表示底层连接已经关闭。和<code>'end'</code>类似，这个事件每个应答只会发送一次。</p><h3>message.httpVersion</h3><p>客户端向服务器发送请求时，客户端发送的 HTTP 版本；或者服务器想客户端返回应答时，服务器的HTTP版本。通常是<code>'1.1'</code>或<code>'1.0'</code>。</p><p>另外，<code>response.httpVersionMajor</code>是第一个整数，<code>response.httpVersionMinor</code>是第二个整数。</p><h3>message.headers</h3><p>请求/响应头对象。</p><p>只读的头名称和值的映射。头的名字是小写，比如：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Prints something like:</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">//</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// { 'user-agent': 'curl/7.22.0',</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">//   host: '127.0.0.1:8000',</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">//   accept: '*/*' }</span></span>\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(request.headers);</code></pre><h3>message.rawHeaders</h3><p>接收到的请求/响应头字段列表。</p><p>注意，键和值在同一个列表中。它并非一个元组列表。所以，偶数偏移量为键，奇数偏移量为对应的值。</p><p>头名字不是小写敏感，也没用合并重复的头。</p><pre><code>// Prints something like:\n//\n// [ 'user-agent',\n//   'this is invalid because there can be only one',\n//   'User-Agent',\n//   'curl/7.22.0',\n//   'Host',\n//   '127.0.0.1:8000',\n//   'ACCEPT',\n//   '*/*' ]\nconsole.log(request.rawHeaders);</code></pre><h3>message.trailers</h3><p>请求/响应的尾部对象。只在'end'事件中存在。</p><h3>message.rawTrailers</h3><p>接收到的原始的请求/响应尾部键和值。仅在'end'事件中存在。</p><h3>message.setTimeout(msecs, callback)</h3><ul><li><code>msecs</code> {Number}</li><li><code>callback</code> {Function}</li></ul><p>调用<code>message.connection.setTimeout(msecs, callback)</code>.</p><h3>message.method</h3><p><strong>仅对从<a href=\"#http_class_http_server\">http.Server</a>获得的请求有效。</strong></p><p>请求方法如果一个只读的字符串。例如：<code>'GET'</code>,<code>'DELETE'</code>.</p><h3>message.url</h3><p><strong>仅对从<a href=\"#http_class_http_server\">http.Server</a>获得的请求有效。</strong></p><p>请求的URL字符串。它仅包含实际的HTTP请求中所提供的URL，比如请求如下：</p><pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">GET</span></span> /status?name=ryan HTTP/<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>.<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n</code></pre><p><code>request.url</code> 就是:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/status?name=ryan'</span></span></code></pre><p>如果你想将URL分解，可以用<code>require('url').parse(request.url)</code>，例如：</p><pre><code class=\"hljs javascript\">node&gt; <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'url'</span></span>).parse(<span class=\"hljs-string\"><span class=\"hljs-string\">'/status?name=ryan'</span></span>)\n{ href: <span class=\"hljs-string\"><span class=\"hljs-string\">'/status?name=ryan'</span></span>,\n  search: <span class=\"hljs-string\"><span class=\"hljs-string\">'?name=ryan'</span></span>,\n  query: <span class=\"hljs-string\"><span class=\"hljs-string\">'name=ryan'</span></span>,\n  pathname: <span class=\"hljs-string\"><span class=\"hljs-string\">'/status'</span></span> }</code></pre><p>如果想从查询字符串中解析出参数，可以用<code>require('querystring').parse</code>函数，或者将<code>true</code>作为第二个参数传递给<code>require('url').parse</code>。 例如：</p><pre><code class=\"hljs javascript\">node&gt; <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'url'</span></span>).parse(<span class=\"hljs-string\"><span class=\"hljs-string\">'/status?name=ryan'</span></span>, <span class=\"hljs-literal\"><span class=\"hljs-literal\">true</span></span>)\n{ href: <span class=\"hljs-string\"><span class=\"hljs-string\">'/status?name=ryan'</span></span>,\n  search: <span class=\"hljs-string\"><span class=\"hljs-string\">'?name=ryan'</span></span>,\n  query: { name: <span class=\"hljs-string\"><span class=\"hljs-string\">'ryan'</span></span> },\n  pathname: <span class=\"hljs-string\"><span class=\"hljs-string\">'/status'</span></span> }</code></pre><h3>message.statusCode</h3><p><strong>仅对从<code>http.ClientRequest</code>获取的响应有效。</strong></p><p>3位数的HTTP响应状态码<code>404</code>。</p><h3>message.statusMessage</h3><p><strong>仅对从<code>http.ClientRequest</code>获取的响应有效。</strong></p><p>HTTP的响应消息。比如，<code>OK</code>或<code>Internal Server Error</code>.</p><h3>message.socket</h3><p>和连接相关联的<code>net.Socket</code>对象。</p><p>通过HTTPS支持，使用<code>request.connection.verifyPeer()</code>和<code>request.connection.getPeerCertificate()</code>获取客户端的身份信息。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 13,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e728dd0e339a237b80f424b63e1d1382",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js REPL",
      "chapter_level_two_url": "/nodejs/yw6r1ito.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>REPL</h2><p>REPL即Node自带的交互式解释器，它可以实现如下的任务：</p><ul><li>读取（Read）- 可以读取用户的输入，解析输入的Javascript数据结构并存储在内存中。</li><li>执行（Eval）- 可以执行输入的Javascript数据结构。</li><li>打印（Print）- 打印输出结果。</li><li>循环（Loop）- 对上述的步骤进行循环，如果需要退出，则用户需要两次按下ctrl-c按钮。</li></ul><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>Read-Eval-Print-Loop (REPL 读取-执行-输出循环)即可作为独立程序，也可以集成到其他程序中。</p><p>REPL提供了一种交互的执行JavaScript并查看输出结果的方法。可以用来调试，测试，或仅是用来试试。</p><p>在命令行中不带任何参数的执行<code>node</code>，就是REPL模式。它提供了简单的emacs行编辑。</p><pre><code class=\"hljs php\">mjr:~$ node\nType <span class=\"hljs-string\">'.help'</span> <span class=\"hljs-keyword\">for</span> options.\n&gt; a = [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n[ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> ]\n&gt; a.<span class=\"hljs-keyword\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(v)</span> </span>{\n...   console.log(v);\n...   });\n<span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">3</span></code></pre><p>若想使用高级的编辑模式，使用环境变量<code>NODE_NO_READLINE=1</code>打开node。这样会开启REPL模式，允许你使用<code>rlwrap</code>。</p><p>例如，你可以添加以下代码到你的bashrc文件里。</p><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">alias</span> node=<span class=\"hljs-string\">\"env NODE_NO_READLINE=1 rlwrap node\"</span></code></pre><h2 class=\"head2\">repl.start(options)</h2><p>启动并返回一个<code>REPLServer</code>实例。它继承自[Readline Interface][]。接收的参数\"options\"有以下值：</p><ul><li><p><code>prompt</code>- 所有输入输出的提示符和流，默认是<code>&gt;</code>.</p></li><li><p><code>input</code>- 需要监听的可读流，默认为<code>process.stdin</code>.</p></li><li><p><code>output</code>- 用来输出数据的可写流，默认为<code>process.stdout</code>.</p></li><li><p><code>terminal</code>- 如果<code>stream</code>被当成TTY，并且有ANSI/VT100转义，传输<code>true</code>。默认在实例的输出流上检查<code>isTTY</code>。</p></li><li><p><code>eval</code>- 用来对每一行进行求值的函数。默认为<code>eval()</code>的异步封装。参见后面的自定义<code>eval</code>例子。</p></li><li><p><code>useColors</code>- 写函数输出是否有颜色。如果设定了不同的<code>writer</code>函数则无效。默认为 repl 的<code>terminal</code>值。</p></li><li><p><code>useGlobal</code>- 如果为<code>true</code>，则repl将会使用全局对象，而不是在独立的上下文中运行scripts。默认为<code>false</code>。 </p></li><li><p><code>ignoreUndefined</code>- 如果为<code>true</code>，repl不会输出未定义命令的返回值。默认为<code>false</code>。  </p></li><li><code>writer</code>- 每个命令行被求值时都会调用这个函数，它会返回格式化显示内容（包括颜色）。默认是<code>util.inspect</code>。</li></ul><p>如果有以下特性，可以使用自己的<code>eval</code>函数：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">eval</span>(<span class=\"hljs-params\">cmd, context, filename, callback</span>) </span>{\n  callback(<span class=\"hljs-literal\">null</span>, result);\n}</code></pre><p>在同一个node的运行实例上，可以打开多个REPLs。每个都会共享一个全局对象，但会有独立的I/O。</p><p>以下的例子，在stdin、 Unix socket和  TCP socket上开启REPL ：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> net = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"net\"</span>),\n    repl = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"repl\"</span>);\n\nconnections = <span class=\"hljs-number\">0</span>;\n\nrepl.start({\n  prompt: <span class=\"hljs-string\">\"node via stdin&gt; \"</span>,\n  input: process.stdin,\n  output: process.stdout\n});\n\nnet.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">socket</span>) </span>{\n  connections += <span class=\"hljs-number\">1</span>;\n  repl.start({\n    prompt: <span class=\"hljs-string\">\"node via Unix socket&gt; \"</span>,\n    input: socket,\n    output: socket\n  }).on(<span class=\"hljs-string\">'exit'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    socket.end();\n  })\n}).listen(<span class=\"hljs-string\">\"/tmp/node-repl-sock\"</span>);\n\nnet.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">socket</span>) </span>{\n  connections += <span class=\"hljs-number\">1</span>;\n  repl.start({\n    prompt: <span class=\"hljs-string\">\"node via TCP socket&gt; \"</span>,\n    input: socket,\n    output: socket\n  }).on(<span class=\"hljs-string\">'exit'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    socket.end();\n  });\n}).listen(<span class=\"hljs-number\">5001</span>);</code></pre><p>从命令行运行这个程序，将会在stdin上启动REPL。其他的REPL客户端可能通过Unix socket或TCP socket连接。<code>telnet</code>常用于连接TCP socket，<code>socat</code>用于连接Unix和TCP sockets</p><p>从Unix socket-based服务器启动REPL（而非stdin），你可以建立长连接，不用重启它们。</p><p>通过<code>net.Server</code>和<code>net.Socket</code>实例运行\"full-featured\" (<code>terminal</code>) REPL的例子，参见: <a rel=\"nofollow\" href=\"https://gist.github.com/2209310\" target=\"_blank\">https://gist.github.com/2209310</a></p><p>通过<code>curl(1)</code>实例运行REPL的例子，参见: <a rel=\"nofollow\" href=\"https://gist.github.com/2053342\" target=\"_blank\">https://gist.github.com/2053342</a></p><h3>Event: 'exit'</h3><p><code>function () {}</code></p><p>当用户通过预定义的方式退出REPL将会触发这个事件。预定义的方式包括，在repl里输入<code>.exit</code>，按Ctrl+C两次来发送SIGINT信号，或者在<code>input</code>流上按Ctrl+D 来发送\"end\"。</p><p>监听<code>exit</code>的例子：</p><pre><code class=\"hljs javascript\">r.on(<span class=\"hljs-string\">'exit'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Got \"exit\" event from repl!'</span>);\n  process.exit();\n});</code></pre><h3>Event: 'reset'</h3><p><code>function (context) {}</code></p><p>重置REPL的上下文的时候触发。当你输入<code>.clear</code>会重置。如果你用<code>{ useGlobal: true }</code>启动repl，那这个事件永远不会被触发。</p><p>监听<code>reset</code>的例子：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Extend the initial repl context.</span>\nr = repl.start({ options ... });\nsomeExtension.extend(r.context);\n\n<span class=\"hljs-comment\">// When a new context is created extend it as well.</span>\nr.on(<span class=\"hljs-string\">'reset'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'repl has a new context'</span>);\n  someExtension.extend(context);\n});</code></pre><h2 class=\"head2\">REPL 特性</h2><p>在REPL里，  Control+D会退出。可以输入多行表达式。支持全局变量和局部变量的TAB自动补全。</p><p>特殊变量<code>_</code>(下划线)包含上一个表达式的结果。</p><pre><code class=\"hljs javascript\">&gt; [ <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"c\"</span> ]\n[ <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span> ]\n&gt; _.length\n<span class=\"hljs-number\">3</span>\n&gt; _ += <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">4</span></code></pre><p>REPL支持在全局域里访问任何变量。将变量赋值个和<code>REPLServer</code>关联的上下文对象，你可以显示的讲变量暴露给REPL，例如：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// repl_test.js</span>\n<span class=\"hljs-keyword\">var</span> repl = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"repl\"</span>),\n    msg = <span class=\"hljs-string\">\"message\"</span>;\n\nrepl.start(<span class=\"hljs-string\">\"&gt; \"</span>).context.m = msg;</code></pre><p><code>context</code>对象里的东西，会以局部变量的形式出现：</p><pre><code class=\"hljs ruby\"><span class=\"hljs-symbol\">mjr:</span>~$ node repl_test.js\n&gt; m\n<span class=\"hljs-string\">'message'</span></code></pre><p>有一些特殊的REPL命令：</p><ul><li><code>.break</code> - 当你输入多行表达式时，也许你走神了或者不想完成了，<code>.break</code>可以重新开始。  </li><li><code>.clear</code> - 重置<code>context</code>对象为空对象，并且清空多行表达式。  </li><li><code>.exit</code> - 关闭输入/输出流，会让REPL退出。</li><li><code>.help</code> - 打印这些特殊命令。</li><li><code>.save</code> - 保存当前REPL会话到文件。<blockquote><p>.save ./file/to/save.js</p></blockquote></li><li><code>.load</code>- 加载一个文件到当前REPL会话<blockquote><p>.load ./file/to/load.js</p></blockquote></li></ul><p>下面的组合键在REPL中有以下效果：</p><ul><li><code>&lt;ctrl&gt;C</code>- 和<code>.break</code>键类似，在一个空行连按两次会强制退出。</li><li><code>&lt;ctrl&gt;D</code>- 和<code>.exit</code>键类似。</li></ul></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 12,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "ee34559bd6d8c7a7d15cbefab5a84e76",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 子进程",
      "chapter_level_two_url": "/nodejs/d7c21itn.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>子进程</h2><p>Node.js是基于单线程模型架构的，它能够拥有高效的CPU利用率，却限制了多个核心CPU的使用，为此，Node.js提供了<code>child_process</code> 模块以通过多线程来实现对多核CPU的使用。</p><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>Node通过<code>child_process</code>模块提供了<code>popen(3)</code>数据流。</p><p>它能在非阻塞的方式中，通过<code>stdin</code>,<code>stdout</code>和<code>stderr</code>传递数据。 </p><p>请注意：某些程序使用内部线性缓冲I/O， 它并不妨碍node.js，只是你发送给子进程的数据不会被立即取消。</p><p>你可以使用<code>require('child_process').spawn()</code>或<code>require('child_process').fork()</code>创建一个子进程。这两种方法有区别，在下文中将进行解释。</p><p>开发过程中查看<a href=\"#child_process_synchronous_process_creation\">synchronous counterparts</a>效率会更高。</p><h2 class=\"head2\">类: ChildProcess</h2><p><code>ChildProcess</code>是一个<a href=\"aue11itf.html\" target=\"_blank\">EventEmitter</a>。</p><p>子进程有三个相关的流<code>child.stdin</code>,<code>child.stdout</code>和<code>child.stderr</code>。他们可能和会父进程的stdiostreams共享，也可作为独立的对象。</p><p>不能直接调用ChildProcess类，使用<code>spawn()</code>,<code>exec()</code>,<code>execFile()</code>或<code>fork()</code>方法来创建子进程的实例。</p><h3>事件:  'error'</h3><ul><li><code>err</code> {Error Object}错误。</li></ul><p>发生于:</p><ol><li>无法创建进程。</li><li>无法杀死进程。</li><li>无论什么原因导致给子进程发送消息失败。</li></ol><p>注意：<code>exit</code>事件有可能在错误发生后调用，也可能不调用，所以如果你监听这两个事件来触发函数，记得预防函数会被调用2次。</p><p>参考<a href=\"#child_process_child_kill_signal\"><code>ChildProcess#kill()</code></a>和<a href=\"#child_process_child_send_message_sendhandle\"><code>ChildProcess#send()</code></a>。</p><h3>事件: 'exit'</h3><ul><li><code>code</code> {Number} 退出代码, 正常退出时才有效。</li><li><code>signal</code> {String} 如果是被父进程杀死，则它为传递给子进程的信号</li></ul><p>子进程结束的时候触发这个事件。如果子进程正常终止，则<code>code</code>为最终的退出代码，否则为<code>null</code>。如果是由<code>signal</code>引起的终止，则<code>signal</code>为字符串，否则为 <code>null</code>。</p><p>注意：子进程的stdio流可能仍为开启模式。</p><p>注意，node为<code>'SIGINT'</code>和<code>'SIGTERM</code>' 建立句柄，所以当信号来临的时候，他们不会终止而是退出。</p><p>参靠<code>waitpid(2)</code>。</p><h3>事件: 'close'</h3><ul><li><code>code</code>{Number} 退出代码, 正常退出时才有效。</li><li><code>signal</code>{String} 如果是被父进程杀死，则它为传递给子进程的信号。</li></ul><p>子进程里所有stdio流都关闭时触发这个事件。要和'exit'区分开，因为多进程可以共享一个stdio流。</p><h3>Event: 'disconnect'</h3><p>父进程或子进程中调用<code>.disconnect()</code>方法后触发这个事件。断开后不会在互发消息，并且<code>.connected</code>属性值为false。</p><h3>Event: 'message'</h3><ul><li><code>message</code>{Object} 一个解析过的JSON对象，或者一个原始值。</li><li><code>sendHandle</code>{Handle object} 一个Socket或Server对象</li></ul><p>通过<code>.send(message, [sendHandle])</code>传递消息。</p><h3>child.stdin</h3><ul><li>{Stream object}</li></ul><p>子进程的<code>stdin</code>是<code>Writable Stream</code>（可写流）。如果子进程在等待输入，它就会暂停直到通过调用<code>end()</code>来关闭。</p><p><code>child.stdin</code>是<code>child.stdio[0]</code>的缩写。这两个都指向同一个对象，或者null。</p><h3>child.stdout</h3><ul><li>{Stream object}</li></ul><p>子进程的<code>stdout</code>是<code>Readable Stream</code>（可读流）。</p><p><code>child.stdout</code>是 <code>child.stdio[1]</code>的缩写。 这两个都指向同一个对象，或者null。</p><h3>child.stderr</h3><ul><li>{Stream object}</li></ul><p>子进程的<code>stderr</code>是<code>Readable Stream</code>（可写流）。</p><p><code>child.stderr</code>是<code>child.stdio[2]</code>缩写。这两个都指向同一个对象，或者null。</p><h3>child.stdio</h3><ul><li>{Array}</li></ul><p>子进程的管道数组和<a href=\"#child_process_child_process_spawn_command_args_options\">spawn</a>的<a href=\"#child_process_options_stdio\" target=\"_blank\">stdio</a>里设置为<code>'pipe'</code> 的内容次序相对应。</p><p>注意，流[0-2]也能分别用ChildProcess.stdin、ChildProcess.stdout和ChildProcess.stderrNote来表示。</p><p>在下面的例子里，只有子进程的fd<code>1</code>设置为pipe管道，所以父进程的<code>child.stdio[1]</code>是流（stream），数组里其他值为<code>null</code>。</p><pre><code class=\"hljs java\">child = child_process.spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"ls\"</span></span></span>, {\n    stdio: [\n      <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>, <span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// use parents stdin for child</span></span></span>\n      <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'pipe'</span></span></span>, <span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// pipe child's stdout to parent</span></span></span>\n      fs.openSync(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"err.out\"</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"w\"</span></span></span>) <span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// direct child's stderr to a file</span></span></span>\n    ]\n});\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>.equal(child.stdio[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>], <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">null</span></span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>.equal(child.stdio[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>], child.stdin);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>(child.stdout);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>.equal(child.stdio[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span></span>], child.stdout);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>.equal(child.stdio[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span></span>], <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">null</span></span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">assert</span></span></span>.equal(child.stdio[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span></span>], child.stderr);</code></pre><h3>child.pid</h3><ul><li>{Integer}</li></ul><p>子进程的PID。</p><p>例子:</p><pre><code class=\"hljs perl\">var spawn = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn,\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">grep</span></span></span>  = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'grep'</span></span></span>, [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ssh'</span></span></span>]);\n\nconsole.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'Spawned child pid: '</span></span></span> + <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">grep</span></span></span>.pid);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">grep</span></span></span>.stdin.end();</code></pre><h3>child.connected</h3><ul><li>{Boolean} 调用`.disconnect'后设置为false</li></ul><p>如果<code>.connected</code>为 false，消息不再可用。</p><h3>child.kill([signal])</h3><ul><li><code>signal</code>{String}</li></ul><p>发送信号给子进程。如果没有参数，会发送<code>'SIGTERM'</code>，参见<code>signal(7)</code>里的可用的信号列表。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> spawn = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn,\n    grep  = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'grep'</span></span></span>, [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ssh'</span></span></span>]);\n\ngrep.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'close'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">code, signal</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child process terminated due to receipt of signal '</span></span></span>+signal);\n});\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// send SIGHUP to process</span></span></span>\ngrep.kill(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'SIGHUP'</span></span></span>);</code></pre><p>当信号无法传递的时候会触发<code>'error'</code>事件。给已经终止的进程发送信号不会触发<code>'error'</code>事件，但是可以能引起不可预知的后果: 因为有可能PID (进程ID) 已经重新分配给其他进程，信号就会被发送到新的进程里，无法想象这样会引发什么样的事情。</p><p>注意：当函数调用<code>kill</code>信号的时候，它实际并并不会杀死进程，只是发送信号给进程。</p><p>参见<code>kill(2)</code></p><h3>child.send(message[, sendHandle])</h3><ul><li><code>message</code>{Object}</li><li><code>sendHandle</code>{Handle object}</li></ul><p>使用<code>child_process.fork()</code>的时候，你能用<code>child.send(message, [sendHandle])</code>给子进程写数据，子进程通过<code>'message'</code>接收消息。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> cp = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> n = cp.fork(__dirname + <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/sub.js'</span></span></span>);\n\nn.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">m</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'PARENT got message:'</span></span></span>, m);\n});\n\nn.send({ hello: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'world'</span></span></span> });</code></pre><p>子进程的代码<code>'sub.js'</code> :</p><pre><code class=\"hljs javascript\">process.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">m</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'CHILD got message:'</span></span></span>, m);\n});\n\nprocess.send({ foo: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'bar'</span></span></span> });</code></pre><p>子进程代码里的<code>process</code>对象拥有<code>send()</code>方法，当它通过信道接收到信息时会触发，并返回对象。</p><p>注意：父进程和子进程<code>send()</code>是同步的，不要用来发送大块的数据（可以用管道来代替，参见<a href=\"#child_process_child_process_spawn_command_args_options\"><code>child_process.spawn</code></a>)。</p><p>不过发送<code>{cmd: 'NODE_foo'}</code>消息是特殊情况。所有包含<code>NODE_</code>前缀的消息都不会被触发，因为它们是node的内部的核心消息，它们会在<code>internalMessage</code>事件里触发，尽量避免使用这个特性。</p><p><code>child.send()</code>里的<code>sendHandle</code>属性用来发送TCP服务或socket对象给其他的进程，子进程会用接收到的对象作为<code>message</code>事件的第二个参数。</p><p>如果不能发出消息会触发<code>'error'</code>事件，比如子进程已经退出。</p><h4>例子: 发送 server 对象</h4><p>以下是例子:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> child = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).fork(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child.js'</span></span></span>);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Open up the server object and send the handle.</span></span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> server = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'net'</span></span></span>).createServer();\nserver.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'connection'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">socket</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  socket.end(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'handled by parent'</span></span></span>);\n});\nserver.listen(<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span></span>{\n  child.send(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'server'</span></span></span>, server);\n});</code></pre><p>子进程将会收到这个server对象:</p><pre><code class=\"hljs javascript\">process.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">m, server</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (m === <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'server'</span></span></span>) {\n    server.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'connection'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">socket</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n      socket.end(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'handled by child'</span></span></span>);\n    });\n  }\n});</code></pre><p>注意，现在父子进程共享了server，某些连接会被父进程处理，某些会被子进程处理。</p><p><code>dgram</code>服务器，工作流程是一样的，监听的是<code>message</code>事件，而不是<code>connection</code>，使用<code>server.bind</code>而不是<code>server.listen</code>。(目前仅支持UNIX平台)</p><h4>例子: 发送 socket 对象</h4><p>以下是发送socket对象的例子。他将会创建2个子线程，并且同时处理连接，一个将远程地址<code>74.125.127.100</code>当做VIP发送到一个特殊的子进程，另外一个发送到正常进程。var normal=require('child_process').fork('child.js', ['normal']);var special = require('child_process').fork('child.js', ['special']);</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Open up the server and send sockets to child</span></span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> server = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'net'</span></span></span>).createServer();\nserver.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'connection'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">socket</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// if this is a VIP</span></span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (socket.remoteAddress === <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'74.125.127.100'</span></span></span>) {\n    special.send(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'socket'</span></span></span>, socket);\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span></span>;\n  }\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// just the usual dudes</span></span></span>\n  normal.send(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'socket'</span></span></span>, socket);\n});\nserver.listen(<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1337</span></span></span>);</code></pre><p><code>child.js</code>代码如下:</p><pre><code class=\"hljs javascript\">process.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">m, socket</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (m === <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'socket'</span></span></span>) {\n    socket.end(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'You were handled as a '</span></span></span> + process.argv[<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span></span>] + <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">' person'</span></span></span>);\n  }\n});</code></pre><p>注意，当socket发送给子进程后，如果这个socket被销毁，父进程不再跟踪它，相应的<code>.connections</code>属性会变为<code>null</code>。这种情况下，不建议使用 <code>.maxConnections</code>。</p><h3>child.disconnect()</h3><p>关闭父子进程间的所有IPC通道，能让子进程优雅的退出。调用这个方法后，父子进程里的<code>.connected</code>标志会变为<code>false</code>，之后不能再发送消息。</p><p>当进程里没有消息需要处理的时候，会触发'disconnect'事件。</p><p>注意，在子进程还有IPC通道的情况下（如<code>fork()</code>），也可以调用<code>process.disconnect()</code>来关闭它。</p><h2 class=\"head2\">创建异步处理</h2><p>这些方法遵从常用的异步处理模式（比如回调，或者返回一个事件处理）。</p><h3>child_process.spawn(command[, args][, options])</h3><ul><li><code>command</code> {String} 要运行的命令</li><li><code>args</code> {Array} 字符串参数表</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的工作目录</li><li><code>env</code> {Object} 环境</li><li><code>stdio</code> {Array|String} 子进程的stdio配置。</li><li><code>customFds</code> {Array} <strong>Deprecated</strong> 作为子进程stdio使用的文件标示符。</li><li><code>detached</code> {Boolean} 子进程将会变成一个进程组的领导者。</li><li><code>uid</code> {Number} 设置用户进程的ID。(参见setuid(2))</li><li><code>gid</code> {Number} 设置进程组的ID。(参见 setgid(2))</li></ul></li><li>返回: {ChildProcess object}</li></ul><p>用指定的<code>command</code>发布一个子进程，<code>args</code>是命令行参数。如果忽略，<code>args</code>是空数组。</p><p>第三个参数用来指定附加设置，默认值:</p><pre><code class=\"hljs css\">{ <span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">cwd</span></span></span>: undefined,\n  env: process.env\n}</code></pre><p>创建的子进程里使用<code>cwd</code>指定工作目录，如果没有指定，默认继承自当前的工作目录。</p><p>使用<code>env</code>来指定新进程可见的环境变量。默认是<code>process.env</code>。</p><p>例如，运行<code>ls -lh /usr</code>，获取<code>stdout</code>,<code>stderr</code>和退出代码:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> spawn = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn,\n    ls    = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ls'</span></span></span>, [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'-lh'</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/usr'</span></span></span>]);\n\nls.stdout.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stdout: '</span></span></span> + data);\n});\n\nls.stderr.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stderr: '</span></span></span> + data);\n});\n\nls.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'close'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">code</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child process exited with code '</span></span></span> + code);\n});</code></pre><p>例如:通过一个非常精巧的方法执行'ps ax | grep ssh'</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> spawn = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn,\n    ps    = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ps'</span></span></span>, [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ax'</span></span></span>]),\n    grep  = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'grep'</span></span></span>, [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ssh'</span></span></span>]);\n\nps.stdout.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  grep.stdin.write(data);\n});\n\nps.stderr.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ps stderr: '</span></span></span> + data);\n});\n\nps.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'close'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">code</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (code !== <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ps process exited with code '</span></span></span> + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">''</span></span></span> + data);\n});\n\ngrep.stderr.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'grep stderr: '</span></span></span> + data);\n});\n\ngrep.on(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'close'</span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">code</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (code !== <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'grep process exited with code '</span></span></span> + code);\n  }\n});</code></pre><h3>options.stdio</h3><p><code>stdio</code>可能是以下几个参数之一:</p><ul><li><code>'pipe'</code>-<code>['pipe', 'pipe', 'pipe']</code>，默认值</li><li><code>'ignore'</code>-<code>['ignore', 'ignore', 'ignore']</code></li><li><code>'inherit'</code>-<code>[process.stdin, process.stdout, process.stderr]</code>或<code>[0,1,2]</code></li></ul><p><code>child_process.spawn()</code>里的'stdio'参数是一个数组，它和子进程的fd相对应，它的值如下:</p><ol><li><p><code>'pipe'</code>- 创建在父进程和子进程间的pipe。管道的父进程端以<code>child_process</code>的属性形式暴露给父进程，例如<code>ChildProcess.stdio[fd]</code>。为fds 0 - 2创建的管道也可以通过ChildProcess.stdin，ChildProcess.stdout和ChildProcess.stderr来独立的访问。</p></li><li><p><code>'ipc'</code>- 在父进程和子进程间创建一个IPC通道来传递消息/文件描述符。一个子进程最多有<strong>1个</strong>IPC stdio文件标识。设置这个选项会激活ChildProcess.send() 方法。如果子进程向此文件标识写入JSON消息，则会触发ChildProcess.on('message') 。如果子进程是Node.js程序，那么IPC通道会激活process.send()和 process.on('message')。</p></li><li><p><code>'ignore'</code>- 在子进程里不要设置这个文件标识，需要注意，Node总会为其spawn的进程打开fd 0-2。如果任何一个被ignored，node将会打开<code>/dev/null</code>并赋给子进程的fd。</p></li><li><p><code>Stream</code>对象 - 共享一个tty、file、socket或刷（pipe）可读或可写流给子进程。该流底层（underlying）的文件标识在子进程中被复制给stdio数组索引对应的文件标识（fd）。</p></li><li><p>正数 - 这个整数被理解为一个在父进程中打开的文件标识，它和子进程共享，就和共享<code>Stream</code>对象类似。</p></li><li><code>null</code>,<code>undefined</code>- 使用默认值。 对于stdio fds 0、1 and 2 (换句话说，stdin、stdout或者stderr) ，pipe管道被建立。 对于fd 3及之后，默认是 <code>'ignore'</code>。</li></ol><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> spawn = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn;\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Child will use parent's stdios</span></span></span>\nspawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'prg'</span></span></span>, [], { stdio: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'inherit'</span></span></span> });\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Spawn child sharing only stderr</span></span></span>\nspawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'prg'</span></span></span>, [], { stdio: [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'pipe'</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'pipe'</span></span></span>, process.stderr] });\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Open an extra fd=4, to interact with programs present a</span></span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// startd-style interface.</span></span></span>\nspawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'prg'</span></span></span>, [], { stdio: [<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'pipe'</span></span></span>, <span class=\"hljs-literal\"><span class=\"hljs-literal\"><span class=\"hljs-literal\">null</span></span></span>, <span class=\"hljs-literal\"><span class=\"hljs-literal\"><span class=\"hljs-literal\">null</span></span></span>, <span class=\"hljs-literal\"><span class=\"hljs-literal\"><span class=\"hljs-literal\">null</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'pipe'</span></span></span>] });</code></pre><h3>options.detached</h3><p>如果设置了<code>detached</code>选项，子进程将会被作为新进程组的leader，这使得子进程可以在父进程退出后继续运行。</p><p>缺省情况下父进程会等detached的子进程退出。要阻止父进程等待一个这样的子进程，调用child.unref()方法，则父进程的事件循环引用计数中将不会包含这个子进程。</p><p>detaching一个长期运行的进程，并重新将输出指向文件：</p><pre><code class=\"hljs javascript\"> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> fs = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'fs'</span></span></span>),\n     spawn = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).spawn,\n     out = fs.openSync(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'./out.log'</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'a'</span></span></span>),\n     err = fs.openSync(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'./out.log'</span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'a'</span></span></span>);\n\n <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> child = spawn(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'prg'</span></span></span>, [], {\n   detached: <span class=\"hljs-literal\"><span class=\"hljs-literal\"><span class=\"hljs-literal\">true</span></span></span>,\n   stdio: [ <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'ignore'</span></span></span>, out, err ]\n });\n\n child.unref();</code></pre><p>使用<code>detached</code>选项来启动一个长时间运行的进程时，进程不会在后台保持运行，除非他提供了一个不连接到父进程的<code>stdio</code>。如果继承了父进程的<code>stdio</code>，则子进程会继续控制终端。</p><h3>options.customFds</h3><p>已废弃，<code>customFds</code>允许指定特定文件描述符作为子进程的<code>stdio</code>。该API无法移植到所有平台，因此被废弃。使用<code>customFds</code>可以将新进程的 [<code>stdin</code>, <code>stdout</code>,<code>stderr</code>] 钩到已有流上；-1表示创建新流。自己承担使用风险。</p><p>参见:<code>child_process.exec()</code>和<code>child_process.fork()</code></p><h3>child_process.exec(command[, options], callback)</h3><ul><li><code>command</code> {String} 要执行的命令，空格分割</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的当前工作目录</li><li><code>env</code> {Object} 环境变量</li><li><code>encoding</code> {String} (默认: 'utf8')</li><li><code>shell</code> {String} 运行命令的shell(默认为: '/bin/sh'  UNIX, 'cmd.exe'  Windows， 该shell必须接收UNIX上的<code>-c</code>开关 ，或者Windows上的<code>/s /c</code>开关。Windows上，命令解析必须兼容<code>cmd.exe</code>。)</li><li><code>timeout</code> {Number} (默认: 0)</li><li><code>maxBuffer</code> {Number} (默认: <code>200*1024</code>)</li><li><code>killSignal</code> {String} (默认: 'SIGTERM')</li><li><code>uid</code> {Number} 设置进程里的用户标识。 (见 setuid(2)。)</li><li><code>gid</code> {Number} 设置进程里的群组标识。(见 setgid(2)。)</li></ul></li><li><code>callback</code> {Function} 进程终止的时候调用<ul><li><code>error</code> {Error}</li><li><code>stdout</code> {Buffer}</li><li><code>stderr</code> {Buffer}</li></ul></li><li>返回: ChildProcess对象</li></ul><p>在shell里执行命令，并缓冲输出。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span> exec = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'child_process'</span></span></span>).exec,\n    child;\n\nchild = exec(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'cat *.js bad_file | wc -l'</span></span></span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">error, stdout, stderr</span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span>{\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stdout: '</span></span></span> + stdout);\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stderr: '</span></span></span> + stderr);\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span> (error !== <span class=\"hljs-literal\"><span class=\"hljs-literal\"><span class=\"hljs-literal\">null</span></span></span>) {\n      <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'exec error: '</span></span></span> + error);\n    }\n});</code></pre><p>回调参数是<code>(error, stdout, stderr)</code>。如果成功，则,<code>error</code>值为<code>null</code>。 如果失败，则<code>error</code>变为<code>Error</code>的实例，<code>error.code</code>等于子进程退出码，并且 <code>error.signal</code>会被设置为结束进程的信号名。</p><p>第二个参数可以设置一些选项。默认如下：</p><pre><code class=\"hljs css\">{ <span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">encoding</span></span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'utf8'</span></span></span>,\n  timeout: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span>,\n  maxBuffer: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span></span>*<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1024</span></span></span>,\n  killSignal: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'SIGTERM'</span></span></span>,\n  cwd: null,\n  env: null }</code></pre><p>如果<code>timeout</code>大于0，子进程运行时间超过<code>timeout</code>时会被终止。<code>killSignal</code>(默认: <code>'SIGTERM'</code>)能杀死子进程。<code>maxBuffer</code>设定了stdout或stderr的最大数据量，如果子进程的数量量超过了，将会被杀死。</p><h3>(file[, args][, options][, callback])</h3><ul><li><code>file</code> {String} 要运行的程序的文件名</li><li><code>args</code> {Array} 参数列表</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的工作目录</li><li><code>env</code> {Object} 环境</li><li><code>encoding</code> {String} (默认: 'utf8')</li><li><code>timeout</code> {Number} (默认: 0)</li><li><code>maxBuffer</code> {Number} (默认: 200*1024)</li><li><code>killSignal</code> {String} (默认: 'SIGTERM')</li><li><code>uid</code> {Number} 设置进程里的用户标识。 (参见setuid(2)。)</li><li><code>gid</code> {Number} 设置进程里的群组标识。(参见setgid(2)。)</li></ul></li><li><code>callback</code> {Function} 进程终止的时候调用<ul><li><code>error</code> {Error}</li><li><code>stdout</code> {Buffer}</li><li><code>stderr</code> {Buffer}</li></ul></li><li>返回: ChildProcess对象</li></ul><p>和<code>child_process.exec()</code>类似，不同之处在于这是执行一个指定的文件，因此它比<code>child_process.exec</code>精简些，参数相同。</p><h3>child_process.fork(modulePath[, args][, options])</h3><ul><li><code>modulePath</code> {String} 子进程里运行的模块</li><li><code>args</code> {Array} 参数列表</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的工作目录</li><li><code>env</code> {Object} 环境</li><li><code>execPath</code> {String} 执行文件路径</li><li><code>execArgv</code> {Array} 执行参数(默认: <code>process.execArgv</code>)</li><li><code>silent</code> {Boolean} 如果是 true ，子进程将会用父进程的 stdin, stdout, and stderr ，否则，将会继承自父进程, 更多细节，参见 <code>spawn()</code> 的 <code>stdio</code> 参数里的 \"pipe\" 和 \"inherit\" 选项(默认 false)</li><li><code>uid</code> {Number} 设置进程里的用户标识。 (见 setuid(2)。)</li><li><code>gid</code> {Number} 设置进程里的群组标识。 (见 setgid(2)。)</li></ul></li><li>返回: ChildProcess对象</li></ul><p>这是<code>spawn()</code>的特殊例子，用于派生Node进程。除了拥有子进程的所有方法，它的返回对象还拥有内置通讯通道。参见<code>child.send(message, [sendHandle])</code>。</p><p>这些Nodes是全新的V8实例化，假设每个Node最少需要30ms的启动时间，10mb的存储空间，可想而知，创建几千个Node是不太现实的。</p><p><code>options</code>对象中的<code>execPath</code>属性可以用于执行文件（非当前<code>node</code> ）创建子进程。这需要小心使用，缺省情况下fd表示子进程的<code>NODE_CHANNEL_FD</code>环境变量。该fa的输入和输出是以行分割的JSON对象。</p><h2 class=\"head2\">创建同步进程</h2><p>以下这些方法是<strong>同步</strong>的，意味着他会<strong>阻塞</strong>事件循环，并暂停执行代码，直到spawned的进程退出。</p><p>同步方法简化了任务进程，比如大为简化在应用初始化加载/处理过程。</p><h3>child_process.spawnSync(command[, args][, options])</h3><ul><li><code>command</code> {String} 要执行的命令</li><li><code>args</code> {Array} 参数列表</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的当前工作目录</li><li><code>input</code> {String|Buffer} 传递给spawned进程的值，这个值将会重写<code>stdio[0]</code></li><li><code>stdio</code> {Array}  子进程的stdio配置。 </li><li><code>env</code> {Object} 环境变量</li><li><code>uid</code> {Number}   设置用户进程的ID。 (参见setuid(2)。)</li><li><code>gid</code> {Number} 设置进程组的ID。 (参见setgid(2)。)</li><li><code>timeout</code> {Number} 子进程运行最大毫秒数。 (默认: undefined)</li><li><code>killSignal</code> {String} 用来终止子进程的信号。 (默认: 'SIGTERM')</li><li><code>maxBuffer</code> {Number}</li><li><code>encoding</code> {String} stdio输入和输出的编码方式。 (默认: 'buffer')</li></ul></li><li>返回: {Object}<ul><li><code>pid</code> {Number} 子进程的pid</li><li><code>output</code> {Array} stdio输出的结果数组</li><li><code>stdout</code> {Buffer|String}  <code>output[1]</code>的内容</li><li><code>stderr</code> {Buffer|String} <code>output[2]</code>的内容</li><li><code>status</code> {Number} 子进程的退出代码</li><li><code>signal</code> {String} 用来杀死子进程的信号</li><li><code>error</code> {Error} 子进程错误或超时的错误代码  </li></ul></li></ul><p><code>spawnSync</code>直到子进程关闭才会返回。超时或者收到<code>killSignal</code>信号，也不会返回，直到进程完全退出。进程处理完<code>SIGTERM</code>信号后并不会结束，直到子进程完全退出。</p><h3>child_process.execFileSync(command[, args][, options])</h3><ul><li><code>command</code> {String} 要执行的命令</li><li><code>args</code> {Array} 参数列表</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的当前工作目录</li><li><code>input</code> {String|Buffer}传递给spawned进程的值，这个值将会重写 <code>stdio[0]</code></li><li><code>stdio</code> {Array}子进程的stdio配置。 (默认: 'pipe')<ul><li><code>stderr</code> 默认情况下会输出给父进程的' stderr除非指定了 <code>stdio</code></li></ul></li><li><code>env</code> {Object} 环境变量</li><li><code>uid</code> {Number} 设置用户进程的ID。 (参见setuid(2)。)</li><li><code>gid</code> {Number} 设置进程组的ID。 (参见setgid(2)。)</li><li><code>timeout</code> {Number} 进程运行最大毫秒数。 (默认: undefined)</li><li><code>killSignal</code> {String} 用来终止子进程的信号。 (默认: 'SIGTERM')</li><li><code>maxBuffer</code> {Number}</li><li><code>encoding</code> {String} stdio输入和输出的编码方式。 (默认: 'buffer')</li></ul></li><li>返回: {Buffer|String} 来自命令的stdout </li></ul><p>直到子进程完全退出，<code>execFileSync</code>才会返回。超时或者收到<code>killSignal</code>信号，也不会返回，直到进程完全退出。进程处理完<code>SIGTERM</code>信号后并不会结束，直到子进程完全退出。</p><p>如果进程超时，或者非正常退出，这个方法将会抛出异常。<code>Error</code>会包含整个<a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync</code></a>结果。</p><h3>child_process.execSync(command[, options])</h3><ul><li><code>command</code> {String} 要执行的命令</li><li><code>options</code> {Object}<ul><li><code>cwd</code> {String} 子进程的当前工作目录</li><li><code>input</code> {String|Buffer} 传递给spawned进程的值，这个值将会重写<code>stdio[0]</code></li><li><code>stdio</code> {Array} 子进程的stdio配置。 (默认: 'pipe')<ul><li><code>stderr</code> 默认情况下会输出给父进程的' stderr 除非指定了<code>stdio</code></li></ul></li><li><code>env</code> {Object} 环境变量</li><li><code>uid</code> {Number} 设置用户进程的ID。 (参见setuid(2)。)</li><li><code>gid</code> {Number} 设置进程组的ID。 (参见setgid(2)。)</li><li><code>timeout</code> {Number} 进程运行最大毫秒数。 (默认: undefined)</li><li><code>killSignal</code> {String} 用来终止子进程的信号。 (默认: 'SIGTERM')</li><li><code>maxBuffer</code> {Number}</li><li><code>encoding</code> {String} stdio输入和输出的编码方式。 (默认: 'buffer')</li></ul></li><li>返回: {Buffer|String}来自命令的stdout </li></ul><p>直到子进程完全退出，<code>execSync</code>才会返回。超时或者收到<code>killSignal</code>信号，也不会返回，直到进程完全退出。进程处理完<code>SIGTERM</code>信号后并不会结束，直到子进程完全退出。</p><p>如果进程超时，或者非正常退出，这个方法将会抛出异常。<code>Error</code>会包含整个<a href=\"#child_process_child_process_spawnsync_command_args_options\"><code>child_process.spawnSync</code></a>结果。</p><p>以上就是Node.js官方文档中有关子进程的介绍。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 11,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "c726fbfba535c95ef6b66278fd73a317",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 全局对象",
      "chapter_level_two_url": "/nodejs/uk7r1itm.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>全局对象</h2><p>在Node.js中我们可以直接访问到全局对象。<br></p><p>这些对象在所有模块里都是可用的，有些对象不是在全局作用域而是在模块作用域里，这些情况将在本文的内容中进行介绍。</p><h3>global</h3><ul><li>{Object} 全局命名空间对象。</li></ul><p>在浏览器中，全局作用域就是顶级域。如果在全局域内定义变量<code>var something</code>将会是全局变量。而在Node中，顶级域并不是全局域；在模块里定义变量 <code>var something</code>只是模块内可用。</p><h3>process</h3><ul><li>{Object}</li></ul><p>进程对象。参见<a href=\"qvcz1iu6.html\" target=\"_blank\">process object</a>章节.</p><h3>console</h3><ul><li>{Object}</li></ul><p>用来打印stdout和stderr。参见<a href=\"of871itt.html\" target=\"_blank\">console</a>章节.</p><h3>Class: Buffer</h3><ul><li>{Function}</li></ul><p>用来处理二进制数据。参见<a href=\"x1u41ith.html\" target=\"_blank\">buffer 章节</a>。</p><h3>require()</h3><ul><li>{Function}</li></ul><p>引入模块。参见<a href=\"p93z1itu.html\" target=\"_blank\">Modules</a>章节。<code>require</code>实际上并非全局的，而是各个本地模块有效。</p><h4>require.resolve()</h4><p>使用内部<code>require()</code>机制来查找module位置，但是不加载模块，只是返回解析过的文件名。</p><h4>require.cache</h4><ul><li>{Object}</li></ul><p>引入模块时会缓存到这个对象。通过删除该对象键值，下次调用<code>require</code>将会重载该模块。</p><h4>require.extensions</h4><pre><code class=\"hljs\">稳定性: 0 - 抛弃</code></pre><ul><li>{Object}</li></ul><p>指导<code>require</code>如何处理特定的文件扩展名。</p><p>将<code>.sjs</code>文件当作<code>.js</code>文件处理：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>.extensions[<span class=\"hljs-string\"><span class=\"hljs-string\">'.sjs'</span></span>] = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>.extensions[<span class=\"hljs-string\"><span class=\"hljs-string\">'.js'</span></span>];</code></pre><p><strong>抛弃</strong>  以前这个列表用来加载按需编译的非JavaScript模块到node。实际上，有更好的办法来解决这个问题，比如通过其他node程序来加载模块，或者提前编译成 JavaScript。</p><p>由于模块系统已经锁定，该功能可能永远不会去掉。改动它可能会产生bug，所以最好不要动它。</p><h3>__filename</h3><ul><li>{String}</li></ul><p>被执行的代码的文件名是相对路径。对于主程序来说，这和命令行里未必用同一个文件名。模块里的值是模块文件的路径。</p><p>列如，运行<code>/Users/mjr</code>里的<code>node example.js</code>：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(__filename);\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// /Users/mjr/example.js</span></span></code></pre><p><code>__filename</code>不是全局的，而是模块本地的。</p><h3>__dirname</h3><ul><li>{String}</li></ul><p>执行的script代码所在的文件夹的名字。</p><p>列如，运行<code>/Users/mjr</code>里的<code>node example.js</code>：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(__dirname);\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// /Users/mjr</span></span></code></pre><p><code>__dirname</code>不是全局的，而是模块本地的。</p><h3>module</h3><ul><li>{Object}</li></ul><p>当前模块的引用。通过<code>require()</code>，<code>module.exports</code>定义了哪个模块输出可用。</p><p><code>module</code>不是全局的，而是模块本地的。</p><p>更多信息参见<a href=\"p93z1itu.html\" target=\"_blank\">module system documentation</a>。</p><h3>exports</h3><p><code>module.exports</code>的引用。关于什么时候使用<code>exports</code>和<code>module.exports</code>，可以参考<a href=\"p93z1itu.html\" target=\"_blank\">module system documentation</a>。</p><p><code>module</code>不是全局的，而是模块本地的。  </p><p>更多信息参见<a href=\"p93z1itu.html\" target=\"_blank\">module system documentation</a>。</p><p>更多信息参见<a href=\"p93z1itu.html\" target=\"_blank\">module 章节</a>。</p><h3>setTimeout(cb, ms)</h3><p>最少在<code>ms</code>毫秒后调回调函数。实际的延迟依赖于外部因素，比如操作系统的粒度和负载。</p><p>timeout值有效范围为1-2,147,483,647。如果超过该范围，将会变为1毫秒。通常，定时器不应该超过24.8天。</p><p>返回一个代表定时器的句柄值。  </p><h3>clearTimeout(t)</h3><p>停止一个之前通过<code>setTimeout()</code>创建的定时器。不会再被执行回调。  </p><h3>setInterval(cb, ms)</h3><p>每隔<code>ms</code>毫秒调用回调函数<code>cb</code>。实际的间隔依赖于外部因素，比如操作系统的粒度和系统负载。通常会大于<code>ms</code>。</p><p>间隔值的有效范围在1-2,147,483,647。如果超过该范围，将会变为1毫秒。通常，定时器不应该超过24.8天。</p><p>返回一个代表该定时器的句柄值。  </p><h3>clearInterval(t)</h3><p>停止一个之前通过<code>setInterval()</code>创建的定时器。不会再被执行回调。  </p><p>timer函数是全局变量。参见<a href=\"8kdi1iu2.html\" target=\"_blank\">timers</a>章节。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 10,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b67e5e317c2662408fc738c38c198f43",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 逐行读取",
      "chapter_level_two_url": "/nodejs/ble81itl.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>逐行读取</h2><p>本节介绍Node.js readline（逐行读取）模块，它用于提供一个接口。</p><pre><code class=\"hljs\">稳定性: 2 - 不稳定</code></pre><p>通过 <code>require('readline')</code>，你可以使用这个模块。逐行读取（Readline）可以逐行读取流（比如<code>process.stdin</code>）。</p><p>访问该模块的方法如下：</p><pre><code>const readline = require('readline');</code></pre><p>一旦你开启了这个模块，node程序将不会终止，直到你关闭接口。以下的代码展示了如何优雅的退出程序：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> readline = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'readline'</span>);\n\n<span class=\"hljs-keyword\">var</span> rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.question(<span class=\"hljs-string\">\"What do you think of node.js? \"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">answer</span>) </span>{\n  <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Log the answer in a database</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Thank you for your valuable feedback:\"</span>, answer);\n\n  rl.close();\n});</code></pre><h2 class=\"head2\">readline.createInterface(options)</h2><p>创建一个逐行读取（Readline）<code>Interface</code>实例。参数\"options\"对象有以下值:</p><ul><li><p><code>input</code>- 监听的可读流 (必填)。</p></li><li><p><code>output</code>- 逐行读取（Readline）数据要写入的可写流(可选)。</p></li><li><p><code>completer</code>- 用于Tab自动补全的可选函数。参见下面的例子。</p></li><li><code>terminal</code>- 如果希望和TTY一样，对待<code>input</code>和<code>output</code>流，设置为true。并且由ANSI/VT100转码。默认情况下，检查<code>isTTY</code>是否在<code>output</code>流上实例化。</li></ul><p><code>completer</code>给出当前行的入口，应该返回包含2条记录的数组。</p><ol><li><p>一个匹配当前输入补全的字符串数组</p></li><li>用来匹配的子字符串</li></ol><p>最终像这样:<code>[[substr1, substr2, ...], originalsubstring]</code>.</p><p>例子：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">completer</span>(<span class=\"hljs-params\">line</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> completions = <span class=\"hljs-string\">'.help .error .exit .quit .q'</span>.split(<span class=\"hljs-string\">' '</span>)\n  <span class=\"hljs-keyword\">var</span> hits = completions.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">c</span>) </span>{ <span class=\"hljs-keyword\">return</span> c.indexOf(line) == <span class=\"hljs-number\">0</span> })\n  <span class=\"hljs-comment\">// show all completions if none found</span>\n  <span class=\"hljs-keyword\">return</span> [hits.length ? hits : completions, line]\n}</code></pre><p>同时，<code>completer</code>可以异步运行，此时接收到2个参数:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">completer</span>(<span class=\"hljs-params\">linePartial, callback</span>) </span>{\n  callback(<span class=\"hljs-literal\">null</span>, [[<span class=\"hljs-string\">'123'</span>], linePartial]);\n}</code></pre><p>为了接受用户输入，<code>createInterface</code>通常和<code>process.stdin</code> ，<code>process.stdout</code>一起使用：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> readline = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'readline'</span>);\n<span class=\"hljs-keyword\">var</span> rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});</code></pre><p>如果你有逐行读取（Readline）实例, 通常会监听<code>\"line\"</code>事件.</p><p>如果这个实例参数<code>terminal</code> = <code>true</code>，而且定义了<code>output.columns</code>属性，那么<code>output</code>流将会最佳兼容性，并且，当columns变化时（当它是TTY时，<code>process.stdout</code>会自动这么做），会在<code>output</code>流上触发<code>\"resize\"</code>事件。</p><h2 class=\"head2\">Class: Interface</h2><p>代表一个包含输入/输出流的逐行读取（Readline）接口的类。</p><h3>rl.setPrompt(prompt)</h3><p>设置提示符，比如当你再命令行里运行<code>node</code>时，可以看到node的提示符<code>&gt;</code>。</p><h3>rl.prompt([preserveCursor])</h3><p>为用户输入准备好逐行读取（Readline），将当前<code>setPrompt</code>选项方法哦新的行中，让用户有新的地方输入。设置<code>preserveCursor</code>为<code>true</code>，防止当前的游标重置为<code>0</code>。</p><p>如果暂停，使用<code>createInterface</code>也可以重置<code>input</code>输入流。</p><p>调用<code>createInterface</code>时，如果<code>output</code>设置为<code>null</code>或<code>undefined</code>，不会重新写提示符。  </p><h3>rl.question(query, callback)</h3><p>预先提示<code>query</code>，用户应答后触发<code>callback</code>。给用户显示query后，用户应答被输入后，调用<code>callback</code>。</p><p>如果暂停，使用<code>createInterface</code>也可以重置<code>input</code>输入流。</p><p>调用<code>createInterface</code>时，如果<code>output</code>设置为<code>null</code>或<code>undefined</code>，不会重新写提示符。  </p><p>例子:</p><pre><code class=\"hljs javascript\">interface.question(<span class=\"hljs-string\">'What is your favorite food?'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">answer</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Oh, so your favorite food is '</span> + answer);\n});</code></pre><h3>rl.pause()</h3><p>暂停逐行读取（Readline）的<code>input</code>输入流, 如果需要可以重新启动。</p><p>注意，这不会立即暂停流。调用<code>pause</code>后还会有很多事件触发，包含<code>line</code>。</p><h3>rl.resume()</h3><p>恢复 逐行读取（Readline）<code>input</code>输入流.</p><h3>rl.close()</h3><p>关闭<code>Interface</code>实例, 放弃控制输入输出流。会触发\"close\"事件。</p><h3>rl.write(data[, key])</h3><p>调用<code>createInterface</code>后，将数据<code>data</code>写到<code>output</code>输出流，除非<code>output</code>为<code>null</code>，或未定义<code>undefined</code>。<code>key</code>是一个代表键序列的对象；当终端是一个 TTY 时可用。</p><p>暂停<code>input</code>输入流后，这个方法可以恢复。</p><p>例子：</p><pre><code class=\"hljs javascript\">rl.write(<span class=\"hljs-string\">'Delete me!'</span>);\n<span class=\"hljs-comment\">// Simulate ctrl+u to delete the line written previously</span>\nrl.write(<span class=\"hljs-literal\">null</span>, {ctrl: <span class=\"hljs-literal\">true</span>, name: <span class=\"hljs-string\">'u'</span>});</code></pre><h2 class=\"head2\">Events</h2><h3>事件: 'line'</h3><p><code>function (line) {}</code></p><p><code>input</code>输入流收到<code>\\n</code>后触发，通常因为用户敲回车或返回键。这是监听用户输入的好办法。</p><p>监听<code>line</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'line'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cmd</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'You just typed: '</span>+cmd);\n});</code></pre><h3>事件: 'pause'</h3><p><code>function () {}</code></p><p>暂停<code>input</code>输入流后，会触发这个方法。</p><p>当输入流未被暂停，但收到<code>SIGCONT</code>也会触发。 (详见<code>SIGTSTP</code>和<code>SIGCONT</code>事件)</p><p>监听<code>pause</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'pause'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Readline paused.'</span>);\n});</code></pre><h3>事件: 'resume'</h3><p><code>function () {}</code></p><p>恢复<code>input</code>输入流后，会触发这个方法。</p><p>监听<code>resume</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'resume'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Readline resumed.'</span>);\n});</code></pre><h3>事件: 'close'</h3><p><code>function () {}</code></p><p>调用<code>close()</code>方法时会触发。</p><p>当<code>input</code>输入流收到\"end\"事件时会触发。一旦触发，可以认为<code>Interface</code>实例结束。例如当<code>input</code>输入流收到<code>^D</code>，被当做<code>EOT</code>。</p><p>如果没有<code>SIGINT</code>事件监听器，当<code>input</code> 输入流接收到<code>^C</code>（被当做<code>SIGINT</code>），也会触发这个事件。</p><h3>事件: 'SIGINT'</h3><p><code>function () {}</code></p><p>当<code>input</code>输入流收到<code>^C</code>时会触发， 被当做<code>SIGINT</code>。如果没有<code>SIGINT</code> 事件监听器，当<code>input</code> 输入流接收到<code>SIGINT</code>（被当做<code>SIGINT</code>），会触发 <code>pause</code>事件。</p><p>监听<code>SIGINT</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'SIGINT'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  rl.question(<span class=\"hljs-string\">'Are you sure you want to exit?'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">answer</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (answer.match(<span class=\"hljs-regexp\">/^y(es)?$/i</span>)) rl.pause();\n  });\n});</code></pre><h3>事件: 'SIGTSTP'</h3><p><code>function () {}</code></p><p><strong>Windows 里不可用</strong></p><p>当<code>input</code>输入流收到<code>^Z</code>时会触发，被当做<code>SIGTSTP</code>。如果没有<code>SIGINT</code>事件监听器，当<code>input</code> 输入流接收到<code>SIGTSTP</code>，程序将会切换到后台。</p><p>当程序通过<code>fg</code>恢复，将会触发<code>pause</code>和<code>SIGCONT</code>事件。你可以使用两者中任一事件来恢复流。</p><p>程切换到后台前，如果暂停了流，<code>pause</code>和 <code>SIGCONT</code>事件不会被触发。</p><p>监听<code>SIGTSTP</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'SIGTSTP'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// This will override SIGTSTP and prevent the program from going to the</span>\n  <span class=\"hljs-comment\">// background.</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Caught SIGTSTP.'</span>);\n});</code></pre><h3>事件: 'SIGCONT'</h3><p><code>function () {}</code></p><p><strong>Windows里不可用</strong></p><p>一旦input流中含有^Z并被切换到后台就会触发。被当做<code>SIGTSTP</code>，然后继续执行<code>fg(1)</code>。程切换到后台前，如果流没被暂停，这个事件可以被触发。</p><p>监听<code>SIGCONT</code>的例子:</p><pre><code class=\"hljs javascript\">rl.on(<span class=\"hljs-string\">'SIGCONT'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// `prompt` will automatically resume the stream</span>\n  rl.prompt();\n});</code></pre><h2 class=\"head2\">例子： Tiny CLI</h2><p>以下的例子，展示了如何所有这些方法的命令行接口:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> readline = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'readline'</span>),\n    rl = readline.createInterface(process.stdin, process.stdout);\n\nrl.setPrompt(<span class=\"hljs-string\">'OHAI&gt; '</span>);\nrl.prompt();\n\nrl.on(<span class=\"hljs-string\">'line'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">line</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span>(line.trim()) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'hello'</span>:\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world!'</span>);\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Say what? I might have heard `'</span> + line.trim() + <span class=\"hljs-string\">'`'</span>);\n      <span class=\"hljs-keyword\">break</span>;\n  }\n  rl.prompt();\n}).on(<span class=\"hljs-string\">'close'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Have a great day!'</span>);\n  process.exit(<span class=\"hljs-number\">0</span>);\n});</code></pre><h2 class=\"head2\">readline.cursorTo(stream, x, y)</h2><p>在TTY流里，移动光标到指定位置。</p><h2 class=\"head2\">readline.moveCursor(stream, dx, dy)</h2><p>在TTY流里，移动光标到当前位置的相对位置。</p><h2 class=\"head2\">readline.clearLine(stream, dir)</h2><p>清空TTY流里指定方向的行。<code>dir</code>是以下值：</p><ul><li><code>-1</code>- 从光标到左边</li><li><code>1</code>- 从光标到右边</li><li><code>0</code>- 整行</li></ul><h2 class=\"head2\">readline.clearScreenDown(stream)</h2><p>清空屏幕上从当前光标位置起的内容。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 9,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "7e17c82f01daabb0fb290e0138973017",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js C/C++ 插件",
      "chapter_level_two_url": "/nodejs/o5811itk.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>C/C++ 插件</h2><p>Node.js Addons（插件）是动态链接的共享对象。他提供了C/C++类库能力。这些API比较复杂，他包以下几个类库:<br></p><ul><li><p>V8 JavaScript， C++类库。用来和<a href=\"https://www.w3cschool.cn/javascript/js-intro.html\" target=\"_blank\">JavaScript</a>交互，比如创建对象，调用函数等等。在<code>v8.h</code>头文件中 (目录地址<code>deps/v8/include/v8.h</code>)，线上地址<a rel=\"nofollow\" href=\"http://izs.me/v8-docs/main.html\" target=\"_blank\">online</a>。</p></li><li><p><a rel=\"nofollow\" href=\"https://github.com/joyent/libuv\" target=\"_blank\">libuv</a>，C事件循环库。等待文件描述符变为可读，等待定时器，等待信号时，会和libuv打交道。或者说，如果你需要和I/O打交道，就会用到libuv。</p></li><li><p>内部Node类库。其中最重要的类<code>node::ObjectWrap</code>，你会经常派生自它。</p></li><li>其他的参见<code>deps/</code>。</li></ul><p>Node已经将所有的依赖编译成可以执行文件，所以你不必当心这些类库的链接问题。</p><p>以下所有例子可以在<a rel=\"nofollow\" href=\"https://github.com/rvagg/node-addon-examples\" target=\"_blank\">download</a>下载，也许你可以从中找一个作为你的扩展插件。</p><h2 class=\"head2\">Hello world</h2><p>现在我们来写一个C++插件的小例子，它的效果和以下JS代码一致：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports.hello = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'world'</span>; };</code></pre><p>通过以下代码来创建<code>hello.cc</code>文件:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// hello.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Method</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"world\"</span>));\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports)</span> </span>{\n  NODE_SET_METHOD(exports, <span class=\"hljs-string\">\"hello\"</span>, Method);\n}\n\nNODE_MODULE(addon, init)</code></pre><p>注意：所有的Node插件必须输出一个初始化函数:</p><pre lang=\"html\"><code class=\"html\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Initialize</span> <span class=\"hljs-params\">(Handle&lt;Object&gt; <span class=\"hljs-keyword\">exports</span>)</span></span>;\nNODE_MODULE(module_name, Initialize)</code></pre><p><code>NODE_MODULE</code>之后的代码没有分号，因为它不是一个函数 (参见<code>node.h</code>)。</p><p><code>module_name</code>必须和二进制文件名字一致 (后缀是.node)。</p><p>源文件会编译成<code>addon.node</code>二进制插件。为此我们创建了一个很像JSON的<code>binding.gyp</code>文件，它包含配置信息，这个文件用<a rel=\"nofollow\" href=\"https://github.com/TooTallNate/node-gyp\" target=\"_blank\">node-gyp</a>编译。</p><pre><code class=\"hljs json\">{\n  <span class=\"hljs-attr\">\"targets\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"target_name\"</span>: <span class=\"hljs-string\">\"addon\"</span>,\n      <span class=\"hljs-attr\">\"sources\"</span>: [ <span class=\"hljs-string\">\"hello.cc\"</span> ]\n    }\n  ]\n}</code></pre><p>下一步创建一个<code>node-gyp configure</code>工程，在平台上生成这些文件。</p><p>创建后，在<code>build/</code>文件夹里拥有一个<code>Makefile</code> (Unix系统) 文件或者<code>vcxproj</code>文件(Windows 系统)。接着调用<code>node-gyp build</code>命令编译，生成<code>.node</code>文件。这些文件位于<code>build/Release/</code>目录里。</p><p>现在，你能在Node工程中使用这些二进制扩展插件，在<code>hello.js</code>中声明<code>require</code>之前编译的<code>hello.node</code>:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// hello.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(addon.hello()); <span class=\"hljs-comment\">// 'world'</span></code></pre><p>更多的信息请参考<a rel=\"nofollow\" href=\"https://github.com/arturadib/node-qt\" target=\"_blank\">https://github.com/arturadib/node-qt</a> 。</p><h2 class=\"head2\">插件模式</h2><p>下面是一些addon插件的模式，帮助你开始编码。<a rel=\"nofollow\" href=\"http://izs.me/v8-docs/main.html\" target=\"_blank\">v8 reference</a>文档里包含v8的各种接口，<a rel=\"nofollow\" href=\"http://code.google.com/apis/v8/embed.html\" target=\"_blank\">Embedder's Guide</a>这个文档包含各种说明，比如handles, scopes, function templates等等。</p><p>在使用这些例子前，你需要先用<code>node-gyp</code>编译。创建<code>binding.gyp</code> 文件:</p><pre><code class=\"hljs json\">{\n  <span class=\"hljs-attr\">\"targets\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"target_name\"</span>: <span class=\"hljs-string\">\"addon\"</span>,\n      <span class=\"hljs-attr\">\"sources\"</span>: [ <span class=\"hljs-string\">\"addon.cc\"</span> ]\n    }\n  ]\n}</code></pre><p>将文件名加入到<code>sources</code>数组里就可以使用多个<code>.cc</code>文件，例如 :</p><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">\"sources\"</span>: [<span class=\"hljs-string\">\"addon.cc\"</span>, <span class=\"hljs-string\">\"myexample.cc\"</span>]</code></pre><p>准备好<code>binding.gyp</code>文件后, 你就能配置并编译插件:</p><pre><code class=\"hljs ruby\">$ node-gyp configure build</code></pre><h3>函数参数</h3><p>从以下模式中解释了如何从JavaScript函数中读取参数，并返回结果。仅需要一个<code>addon.cc</code>文件:</p><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-comment\">#include &lt;node.h&gt;</span>\n\nusing <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">v8</span>;\n\nvoid Add(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">if</span> (args.Length() &lt; <span class=\"hljs-number\">2</span>) {\n    isolate-&gt;ThrowException(<span class=\"hljs-keyword\">Exception</span>::TypeError(\n        String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"Wrong number of arguments\"</span>)));\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (!args[<span class=\"hljs-number\">0</span>]-&gt;IsNumber() || !args[<span class=\"hljs-number\">1</span>]-&gt;IsNumber()) {\n    isolate-&gt;ThrowException(<span class=\"hljs-keyword\">Exception</span>::TypeError(\n        String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"Wrong arguments\"</span>)));\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  double value = args[<span class=\"hljs-number\">0</span>]-&gt;NumberValue() + args[<span class=\"hljs-number\">1</span>]-&gt;NumberValue();\n  Local&lt;Number&gt; num = Number::New(isolate, value);\n\n  args.GetReturnValue().Set(num);\n}\n\nvoid Init(Handle&lt;Object&gt; exports) {\n  NODE_SET_METHOD(exports, <span class=\"hljs-string\">\"add\"</span>, Add);\n}\n\nNODE_MODULE(addon, Init)</code></pre><p>可以用以下的JavaScript代码片段测试：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">'This should be eight:'</span>, addon.add(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>) );</code></pre><h3>回调Callbacks</h3><p>你也能传JavaScript函数给C++函数，并执行它。在<code>addon.cc</code>中:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">RunCallback</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n\n  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">unsigned</span> argc = <span class=\"hljs-number\">1</span>;\n  Local&lt;Value&gt; argv[argc] = { String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"hello world\"</span>) };\n  cb-&gt;Call(isolate-&gt;GetCurrentContext()-&gt;Global(), argc, argv);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; <span class=\"hljs-keyword\">module</span>)</span> </span>{\n  NODE_SET_METHOD(<span class=\"hljs-keyword\">module</span>, <span class=\"hljs-string\">\"exports\"</span>, RunCallback);\n}\n\nNODE_MODULE(addon, Init)</code></pre><p>注意，这个例子中使用了<code>Init()</code>里的2个参数，<code>module</code>对象是第二个参数。它允许addon使用一个函数完全重写<code>exports</code>。</p><p>可以用以下的代码来测试：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\naddon(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>)</span>{\n  <span class=\"hljs-built_in\">console</span>.log(msg); <span class=\"hljs-comment\">// 'hello world'</span>\n});</code></pre><h3>对象工厂</h3><p>在<code>addon.cc</code>模式里，你能用C++函数创建并返回一个新的对象，这个对象所包含的<code>msg</code>属性是由<code>createObject()</code>函数传入:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CreateObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n\n  Local&lt;Object&gt; obj = Object::New(isolate);\n  obj-&gt;Set(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"msg\"</span>), args[<span class=\"hljs-number\">0</span>]-&gt;ToString());\n\n  args.GetReturnValue().Set(obj);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; <span class=\"hljs-keyword\">module</span>)</span> </span>{\n  NODE_SET_METHOD(<span class=\"hljs-keyword\">module</span>, <span class=\"hljs-string\">\"exports\"</span>, CreateObject);\n}\n\nNODE_MODULE(addon, Init)</code></pre><p>使用JavaScript测试:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-keyword\">var</span> obj1 = addon(<span class=\"hljs-string\">'hello'</span>);\n<span class=\"hljs-keyword\">var</span> obj2 = addon(<span class=\"hljs-string\">'world'</span>);\n<span class=\"hljs-built_in\">console</span>.log(obj1.msg+<span class=\"hljs-string\">' '</span>+obj2.msg); <span class=\"hljs-comment\">// 'hello world'</span></code></pre><h3>工厂模式</h3><p>这个模式里展示了如何创建并返回一个JavaScript函数，它是由C++函数包装的 :</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">MyFunction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n  args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"hello world\"</span>));\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CreateFunction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, MyFunction);\n  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();\n\n  <span class=\"hljs-comment\">// omit this to make it anonymous</span>\n  fn-&gt;SetName(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"theFunction\"</span>));\n\n  args.GetReturnValue().Set(fn);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; <span class=\"hljs-keyword\">module</span>)</span> </span>{\n  NODE_SET_METHOD(<span class=\"hljs-keyword\">module</span>, <span class=\"hljs-string\">\"exports\"</span>, CreateFunction);\n}\n\nNODE_MODULE(addon, Init)</code></pre><p>测试:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-keyword\">var</span> fn = addon();\n<span class=\"hljs-built_in\">console</span>.log(fn()); <span class=\"hljs-comment\">// 'hello world'</span></code></pre><h3>包装C++对象</h3><p>以下会创建一个C++对象的包装<code>MyObject</code>，这样他就能在JavaScript中用<code>new</code>实例化。首先在<code>addon.cc</code>中准备主要模块:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">\"myobject.h\"</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitAll</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports)</span> </span>{\n  MyObject::Init(exports);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre><p>接着在<code>myobject.h</code>创建包装，它继承自<code>node::ObjectWrap</code>:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// myobject.h</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> MYOBJECT_H</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MYOBJECT_H</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node_object_wrap.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">class</span> MyObject : <span class=\"hljs-keyword\">public</span> node::ObjectWrap {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(v8::Handle&lt;v8::Object&gt; exports)</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">MyObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> value = <span class=\"hljs-number\">0</span>)</span></span>;\n  ~MyObject();\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PlusOne</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-keyword\">static</span> v8::Persistent&lt;v8::Function&gt; constructor;\n  <span class=\"hljs-keyword\">double</span> value_;\n};\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span></code></pre><p>在<code>myobject.cc</code>中实现各种暴露的方法，通过给构造函数添加prototype属性来暴露<code>plusOne</code>方法:</p><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// myobject.cc</span>\n<span class=\"hljs-comment\">#include \"myobject.h\"</span>\n\nusing <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">v8</span>;\n\nPersistent&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">MyObject</span>::<span class=\"hljs-title\">constructor</span></span>;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Handle&lt;Object&gt; exports) {\n  Isolate* isolate = Isolate::GetCurrent();\n\n  <span class=\"hljs-comment\">// Prepare constructor template</span>\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, <span class=\"hljs-keyword\">New</span>);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"MyObject\"</span>));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-comment\">// Prototype</span>\n  NODE_SET_PROTOTYPE_METHOD(tpl, <span class=\"hljs-string\">\"plusOne\"</span>, PlusOne);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n  exports-&gt;Set(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"MyObject\"</span>),\n               tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">if</span> (args.IsConstructCall()) {\n    <span class=\"hljs-comment\">// Invoked as constructor: `new MyObject(...)`</span>\n    double value = args[<span class=\"hljs-number\">0</span>]-&gt;IsUndefined() ? <span class=\"hljs-number\">0</span> : args[<span class=\"hljs-number\">0</span>]-&gt;NumberValue();\n    MyObject* obj = <span class=\"hljs-keyword\">new</span> MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Invoked as plain function `MyObject(...)`, turn into construct call.</span>\n    <span class=\"hljs-keyword\">const</span> int argc = <span class=\"hljs-number\">1</span>;\n    Local&lt;Value&gt; argv[argc] = { args[<span class=\"hljs-number\">0</span>] };\n    Local&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">cons</span> = <span class=\"hljs-title\">Local</span>&lt;<span class=\"hljs-title\">Function</span>&gt;::<span class=\"hljs-title\">New</span><span class=\"hljs-params\">(isolate, constructor)</span></span>;\n    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));\n  }\n}\n\nvoid MyObject::PlusOne(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());\n  obj-&gt;value_ += <span class=\"hljs-number\">1</span>;\n\n  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));\n}</code></pre><p>测试:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> addon.MyObject(<span class=\"hljs-number\">10</span>);\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 11</span>\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 12</span>\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 13</span></code></pre><h3>包装对象工厂</h3><p>当你想创建本地对象，又不想在JavaScript中严格的使用<code>new</code>初始化的时候，以下方法非常实用：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> obj = addon.createObject();\n<span class=\"hljs-comment\">// instead of:</span>\n<span class=\"hljs-comment\">// var obj = new addon.Object();</span></code></pre><p>在<code>addon.cc</code>中注册<code>createObject</code>方法:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">\"myobject.h\"</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CreateObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n  MyObject::NewInstance(args);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitAll</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; <span class=\"hljs-keyword\">module</span>)</span> </span>{\n  MyObject::Init();\n\n  NODE_SET_METHOD(<span class=\"hljs-keyword\">module</span>, <span class=\"hljs-string\">\"exports\"</span>, CreateObject);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre><p>在<code>myobject.h</code>中有静态方法<code>NewInstance</code>，他能实例化对象（它就像JavaScript的<code>new</code>):</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// myobject.h</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> MYOBJECT_H</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MYOBJECT_H</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node_object_wrap.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">class</span> MyObject : <span class=\"hljs-keyword\">public</span> node::ObjectWrap {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">()</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">NewInstance</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">MyObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> value = <span class=\"hljs-number\">0</span>)</span></span>;\n  ~MyObject();\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PlusOne</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-keyword\">static</span> v8::Persistent&lt;v8::Function&gt; constructor;\n  <span class=\"hljs-keyword\">double</span> value_;\n};\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span></code></pre><p>这个实现方法和<code>myobject.cc</code>类似:</p><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// myobject.cc</span>\n<span class=\"hljs-comment\">#include &lt;node.h&gt;</span>\n<span class=\"hljs-comment\">#include \"myobject.h\"</span>\n\nusing <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">v8</span>;\n\nPersistent&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">MyObject</span>::<span class=\"hljs-title\">constructor</span></span>;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-comment\">// Prepare constructor template</span>\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, <span class=\"hljs-keyword\">New</span>);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"MyObject\"</span>));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-comment\">// Prototype</span>\n  NODE_SET_PROTOTYPE_METHOD(tpl, <span class=\"hljs-string\">\"plusOne\"</span>, PlusOne);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">if</span> (args.IsConstructCall()) {\n    <span class=\"hljs-comment\">// Invoked as constructor: `new MyObject(...)`</span>\n    double value = args[<span class=\"hljs-number\">0</span>]-&gt;IsUndefined() ? <span class=\"hljs-number\">0</span> : args[<span class=\"hljs-number\">0</span>]-&gt;NumberValue();\n    MyObject* obj = <span class=\"hljs-keyword\">new</span> MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Invoked as plain function `MyObject(...)`, turn into construct call.</span>\n    <span class=\"hljs-keyword\">const</span> int argc = <span class=\"hljs-number\">1</span>;\n    Local&lt;Value&gt; argv[argc] = { args[<span class=\"hljs-number\">0</span>] };\n    Local&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">cons</span> = <span class=\"hljs-title\">Local</span>&lt;<span class=\"hljs-title\">Function</span>&gt;::<span class=\"hljs-title\">New</span><span class=\"hljs-params\">(isolate, constructor)</span></span>;\n    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));\n  }\n}\n\nvoid MyObject::NewInstance(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">const</span> unsigned argc = <span class=\"hljs-number\">1</span>;\n  Handle&lt;Value&gt; argv[argc] = { args[<span class=\"hljs-number\">0</span>] };\n  Local&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">cons</span> = <span class=\"hljs-title\">Local</span>&lt;<span class=\"hljs-title\">Function</span>&gt;::<span class=\"hljs-title\">New</span><span class=\"hljs-params\">(isolate, constructor)</span></span>;\n  Local&lt;Object&gt; instance = cons-&gt;NewInstance(argc, argv);\n\n  args.GetReturnValue().Set(instance);\n}\n\nvoid MyObject::PlusOne(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());\n  obj-&gt;value_ += <span class=\"hljs-number\">1</span>;\n\n  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));\n}</code></pre><p>测试:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> createObject = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-keyword\">var</span> obj = createObject(<span class=\"hljs-number\">10</span>);\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 11</span>\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 12</span>\n<span class=\"hljs-built_in\">console</span>.log( obj.plusOne() ); <span class=\"hljs-comment\">// 13</span>\n\n<span class=\"hljs-keyword\">var</span> obj2 = createObject(<span class=\"hljs-number\">20</span>);\n<span class=\"hljs-built_in\">console</span>.log( obj2.plusOne() ); <span class=\"hljs-comment\">// 21</span>\n<span class=\"hljs-built_in\">console</span>.log( obj2.plusOne() ); <span class=\"hljs-comment\">// 22</span>\n<span class=\"hljs-built_in\">console</span>.log( obj2.plusOne() ); <span class=\"hljs-comment\">// 23</span></code></pre><h3>传递包装对象</h3><p>除了包装并返回C++对象，你可以使用Node的<code>node::ObjectWrap::Unwrap</code>帮助函数来解包。在下面的<code>addon.cc</code>中，我们介绍了一个<code>add()</code>函数，它能获取2个 <code>MyObject</code>对象：</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// addon.cc</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node_object_wrap.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">\"myobject.h\"</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> v8;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CreateObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n  MyObject::NewInstance(args);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>{\n  Isolate* isolate = Isolate::GetCurrent();\n  <span class=\"hljs-function\">HandleScope <span class=\"hljs-title\">scope</span><span class=\"hljs-params\">(isolate)</span></span>;\n\n  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[<span class=\"hljs-number\">0</span>]-&gt;ToObject());\n  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[<span class=\"hljs-number\">1</span>]-&gt;ToObject());\n\n  <span class=\"hljs-keyword\">double</span> sum = obj1-&gt;value() + obj2-&gt;value();\n  args.GetReturnValue().Set(Number::New(isolate, sum));\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">InitAll</span><span class=\"hljs-params\">(Handle&lt;Object&gt; exports)</span> </span>{\n  MyObject::Init();\n\n  NODE_SET_METHOD(exports, <span class=\"hljs-string\">\"createObject\"</span>, CreateObject);\n  NODE_SET_METHOD(exports, <span class=\"hljs-string\">\"add\"</span>, Add);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre><p>介绍<code>myobject.h</code>里的一个公开方法，它能在解包后使用私有变量:</p><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// myobject.h</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">ifndef</span> MYOBJECT_H</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> MYOBJECT_H</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;node_object_wrap.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">class</span> MyObject : <span class=\"hljs-keyword\">public</span> node::ObjectWrap {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">()</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">NewInstance</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">value</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> value_; }\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">MyObject</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> value = <span class=\"hljs-number\">0</span>)</span></span>;\n  ~MyObject();\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args)</span></span>;\n  <span class=\"hljs-keyword\">static</span> v8::Persistent&lt;v8::Function&gt; constructor;\n  <span class=\"hljs-keyword\">double</span> value_;\n};\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">endif</span></span></code></pre><p><code>myobject.cc</code>的实现方法和之前的类似:</p><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// myobject.cc</span>\n<span class=\"hljs-comment\">#include &lt;node.h&gt;</span>\n<span class=\"hljs-comment\">#include \"myobject.h\"</span>\n\nusing <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">v8</span>;\n\nPersistent&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">MyObject</span>::<span class=\"hljs-title\">constructor</span></span>;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  Isolate* isolate = Isolate::GetCurrent();\n\n  <span class=\"hljs-comment\">// Prepare constructor template</span>\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, <span class=\"hljs-keyword\">New</span>);\n  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, <span class=\"hljs-string\">\"MyObject\"</span>));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(<span class=\"hljs-number\">1</span>);\n\n  constructor.Reset(isolate, tpl-&gt;GetFunction());\n}\n\nvoid MyObject::New(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">if</span> (args.IsConstructCall()) {\n    <span class=\"hljs-comment\">// Invoked as constructor: `new MyObject(...)`</span>\n    double value = args[<span class=\"hljs-number\">0</span>]-&gt;IsUndefined() ? <span class=\"hljs-number\">0</span> : args[<span class=\"hljs-number\">0</span>]-&gt;NumberValue();\n    MyObject* obj = <span class=\"hljs-keyword\">new</span> MyObject(value);\n    obj-&gt;Wrap(args.This());\n    args.GetReturnValue().Set(args.This());\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Invoked as plain function `MyObject(...)`, turn into construct call.</span>\n    <span class=\"hljs-keyword\">const</span> int argc = <span class=\"hljs-number\">1</span>;\n    Local&lt;Value&gt; argv[argc] = { args[<span class=\"hljs-number\">0</span>] };\n    Local&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">cons</span> = <span class=\"hljs-title\">Local</span>&lt;<span class=\"hljs-title\">Function</span>&gt;::<span class=\"hljs-title\">New</span><span class=\"hljs-params\">(isolate, constructor)</span></span>;\n    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));\n  }\n}\n\nvoid MyObject::NewInstance(<span class=\"hljs-keyword\">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Isolate* isolate = Isolate::GetCurrent();\n  HandleScope scope(isolate);\n\n  <span class=\"hljs-keyword\">const</span> unsigned argc = <span class=\"hljs-number\">1</span>;\n  Handle&lt;Value&gt; argv[argc] = { args[<span class=\"hljs-number\">0</span>] };\n  Local&lt;<span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&gt; <span class=\"hljs-title\">cons</span> = <span class=\"hljs-title\">Local</span>&lt;<span class=\"hljs-title\">Function</span>&gt;::<span class=\"hljs-title\">New</span><span class=\"hljs-params\">(isolate, constructor)</span></span>;\n  Local&lt;Object&gt; instance = cons-&gt;NewInstance(argc, argv);\n\n  args.GetReturnValue().Set(instance);\n}</code></pre><p>测试:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// test.js</span>\n<span class=\"hljs-keyword\">var</span> addon = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./build/Release/addon'</span>);\n\n<span class=\"hljs-keyword\">var</span> obj1 = addon.createObject(<span class=\"hljs-number\">10</span>);\n<span class=\"hljs-keyword\">var</span> obj2 = addon.createObject(<span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">var</span> result = addon.add(obj1, obj2);\n\n<span class=\"hljs-built_in\">console</span>.log(result); <span class=\"hljs-comment\">// 30</span></code></pre></div><h2>相关教程</h2><p>如果你想了解更多与C++相关的知识，则可以参考本站的<a href=\"https://www.w3cschool.cn/cpp/cpp-intro.html\" target=\"_blank\">《C++教程》</a>！</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 8,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "677db4686ba74ad646a368463d0f3469",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js Query Strings",
      "chapter_level_two_url": "/nodejs/j9xh1itj.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Query String</h2><p>本节为你介绍Node.js Query Strings。</p><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>该Node.js模块提供了一些处理query strings的工具，你可以通过以下方式访问它：</p><pre><code>const querystring = require('querystring');</code></pre><p>Node.js Query Strings包含的方法如下：</p><h3>querystring.stringify(obj[, sep][, eq][, options])</h3><p>该方法可以将一个对象序列化化为一个query string 。</p><p>可以选择重写默认的分隔符(<code>'&amp;'</code>) 和分配符 (<code>'='</code>)。</p><p>Options对象可能包含<code>encodeURIComponent</code>属性 (默认：<code>querystring.escape</code>)，如果需要，它可以用<code>non-utf8</code>编码字符串。</p><p>例子:</p><pre><code class=\"hljs javascript\">querystring.stringify({ foo: <span class=\"hljs-string\">'bar'</span>, baz: [<span class=\"hljs-string\">'qux'</span>, <span class=\"hljs-string\">'quux'</span>], corge: <span class=\"hljs-string\">''</span> })\n<span class=\"hljs-comment\">// returns</span>\n<span class=\"hljs-string\">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='</span>\n\nquerystring.stringify({foo: <span class=\"hljs-string\">'bar'</span>, baz: <span class=\"hljs-string\">'qux'</span>}, <span class=\"hljs-string\">';'</span>, <span class=\"hljs-string\">':'</span>)\n<span class=\"hljs-comment\">// returns</span>\n<span class=\"hljs-string\">'foo:bar;baz:qux'</span>\n\n<span class=\"hljs-comment\">// Suppose gbkEncodeURIComponent function already exists,</span>\n<span class=\"hljs-comment\">// it can encode string with `gbk` encoding</span>\nquerystring.stringify({ w: <span class=\"hljs-string\">'中文'</span>, foo: <span class=\"hljs-string\">'bar'</span> }, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>,\n  { <span class=\"hljs-built_in\">encodeURIComponent</span>: gbkEncodeURIComponent })\n<span class=\"hljs-comment\">// returns</span>\n<span class=\"hljs-string\">'w=%D6%D0%CE%C4&amp;foo=bar'</span></code></pre><h3>querystring.parse(str[, sep][, eq][, options])</h3><p>该方法可以将query string反序列化为对象。  </p><p>你可以选择重写默认的分隔符(<code>'&amp;'</code>) 和分配符 (<code>'='</code>)。</p><p>Options对象可能包含<code>maxKeys</code>属性（默认：1000），用来限制处理过的健值（keys）。设置为0的话，可以去掉键值的数量限制。</p><p>Options 对象可能包含<code>decodeURIComponent</code>属性（默认：<code>querystring.unescape</code>），如果需要，可以用来解码<code>non-utf8</code>编码的字符串。</p><p>例子:</p><pre><code class=\"hljs javascript\">querystring.parse(<span class=\"hljs-string\">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge'</span>)\n<span class=\"hljs-comment\">// returns</span>\n{ foo: <span class=\"hljs-string\">'bar'</span>, baz: [<span class=\"hljs-string\">'qux'</span>, <span class=\"hljs-string\">'quux'</span>], corge: <span class=\"hljs-string\">''</span> }\n\n<span class=\"hljs-comment\">// Suppose gbkDecodeURIComponent function already exists,</span>\n<span class=\"hljs-comment\">// it can decode `gbk` encoding string</span>\nquerystring.parse(<span class=\"hljs-string\">'w=%D6%D0%CE%C4&amp;foo=bar'</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>,\n  { <span class=\"hljs-built_in\">decodeURIComponent</span>: gbkDecodeURIComponent })\n<span class=\"hljs-comment\">// returns</span>\n{ w: <span class=\"hljs-string\">'中文'</span>, foo: <span class=\"hljs-string\">'bar'</span> }</code></pre><h3>querystring.escape</h3><p>escape函数供<code>querystring.stringify</code>使用，必要时，可以重写。</p><h3>querystring.unescape</h3><p>unescape函数供<code>querystring.parse</code>使用。必要时，可以重写。</p><p>首先会尝试用<code>decodeURIComponent</code>，如果失败，会回退，不会抛出格式不正确的URLs。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 7,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b0e8d7ac9f757599d147a7f67cf300f3",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 文件系统",
      "chapter_level_two_url": "/nodejs/hzpd1iti.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>文件系统</h2><p>Node.js官方文档对Node.js文件系统进行了详细的介绍。</p><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>Node.js文件系统模块是一个封装了标准的POSIX文件I/O操作的集合。通过<code>require('fs')</code>使用这个模块，其中所有的方法都有同步和异步两种模式。</p><p>异步方法最后一个参数都是回调函数，这个回调的参数取决于方法，不过第一个参数一般都是异常。如果操作成功，那么第一个参数就是<code>null</code>或<code>undefined</code>。</p><p>当使用一个同步操作的时候，任意的异常都立即抛出，可以用try/catch来处理异常，使得程序正常运行。</p><p>以下是一个异步操作的例子:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span></span> fs = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'fs'</span></span></span></span>);\n\nfs.unlink(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/hello'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'successfully deleted /tmp/hello'</span></span></span></span>);\n});</code></pre><p>以下是一个同步操作的例子:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span></span> fs = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'fs'</span></span></span></span>);\n\nfs.unlinkSync(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/hello'</span></span></span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'successfully deleted /tmp/hello'</span></span></span></span>);</code></pre><p>异步方法不能保证操作顺序，因此下面的例子很容易出错：</p><pre><code class=\"hljs javascript\">fs.rename(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/hello'</span></span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/world'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'renamed complete'</span></span></span></span>);\n});\nfs.stat(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/world'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, stats</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stats: '</span></span></span></span> + <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">JSON</span></span></span></span>.stringify(stats));\n});</code></pre><p>该例子出错的原因很可能是因为先执行了<code>fs.stat</code>方法，正确的方法如下：</p><pre><code class=\"hljs javascript\">fs.rename(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/hello'</span></span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/world'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  fs.stat(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/tmp/world'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, stats</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'stats: '</span></span></span></span> + <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">JSON</span></span></span></span>.stringify(stats));\n  });\n});</code></pre><p>在繁忙的进程里，强烈建议使用异步方法。同步方法会阻塞整个进程，直到方法完成。</p><p>可能会用到相对路径，路径是相对<code>process.cwd()</code>来说的。</p><p>大部分fs函数会忽略回调参数，如果忽略，将会用默认函数抛出异常。如果想得到原调用点的堆栈信息，需要设置环境变量NODE_DEBUG：</p><pre><code class=\"hljs javascript\">$ cat script.js\n<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> </span></span></span><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\"><span class=\"hljs-function\"><span class=\"hljs-title\">bad</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span></span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span></span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'fs'</span></span></span></span>).readFile(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/'</span></span></span></span>);\n}\nbad();\n\n$ env NODE_DEBUG=fs node script.js\nfs.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">66</span></span></span></span>\n        <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n              ^\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">Error</span></span></span></span>: EISDIR, read\n    at rethrow (fs.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">61</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">21</span></span></span></span>)\n    at maybeCallback (fs.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">79</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">42</span></span></span></span>)\n    at <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">Object</span></span></span></span>.fs.readFile (fs.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">153</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">18</span></span></span></span>)\n    at bad (<span class=\"hljs-regexp\"><span class=\"hljs-regexp\"><span class=\"hljs-regexp\"><span class=\"hljs-regexp\">/path/</span></span></span></span>to/script.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">17</span></span></span></span>)\n    at <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">Object</span></span></span></span>.&lt;anonymous&gt; (<span class=\"hljs-regexp\"><span class=\"hljs-regexp\"><span class=\"hljs-regexp\"><span class=\"hljs-regexp\">/path/</span></span></span></span>to/script.js:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span></span></span>)\n    &lt;etc.&gt;</code></pre><h2>fs.rename(oldPath, newPath, callback)</h2><p>异步函数rename(2)。回调函数只有一个参数：可能出现的异常。  </p><h2>fs.renameSync(oldPath, newPath)</h2><p>同步函数rename(2)。 返回<code>undefined</code>。</p><h2>fs.ftruncate(fd, len, callback)</h2><p>异步函数ftruncate(2)。 回调函数只有一个参数：可能出现的异常。</p><h2>fs.ftruncateSync(fd, len)</h2><p>同步函数ftruncate(2)。 返回<code>undefined</code>。</p><h2>fs.truncate(path, len, callback)</h2><p>异步函数truncate(2)。 回调函数只有一个参数：可能出现的异常。 文件描述符也可以作为第一个参数，如果这种情况，调用<code>fs.ftruncate()</code> 。</p><h2>fs.truncateSync(path, len)</h2><p>同步函数truncate(2)。 返回<code>undefined</code>。</p><h2>fs.chown(path, uid, gid, callback)</h2><p>异步函数chown(2)。回调函数只有一个参数：可能出现的异常。</p><h2>fs.chownSync(path, uid, gid)</h2><p>同步函数chown(2)。返回<code>undefined</code>。</p><h2>fs.fchown(fd, uid, gid, callback)</h2><p>异步函数fchown(2)。回调函数只有一个参数：可能出现的异常。</p><h2>fs.fchownSync(fd, uid, gid)</h2><p>同步函数 fchown(2)。返回<code>undefined</code>。</p><h2>fs.lchown(path, uid, gid, callback)</h2><p>异步函数lchown(2)。回调函数只有一个参数：可能出现的异常。</p><h2>fs.lchownSync(path, uid, gid)</h2><p>同步函数lchown(2)。返回<code>undefined</code>。</p><h2>fs.chmod(path, mode, callback)</h2><p>异步函数chmod(2)。回调函数只有一个参数：可能出现的异常。</p><h2>fs.chmodSync(path, mode)</h2><p>同步函数chmod(2)。返回 <code>undefined</code>。</p><h2>fs.fchmod(fd, mode, callback)</h2><p>异步函数fchmod(2)。回调函数只有一个参数：可能出现的异常。</p><h2>fs.fchmodSync(fd, mode)</h2><p>同步函数fchmod(2)。返回<code>undefined</code>。</p><h2>fs.lchmod(path, mode, callback)</h2><p>异步函数 lchmod(2)。回调函数只有一个参数：可能出现的异常。</p><p>仅在Mac OS X可用。</p><h2>fs.lchmodSync(path, mode)</h2><p>同步函数lchmod(2)。返回<code>undefined</code>。</p><h2>fs.stat(path, callback)</h2><p>异步函数stat(2)。回调函数有两个参数：(err, stats) ，其中<code>stats</code>是一个<code>fs.Stats</code>对象。 详情请参考fs.Stats。  </p><h2 class=\"head2\">fs.lstat(path, callback)</h2><p>异步函数lstat(2)。回调函数有两个参数：(err, stats) ，其中<code>stats</code>是一个<code>fs.Stats</code>对象。<code>lstat()</code>与<code>stat()</code>基本相同，区别在于，如果<code>path</code>是链接，读取的是链接本身，而不是它所链接到的文件。</p><h2 class=\"head2\">fs.fstat(fd, callback)</h2><p>异步函数fstat(2)。回调函数有两个参数： (err, stats)，其中<code>stats</code>是一个<code>fs.Stats</code>对象。 </p><h2 class=\"head2\">fs.statSync(path)</h2><p>同步函数stat(2)。返回<code>fs.Stats</code>实例。</p><h2 class=\"head2\">fs.lstatSync(path)</h2><p>同步函数lstat(2)。返回<code>fs.Stats</code>实例。</p><h2 class=\"head2\">fs.fstatSync(fd)</h2><p>同步函数fstat(2)。返回<code>fs.Stats</code>实例。</p><h2 class=\"head2\">fs.link(srcpath, dstpath, callback)</h2><p>异步函数link(2)。回调函数只有一个参数：可能出现的异常。</p><h2 class=\"head2\">fs.linkSync(srcpath, dstpath)</h2><p>同步函数link(2)。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.symlink(srcpath, dstpath[, type], callback)</h2><p>异步函数symlink(2)。回调函数只有一个参数：可能出现的异常。</p><p><code>type</code>可能是<code>'dir'</code>,<code>'file'</code>, 或<code>'junction'</code> (默认<code>'file'</code>) ，仅在Windows（不考虑其他系统）有效。注意， Windows junction要求目的地址需要绝对的。当使用<code>'junction'</code>的时候，<code>destination</code>参数将会自动转换为绝对路径。</p><h2 class=\"head2\">fs.symlinkSync(srcpath, dstpath[, type])</h2><p>同步函数symlink(2)。 返回<code>undefined</code>。</p><h2 class=\"head2\">fs.readlink(path, callback)</h2><p>异步函数readlink(2)。回调函数有2个参数<code>(err, linkString)</code>.</p><h2 class=\"head2\">fs.readlinkSync(path)</h2><p>同步函数readlink(2)。返回符号链接的字符串值。</p><h2 class=\"head2\">fs.realpath(path[, cache], callback)</h2><p>异步函数realpath(2)。回调函数有2个参数<code>(err,resolvedPath)</code>。可以使用<code>process.cwd</code>来解决相对路径问题。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span></span></span> cache = {<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/etc'</span></span></span></span>:<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/private/etc'</span></span></span></span>};\nfs.realpath(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/etc/passwd'</span></span></span></span>, cache, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, resolvedPath</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(resolvedPath);\n});</code></pre><h2 class=\"head2\">fs.realpathSync(path[, cache])</h2><p>同步函数realpath(2)。返回解析出的路径。</p><h2 class=\"head2\">fs.unlink(path, callback)</h2><p>异步函数unlink(2)。回调函数只有一个参数：可能出现的异常.</p><h2 class=\"head2\">fs.unlinkSync(path)</h2><p>同步函数unlink(2)。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.rmdir(path, callback)</h2><p>异步函数rmdir(2)。回调函数只有一个参数：可能出现的异常.</p><h2 class=\"head2\">fs.rmdirSync(path)</h2><p>同步函数rmdir(2)。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.mkdir(path[, mode], callback)</h2><p>异步函数mkdir(2)。回调函数只有一个参数：可能出现的异常. <code>mode</code>默认为<code>0777</code>.</p><h2 class=\"head2\">fs.mkdirSync(path[, mode])</h2><p>同步函数mkdir(2)。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.readdir(path, callback)</h2><p>异步函数readdir(3)。读取文件夹的内容。回调有2个参数 <code>(err, files)</code>files是文件夹里除了名字为'.'和'..'之外的所有文件名。</p><h2 class=\"head2\">fs.readdirSync(path)</h2><p>同步函数readdir(3)。返回除了文件名为<code>'.'</code>和<code>'..'</code>之外的所有文件.</p><h2 class=\"head2\">fs.close(fd, callback)</h2><p>异步函数close(2)。回调函数只有一个参数：可能出现的异常.</p><h2 class=\"head2\">fs.closeSync(fd)</h2><p>同步函数close(2)。返回 <code>undefined</code>。</p><h2 class=\"head2\">fs.open(path, flags[, mode], callback)</h2><p>异步函数file open. 参见open(2)。<code>flags</code>是:</p><ul><li><p><code>'r'</code>- 以只读模式打开；如果文件不存在，抛出异常。</p></li><li><p><code>'r+'</code>-以读写模式打开；如果文件不存在，抛出异常。</p></li><li><p><code>'rs'</code>- 同步的，以只读模式打开；指令绕过操作系统直接使用本地文件系统缓存。这个功能主要用来打开NFS挂载的文件，因为它能让你跳过可能过时的本地缓存。如果对I/O性能很在乎，就不要使用这个标志位。</p><p>这里不是调用<code>fs.open()</code>变成同步阻塞请求，如果你想要这样，可以调用<code>fs.openSync()</code>。</p></li><li><p><code>'rs+'</code>- 同步模式下以读写方式打开文件。注意事项参见<code>'rs'</code>.</p></li><li><p><code>'w'</code>- 以只写模式打开。文件会被创建 (如果文件不存在) 或者覆盖 (如果存在)。</p></li><li><p><code>'wx'</code>- 和<code>'w'</code>类似，如果文件存储操作失败</p></li><li><p><code>'w+'</code>- 以可读写方式打开。文件会被创建 (如果文件不存在) 或者覆盖 (如果存在)  </p></li><li><p><code>'wx+'</code>- 和<code>'w+'</code>类似，如果文件存储操作失败。</p></li><li><p><code>'a'</code>- 以附加的形式打开。如果文件不存在则创建一个。</p></li><li><p><code>'ax'</code>- 和<code>'a'</code>类似，如果文件存储操作失败。</p></li><li><p><code>'a+'</code>- 以只读和附加的形式打开文件.若文件不存在，则会建立该文件</p></li><li><code>'ax+'</code>- 和<code>'a+'</code>类似，如果文件存储操作失败.</li></ul><p>如果文件存在，参数<code>mode</code>设置文件模式 (permission和sticky bits)。 默认是<code>0666</code>，可读写。</p><p>回调有2个参数<code>(err, fd)</code>.</p><p>排除标记<code>'x'</code>(对应open(2)的<code>O_EXCL</code>标记) 保证<code>path</code>是新创建的。在POSIX系统里，即使文件不存在，也会被认定为文件存在。排除标记不能确定在网络文件系统中是否有效。</p><p>Linux系统里，无法对以追加模式打开的文件进行指定位置写。系统核心忽略了位置参数，每次把数据写到文件的最后。</p><h2 class=\"head2\">fs.openSync(path, flags[, mode])</h2><p><code>fs.open()</code>的同步版本. 返回整数形式的文件描述符。.</p><h2 class=\"head2\">fs.utimes(path, atime, mtime, callback)</h2><p>改变指定路径文件的时间戳。</p><h2 class=\"head2\">fs.utimesSync(path, atime, mtime)</h2><p><code>fs.utimes()</code>的同步版本。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.futimes(fd, atime, mtime, callback)</h2><p>改变传入的文件描述符指向文件的时间戳。</p><h2 class=\"head2\">fs.futimesSync(fd, atime, mtime)</h2><p><code>fs.futimes()</code>的同步版本。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.fsync(fd, callback)</h2><p>异步函数fsync(2)。回调函数只有一个参数：可能出现的异常.</p><h2 class=\"head2\">fs.fsyncSync(fd)</h2><p>同步fsync(2)。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.write(fd, buffer, offset, length[, position], callback)</h2><p>将<code>buffer</code>写到<code>fd</code>指定的文件里。</p><p>参数<code>offset</code>和<code>length</code>确定写哪个部分的缓存。</p><p>参数<code>position</code>是要写入的文件位置。如果<code>typeof position !== 'number'</code>，将会在当前位置写入。参见pwrite(2)。</p><p>回调函数有三个参数<code>(err, written, buffer)</code>，<code>written</code>指定<code>buffer</code>的多少字节用来写。</p><p>注意，如果<code>fs.write</code> 的回调还没执行，就多次调用<code>fs.write</code>，这样很不安全。因此，推荐使用<code>fs.createWriteStream</code> 。</p><p>Linux系统里，无法对以追加模式打开的文件进行指定位置写。系统核心忽略了位置参数，每次把数据写到文件的最后。</p><h2 class=\"head2\">fs.write(fd, data[, position[, encoding]], callback)</h2><p>将<code>buffer</code>写到<code>fd</code>指定的文件里。如果<code>data</code>不是buffer,那么它就会被强制转换为字符串。</p><p>参数<code>position</code>是要写入的文件位置。如果<code>typeof position !== 'number'</code>，将会在当前位置写入。参见pwrite(2)。</p><p>参数<code>encoding</code> ：字符串的编码方式.</p><p>回调函数有三个参数<code>(err, written, buffer)</code>，<code>written</code>指定<code>buffer</code>的多少字节用来写。注意写入的字节（bytes）和字符（string characters）不同。参见<a href=\"x1u41ith.html\" target=\"_blank\">Buffer.byteLength</a>。</p><p>和写入<code>buffer</code>不同，必须写入整个字符串，不能截取字符串。这是因为返回的字节的位移跟字符串的位移是不一样的。</p><p>注意，如果<code>fs.write</code>的回调还没执行，就多次调用<code>fs.write</code>，这样很不安全。因此，推荐使用<code>fs.createWriteStream</code> </p><p>Linux系统里，无法对以追加模式打开的文件进行指定位置写。系统核心忽略了位置参数，每次把数据写到文件的最后。</p><h2 class=\"head2\">fs.writeSync(fd, buffer, offset, length[, position])</h2><h2 class=\"head2\">fs.writeSync(fd, data[, position[, encoding]])</h2><p><code>fs.write()</code>的同步版本. 返回要写的bytes数.</p><h2 class=\"head2\">fs.read(fd, buffer, offset, length, position, callback)</h2><p>读取<code>fd</code>指定文件的数据。</p><p><code>buffer</code>是缓冲区，数据将会写入到这里.</p><p><code>offset</code>写入的偏移量</p><p><code>length</code>需要读的文件长度</p><p><code>position</code>读取的文件起始位置，如果<code>position</code>是<code>null</code>， 将会从当前位置读。</p><p>回调函数有3个参数，<code>(err, bytesRead, buffer)</code>.</p><h2 class=\"head2\">fs.readSync(fd, buffer, offset, length, position)</h2><p><code>fs.read</code>的同步版本。返回<code>bytesRead</code>的数量.</p><h2 class=\"head2\">fs.readFile(filename[, options], callback)</h2><ul><li><code>filename</code> {String}</li><li><code>options</code> {Object}<ul><li><code>encoding</code> {String | Null} 默认 = <code>null</code></li><li><code>flag</code> {String} 默认 = <code>'r'</code></li></ul></li><li><code>callback</code> {Function}</li></ul><p>异步读取整个文件的内容。例如：</p><pre><code class=\"hljs javascript\">fs.readFile(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/etc/passwd'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, data</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(data);\n});</code></pre><p>回调函数有2个参数<code>(err, data)</code>，参数<code>data</code>是文件的内容。如果没有指定参数<code>encoding</code>，返回原生buffer</p><h2 class=\"head2\">fs.readFileSync(filename[, options])</h2><p><code>fs.readFile</code>的同步版本. 返回整个文件的内容.</p><p>如果没有指定参数<code>encoding</code>，返回buffer。</p><h2 class=\"head2\">fs.writeFile(filename, data[, options], callback)</h2><ul><li><code>filename</code> {String}</li><li><code>data</code> {String | Buffer}</li><li><code>options</code> {Object}<ul><li><code>encoding</code> {String | Null} 默认 = <code>'utf8'</code></li><li><code>mode</code> {Number} 默认 = <code>438</code> (aka <code>0666</code> in Octal)</li><li><code>flag</code> {String} 默认 = <code>'w'</code></li></ul></li><li><code>callback</code> {Function}</li></ul><p>异步写文件，如果文件已经存在则替换。<code>data</code>可以是缓存或者字符串。  </p><p>如果参数<code>data</code>是buffer，会忽略参数<code>encoding</code>。默认值是<code>'utf8'</code>。</p><p>列如:</p><pre><code class=\"hljs javascript\">fs.writeFile(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message.txt'</span></span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'Hello Node'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'It\\'s saved!'</span></span></span></span>);\n});</code></pre><h2 class=\"head2\">fs.writeFileSync(filename, data[, options])</h2><p><code>fs.writeFile</code>的同步版本。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.appendFile(filename, data[, options], callback)</h2><ul><li><code>filename</code> {String}</li><li><code>data</code> {String | Buffer}</li><li><code>options</code> {Object}<ul><li><code>encoding</code> {String | Null} 默认 = <code>'utf8'</code></li><li><code>mode</code> {Number} 默认 = <code>438</code> (aka <code>0666</code> in Octal)</li><li><code>flag</code> {String} 默认 = <code>'a'</code></li></ul></li><li><code>callback</code> {Function}</li></ul><p>异步的给文件添加数据，如果文件不存在，就创建一个。<code>data</code>可以是缓存或者字符串。  </p><p>例如:</p><pre><code class=\"hljs javascript\">fs.appendFile(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message.txt'</span></span></span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'data to append'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (err) <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">throw</span></span></span></span> err;\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'The \"data to append\" was appended to file!'</span></span></span></span>);\n});</code></pre><h2 class=\"head2\">fs.appendFileSync(filename, data[, options])</h2><p><code>fs.appendFile</code>的同步版本。返回<code>undefined</code>。</p><h2 class=\"head2\">fs.watchFile(filename[, options], listener)</h2><pre><code class=\"hljs css\">稳定性: 2 <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">-</span></span></span></span> 不稳定。  尽可能的用 <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">fs</span></span></span></span><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\">.watch</span></span></span></span> 来替换。</code></pre><p>监视<code>filename</code>文件的变化。每当文件被访问的时候都会调用<code>listener</code>。</p><p>第二个参数可选。如果有，它必须包含两个boolean参数（<code>persistent</code>和<code>interval</code>）的对象。<code>persistent</code>指定文件被监视时进程是否继续运行。<code>interval</code>指定了查询文件的间隔，以毫秒为单位。缺省值为{ persistent: true, interval: 5007 }。</p><p>listener有两个参数，第一个为文件现在的状态，第二个为文件的前一个状态：</p><pre><code class=\"hljs javascript\">fs.watchFile(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'message.text'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">curr, prev</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'the current mtime is: '</span></span></span></span> + curr.mtime);\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'the previous mtime was: '</span></span></span></span> + prev.mtime);\n});</code></pre><p>listener中的文件状态对象类型为fs.Stat。</p><p>如果想修改文件时被通知，而不是访问的时候就通知，可以比较<code>curr.mtime</code>和<code>prev.mtime</code>。</p><h2 class=\"head2\">fs.unwatchFile(filename[, listener])</h2><pre><code class=\"hljs css\">稳定性: 2 <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">-</span></span></span></span> 不稳定. 尽可能的用 <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">fs</span></span></span></span><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\">.watch</span></span></span></span> 来替换。</code></pre><p>停止监视<code>filename</code>文件的变化。如果指定了<code>listener</code>，那只会移除这个<code>listener</code>。否则，移除所有的listener，并会停止监视<code>filename</code>。</p><p>调用<code>fs.unwatchFile()</code>停止监视一个没被监视的文件，不会触发错误，而会发生一个no-op。 </p><h2 class=\"head2\">fs.watch(filename[, options][, listener])</h2><pre><code class=\"hljs\">稳定性: 2 - 不稳定.</code></pre><p>观察<code>filename</code>指定的文件或文件夹的改变。返回对象是 <a href=\"#fs_class_fs_fswatcher\">fs.FSWatcher</a>。</p><p>第二个参数可选。如果有，它必须是包含两个boolean参数（<code>persistent</code>和<code>recursive</code>）的对象。<code>persistent</code>指定文件被监视时进程是否继续运行。 <code>recursive</code>表明是监视所有的子文件夹还是当前文件夹，这个参数只有监视对象是文件夹时才有效，而且仅在支持的系统里有效（参见下面注意事项）。</p><p>默认值<code>{ persistent: true, recursive: false }</code>.</p><p>回调函数有2个参数<code>(event, filename)</code>。<code>event</code>是<code>rename</code>或<code>change</code>。<code>filename</code>是触发事件的文件名。</p><h3>注意事项</h3><p><code>fs.watch</code>API 不是100%的跨平台兼容，可能在某些情况下不可用。</p><p><code>recursive</code>参数仅在OS X上可用。仅<code>FSEvents</code>支持这个类型文件的监视，所以未来也不太可能有新的平台加入。</p><h4>可用性</h4><p>这些特性依赖于底层系统提供文件系统变动的通知。</p><ul><li>Linux系统，使用<code>inotify</code>.</li><li>BSD系统，使用<code>kqueue</code>.</li><li>OS X，文件使用<code>kqueue</code>，文件夹使用<code>FSEvents</code>.</li><li>SunOS 系统(包括Solaris和SmartOS)，使用<code>event ports</code>.</li><li>Windows系统，依赖与<code>ReadDirectoryChangesW</code>.</li></ul><p>如果底层系统函数不可用，那么<code>fs.watch</code>就无法工作。例如，监视网络文件系统(NFS、 SMB等)经常不能用。你仍然可以用<code>fs.watchFile</code>查询，但是会比较慢，且不可靠。  </p><h4>文件名参数</h4><p>回调函数中提供文件名参数，不是每个平台都能用（Linux和Windows就不行）。即使在可用的平台，也不能保证都能提供。所以不要假设回调函数中<code>filename</code>参数有效，要在代码里添加一些为空的逻辑判断。</p><pre><code class=\"hljs javascript\">fs.watch(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'somedir'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">event, filename</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'event is: '</span></span></span></span> + event);\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">if</span></span></span></span> (filename) {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'filename provided: '</span></span></span></span> + filename);\n  } <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">else</span></span></span></span> {\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span></span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'filename not provided'</span></span></span></span>);\n  }\n});</code></pre><h2 class=\"head2\">fs.exists(path, callback)</h2><p>判断文件是否存在，回调函数参数是bool值。例如：</p><pre><code class=\"hljs javascript\">fs.exists(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/etc/passwd'</span></span></span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"> (</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">exists</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  util.debug(exists ? <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"it's there\"</span></span></span></span> : <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"no passwd!\"</span></span></span></span>);\n});</code></pre><p><code>fs.exists()</code>是老版本的函数，因此在代码里不要用。</p><p>另外，打开文件前判断是否存在有漏洞，在<code>fs.exists()</code>和<code>fs.open()</code>调用中间，另外一个进程有可能已经移除了文件。最好用<code>fs.open()</code>来打开文件，根据回调函数来判断是否有错误。</p><p><code>fs.exists()</code>未来会被移除。</p><h2 class=\"head2\">fs.existsSync(path)</h2><p><code>fs.exists()</code>的同步版本. 如果文件存在返回<code>true</code>, 否则返回<code>false</code>。</p><p><code>fs.existsSync()</code>未来会被移除。</p><h2 class=\"head2\">fs.access(path[, mode], callback)</h2><p>测试由参数<code>path</code>指向的文件的用户权限。可选参数<code>mode</code>为整数，它表示需要检查的权限。下面列出了所有值。<code>mode</code>可以是单个值，或者可以通过或运算，掩码运算实现多个权限检查。</p><ul><li><code>fs.F_OK</code>- 文件是对于进程可见，可以用来检查文件是否存在。参数<code>mode</code>的默认值。  </li><li><code>fs.R_OK</code>- 文件对于进程是否可读。</li><li><code>fs.W_OK</code>- 文件对于进程是否可写。</li><li><code>fs.X_OK</code>- 文件对于进程是否可执行。（Windows系统不可用，执行效果等同<code>fs.F_OK</code>）  </li></ul><p>第三个参数是回调函数。如果检查失败，回调函数的参数就是响应的错误。下面的例子检查文件<code>/etc/passwd</code>是否能被当前的进程读写。</p><pre><code class=\"hljs javascript\">fs.access(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'/etc/passwd'</span></span></span></span>, fs.R_OK | fs.W_OK, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(</span></span></span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err</span></span></span></span></span></span></span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) </span></span></span></span>{\n  util.debug(err ? <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'no access!'</span></span></span></span> : <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'can read/write'</span></span></span></span>);\n});</code></pre><h2 class=\"head2\">fs.accessSync(path[, mode])</h2><p><code>fs.access</code>的同步版本. 如果发生错误抛出异常，否则不做任何事情。  </p><h2 class=\"head2\">类: fs.Stats</h2><p><code>fs.stat()</code>, <code>fs.lstat()</code>和<code>fs.fstat()</code>以及同步版本的返回对象。</p><ul><li><code>stats.isFile()</code></li><li><code>stats.isDirectory()</code></li><li><code>stats.isBlockDevice()</code></li><li><code>stats.isCharacterDevice()</code></li><li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li><li><code>stats.isFIFO()</code></li><li><code>stats.isSocket()</code></li></ul><p>对普通文件使用<code>util.inspect(stats)</code>，返回的字符串和下面类似：</p><pre><code class=\"hljs css\">{ <span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">dev</span></span></span></span>: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2114</span></span></span></span>,\n  ino: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">48064969</span></span></span></span>,\n  mode: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">33188</span></span></span></span>,\n  nlink: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span></span></span>,\n  uid: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">85</span></span></span></span>,\n  gid: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">100</span></span></span></span>,\n  rdev: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span></span></span>,\n  size: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">527</span></span></span></span>,\n  blksize: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">4096</span></span></span></span>,\n  blocks: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">8</span></span></span></span>,\n  atime: Mon, <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span></span></span> Oct <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2011</span></span></span></span> <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">23</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">24</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">11</span></span></span></span> GMT,\n  mtime: Mon, <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span></span></span> Oct <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2011</span></span></span></span> <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">23</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">24</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">11</span></span></span></span> GMT,\n  ctime: Mon, <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span></span></span> Oct <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2011</span></span></span></span> <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">23</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">24</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">11</span></span></span></span> GMT,\n  birthtime: Mon, <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span></span></span> Oct <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">2011</span></span></span></span> <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">23</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">24</span></span></span></span>:<span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">11</span></span></span></span> GMT }</code></pre><p><code>atime</code>, <code>mtime</code>, <code>birthtime</code>, 和<code>ctime</code>都是<a rel=\"nofollow\" href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\">Date</a>的实例，需要使用合适的方法来比较这些值。通常使用<a rel=\"nofollow\" href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime\" target=\"_blank\">getTime()</a>来获取时间戳（毫秒，从 <em>1 January 1970 00:00:00 UTC</em>开始算），这个整数基本能满足任何比较条件。也有一些其他方法来显示额外信息。更多参见<a rel=\"nofollow\" href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\">MDN JavaScript Reference</a>  </p><h3>Stat Time Values</h3><p>状态对象（stat object）有以下语义：</p><ul><li><code>atime</code>访问时间 - 文件的最后访问时间.  <code>mknod(2)</code>, <code>utimes(2)</code>, 和 <code>read(2)</code>等系统调用可以改变.</li><li><code>mtime</code>修改时间 - 文件的最后修改时间. <code>mknod(2)</code>, <code>utimes(2)</code>, 和 <code>write(2)</code>等系统调用可以改变.</li><li><code>ctime</code>改变时间 - 文件状态(inode)的最后修改时间. <code>chmod(2)</code>, <code>chown(2)</code>,<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>, <code>read(2)</code>, 和<code>write(2)</code>等系统调用可以改变.</li><li><code>birthtime</code>\"Birth Time\" -  文件创建时间，文件创建时生成。 在一些不提供文件birthtime的文件系统中, 这个字段会使用ctime或1970-01-01T00:00Z (ie, unix epoch timestamp 0)来填充。在Darwin和其他FreeBSD系统变体中，也将atime显式地设置成比它现在的birthtime更早的一个时间值，这个过程使用了 utimes(2)系统调用。</li></ul><p>在Node v0.12版本之前，Windows系统里ctime有birthtime值. 注意在v.0.12版本中, ctime不再是\"creation time\", 而且在Unix系统中，他一直都不是。</p><h2 class=\"head2\">fs.createReadStream(path[, options])</h2><p>返回可读流对象 (见<code>Readable Stream</code>)。</p><p><code>options</code>默认值如下:</p><pre><code class=\"hljs css\">{ <span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">flags</span></span></span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'r'</span></span></span></span>,\n  encoding: null,\n  fd: null,\n  mode: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0666</span></span></span></span>,\n  autoClose: true\n}</code></pre><p>参数<code>options</code>提供<code>start</code>和<code>end</code>位置来读取文件的特定范围内容，而不是整个文件。<code>start</code>和<code>end</code>都在文件范围里，并从0开始，<code>encoding</code>是<code>'utf8'</code>, <code>'ascii'</code>或<code>'base64'</code>。</p><p>如果给了<code>fd</code>值，<code>ReadStream</code>将会忽略<code>path</code>参数，而使用文件描述，这样不会触发任何<code>open</code>事件。</p><p>如果<code>autoClose</code>为false，即使发生错误文件也不会关闭，需要你来负责关闭，避免文件描述符泄露。如果<code>autoClose</code>是true（默认值），遇到<code>error</code>或<code>end</code>，文件描述符将会自动关闭。  </p><p>例如，从100个字节的文件里，读取最少10个字节：</p><pre><code class=\"hljs javascript\">fs.createReadStream(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'sample.txt'</span></span></span></span>, {start: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">90</span></span></span></span>, end: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">99</span></span></span></span>});</code></pre><h2 class=\"head2\">Class: fs.ReadStream</h2><p><code>ReadStream</code>是 <a href=\"stream.html#stream_class_stream_readable\">Readable Stream</a>。</p><h3>Event: 'open'</h3><ul><li><code>fd</code>{Integer} ReadStream 所使用的文件描述符。</li></ul><p>当创建文件的ReadStream时触发。</p><h2 class=\"head2\">fs.createWriteStream(path[, options])</h2><p>返回一个新的写对象 (参见 <code>Writable Stream</code>)。</p><p><code>options</code>是一个对象，默认值:</p><pre><code class=\"hljs css\">{ <span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\"><span class=\"hljs-attribute\">flags</span></span></span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">'w'</span></span></span></span>,\n  encoding: null,\n  fd: null,\n  mode: <span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\"><span class=\"hljs-number\">0666</span></span></span></span> }</code></pre><p>options也可以包含一个start选项，在指定文件中写入数据开始位置。 修改而不替换文件需要flags的模式指定为r+而不是默值的w。</p><p>和之前的<code>ReadStream</code>类似，如果<code>fd</code>不为空，<code>WriteStream</code>将会忽略<code>path</code>参数，转而使用文件描述，这样不会触发任何<code>open</code>事件。</p><h2 class=\"head2\">类: fs.WriteStream</h2><p><code>WriteStream</code>是 <a href=\"ocq11itw.html\" target=\"_blank\">Writable Stream</a>。</p><h3>Event: 'open'</h3><ul><li><code>fd</code>{Integer} WriteStream所用的文件描述符</li></ul><p>打开WriteStream file时触发。</p><h3>file.bytesWritten</h3><p>目前写入的字节数，不含等待写入的数据。</p><h2 class=\"head2\">Class: fs.FSWatcher</h2><p><code>fs.watch()</code>返回的对象就是这个类.</p><h3>watcher.close()</h3><p>停止观察<code>fs.FSWatcher</code>对象中的更改。</p><h3>Event: 'change'</h3><ul><li><code>event</code>{String} fs改变的类型</li><li><code>filename</code>{String} 改变的文件名 (if relevant/available)</li></ul><p>当监听的文件或文件夹改变的时候触发，参见<a href=\"#fs_fs_watch_filename_options_listener\">fs.watch</a>。</p><h3>Event: 'error'</h3><ul><li><code>error</code>{Error object}</li></ul><p>错误发生时触发。</p><h2>相关文章</h2><p><a href=\"https://www.w3cschool.cn/javascript/js-errors.html\" target=\"_blank\">JavaScript 错误 - throw、try 和 catch</a></p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 6,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "f9da0ded6cb880e2f7a3aebf5335af44",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js Buffer",
      "chapter_level_two_url": "/nodejs/x1u41ith.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Buffer</h2><pre><code class=\"hljs\">稳定性: 3 - 稳定</code></pre><p>纯Javascript语言对Unicode友好，能够很好地处理Unicode编码的字符串数据，但是难以处理二进制数据。在处理TCP流和文件系统时经常需要操作字节流。Node提供了一些机制，用于操作、创建、以及消耗字节流。</p><p>在Node.js中提供了Buffer，它可以处理二进制以及非Unicode编码的数据。<br></p><p>在Buffer类实例化中存储了原始数据。Buffer类似于一个整数数组，在V8堆（the V8 heap）原始存储空间给它分配了内存。一旦创建了Buffer实例，则无法改变大小。</p><p><code>Buffer</code>类是全局对象，所以访问它不必使用<code>require('buffer')</code> 。</p><p>Buffers和Javascript字符串对象之间转换时需要一个明确的编码方法。下面是字符串的不同编码：</p><ul><li><p><code>'ascii'</code>- 7位的ASCII数据。这种编码方式非常快，它会移除最高位内容。</p></li><li><p><code>'utf8'</code>- 多字节编码Unicode字符。大部分网页和文档使用这类编码方式。</p></li><li><p><code>'utf16le'</code>- 2个或4个字节， Little Endian (LE)编码Unicode字符。编码范围(U+10000 到 U+10FFFF) 。</p></li><li><p><code>'ucs2'</code>-<code>'utf16le'</code>的子集。</p></li><li><p><code>'base64'</code> - Base64字符编码。</p></li><li><code>'binary'</code>- 仅使用每个字符的头8位将原始的二进制信息进行编码。在需使用Buffer的情况下，应该尽量避免使用这个已经过时的编码方式。这个编码方式将会在未来某个版本中弃用。</li><li><code>'hex'</code>- 每个字节都采用二进制编码。</li></ul><p>在<code>Buffer</code>中创建一个数组，需要注意以下规则：</p><ol><li><p>Buffer是内存拷贝，而不是内存共享。</p></li><li>Buffer占用内存被解释为一个数组，而不是字节数组。比如，<code>new Uint32Array(new Buffer([1,2,3,4]))</code>创建了4个<code>Uint32Array</code>，它的成员为 <code>[1,2,3,4]</code>，而不是<code>[0x1020304]</code>或<code>[0x4030201]</code>。</li></ol><p>注意：Node.js v0.8只是简单的引用了<code>array.buffer</code>里的buffer，而不是对其进行克隆(cloning)。</p><p>介绍一个高效的方法，<code>ArrayBuffer#slice()</code>拷贝了一份切片，而<code>Buffer#slice()</code>新建了一份。</p><h2 class=\"head2\">类: Buffer</h2><p>Buffer类是全局变量类型，用来直接处理二进制数据。它能够使用多种方式构建。</p><h3>new Buffer(size)</h3><ul><li><code>size</code>Number类型</li></ul><p>分配一个新的<code>size</code>大小单位为8位字节的buffer。</p><p>注意：<code>size</code>必须小于<a href=\"95fo1itr.html\" target=\"_blank\">kMaxLength</a>，否则将会抛出<code>RangeError</code>异常。</p><h3>new Buffer(array)</h3><ul><li><code>array</code>Array</li></ul><p>使用一个8位字节<code>array</code>数组分配一个新的buffer。</p><h3>new Buffer(buffer)</h3><ul><li><code>buffer</code>{Buffer}</li></ul><p>拷贝参数<code>buffer</code>的数据到<code>Buffer</code>实例。</p><h3>new Buffer(str[, encoding])</h3><ul><li><code>str</code> String类型 - 需要编码的字符串。</li><li><code>encoding</code> String类型 - 编码方式, 可选。</li></ul><p>分配一个新的buffer ，其中包含着传入的<code>str</code>字符串。<code>encoding</code> 编码方式默认为<code>'utf8'</code>。</p><h3>类方法: Buffer.isEncoding(encoding)</h3><ul><li><code>encoding</code> {String}  用来测试给定的编码字符串</li></ul><p>如果参数编码<code>encoding</code>是有效的，则返回true，否则返回false。</p><h3>类方法: Buffer.isBuffer(obj)</h3><ul><li><code>obj</code>对象</li><li>返回：Boolean</li></ul><p><code>obj</code>如果是<code>Buffer</code> 返回true，否则返回 false。</p><h3>类方法: Buffer.byteLength(string[, encoding])</h3><ul><li><code>string</code> String类型</li><li><code>encoding</code> String类型，可选的，默认为: 'utf8'</li><li>返回：Number类型</li></ul><p>将会返回这个字符串真实字节长度。 encoding编码默认是：<code>utf8</code>。 这和<code>String.prototype.length</code>不一样，因为那个方法返回这个字符串中字符的数量。</p><p>例如:</p><pre><code class=\"hljs javascript\">str = <span class=\"hljs-string\"><span class=\"hljs-string\">'\\u00bd + \\u00bc = \\u00be'</span></span>;\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(str + <span class=\"hljs-string\"><span class=\"hljs-string\">\": \"</span></span> + str.length + <span class=\"hljs-string\"><span class=\"hljs-string\">\" characters, \"</span></span> +\n  Buffer.byteLength(str, <span class=\"hljs-string\"><span class=\"hljs-string\">'utf8'</span></span>) + <span class=\"hljs-string\"><span class=\"hljs-string\">\" bytes\"</span></span>);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// ½ + ¼ = ¾: 9 characters, 12 bytes</span></span></code></pre><h3>类方法: Buffer.concat(list[, totalLength])</h3><ul><li><code>list</code> {Array} 用来连接的数组</li><li><code>totalLength</code> {Number 类型} 数组里所有对象的总buffer大小</li></ul><p>返回一个buffer对象，它将参数buffer数组中所有buffer对象拼接在一起。</p><p>如果传入的数组没有内容，或者totalLength是0，那将返回一个长度为0的buffer。</p><p>如果数组长度为1，返回数组第一个成员。</p><p>如果数组长度大于0，将会创建一个新的Buffer实例。</p><p>如果没有提供totalLength参数，会根据buffer数组计算，这样会增加一个额外的循环计算，所以提供一个准确的totalLength参数速度更快。</p><h3>类方法: Buffer.compare(buf1, buf2)</h3><ul><li><code>buf1</code> {Buffer}</li><li><code>buf2</code> {Buffer}</li></ul><p>和<a href=\"#buffer_buf_compare_otherbuffer\"><code>buf1.compare(buf2)</code></a>一样， 用来对数组排序:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> arr = [Buffer(<span class=\"hljs-string\"><span class=\"hljs-string\">'1234'</span></span>), Buffer(<span class=\"hljs-string\"><span class=\"hljs-string\">'0123'</span></span>)];\narr.sort(Buffer.compare);</code></pre><h3>buf.length</h3><ul><li>Number类型</li></ul><p>返回这个buffer的bytes数。注意这未必是buffer里面内容的大小。<code>length</code>是buffer对象所分配的内存数，它不会随着这个buffer对象内容的改变而改变。</p><pre><code class=\"hljs javascript\">buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">1234</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.length);\nbuf.write(<span class=\"hljs-string\"><span class=\"hljs-string\">\"some string\"</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">\"ascii\"</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.length);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 1234</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 1234</span></span></code></pre><p><code>length</code>不能改变，如果改变<code>length</code>将会导致不可以预期的结果。如果想要改变buffer的长度，需要使用<code>buf.slice</code>来创建新的buffer。</p><pre><code class=\"hljs javascript\">buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>);\nbuf.write(<span class=\"hljs-string\"><span class=\"hljs-string\">\"abcdefghj\"</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-string\"><span class=\"hljs-string\">\"ascii\"</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.length); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 10</span></span>\nbuf = buf.slice(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.length); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 5</span></span></code></pre><h3>buf.write(string[, offset][, length][, encoding])</h3><ul><li><code>string</code> String类型 - 写到buffer里</li><li><code>offset</code> Number类型，可选参数，默认值: 0</li><li><code>length</code> Number类型，可选参数，默认值:<code>buffer.length - offset</code></li><li><code>encoding</code> String类型，可选参数，默认值: 'utf8'</li></ul><p>根据参数offset偏移量和指定的encoding编码方式，将参数string数据写入buffer。offset偏移量默认值是0，encoding编码方式默认是<code>utf8</code>。 length长度是将要写入的字符串的bytes大小。返回number类型，表示写入了多少8位字节流。如果buffer没有足够的空间来放整个string，它将只会只写入部分字符串。length默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</p><pre><code class=\"hljs javascript\">buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">256</span></span>);\nlen = buf.write(<span class=\"hljs-string\"><span class=\"hljs-string\">'\\u00bd + \\u00bc = \\u00be'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(len + <span class=\"hljs-string\"><span class=\"hljs-string\">\" bytes: \"</span></span> + buf.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'utf8'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, len));</code></pre><h3>buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3><h3>buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3><h3>buf.writeIntLE(value, offset, byteLength[, noAssert])</h3><h3>buf.writeIntBE(value, offset, byteLength[, noAssert])</h3><ul><li><code>value</code> {Number 类型}准备写到buffer字节数</li><li><code>offset</code> {Number 类型} <code>0 &lt;= offset &lt;= buf.length</code></li><li><code>byteLength</code> {Number 类型} <code>0 &lt; byteLength &lt;= 6</code></li><li><code>noAssert</code> {Boolean} 默认值: false</li><li>返回： {Number 类型}</li></ul><p>将<code>value</code>写入到buffer里， 它由<code>offset</code>和<code>byteLength</code>决定，支持48位计算，例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> b = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">6</span></span>);\nb.writeUIntBE(<span class=\"hljs-number\"><span class=\"hljs-number\">0x1234567890ab</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">6</span></span>);\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer 12 34 56 78 90 ab&gt;</span></span></code></pre><p><code>noAssert</code>值为<code>true</code>时，不再验证<code>value</code>和<code>offset</code> 的有效性。 默认是<code>false</code>。</p><h3>buf.readUIntLE(offset, byteLength[, noAssert])</h3><h3>buf.readUIntBE(offset, byteLength[, noAssert])</h3><h3>buf.readIntLE(offset, byteLength[, noAssert])</h3><h3>buf.readIntBE(offset, byteLength[, noAssert])</h3><ul><li><code>offset</code> {Number 类型} <code>0 &lt;= offset &lt;= buf.length</code></li><li><code>byteLength</code> {Number 类型} <code>0 &lt; byteLength &lt;= 6</code></li><li><code>noAssert</code> {Boolean} 默认值: false</li><li>返回: {Number 类型}</li></ul><p>支持48位以下的数字读取。 例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> b = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">6</span></span>);\nb.writeUint16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0x90ab</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\nb.writeUInt32LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0x12345678</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>);\nb.readUIntLE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">6</span></span>).toString(<span class=\"hljs-number\"><span class=\"hljs-number\">16</span></span>);  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 指定为 6 bytes (48 bits)</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 输出: '1234567890ab'</span></span></code></pre><p><code>noAssert</code> 值为true时， <code>offset</code>不再验证是否超过buffer的长度，默认为<code>false</code>。</p><h3>buf.toString([encoding][, start][, end])</h3><ul><li><code>encoding</code> String 类型，可选参数，默认值: 'utf8'</li><li><code>start</code> Number 类型，可选参数，默认值: 0</li><li><code>end</code> Number 类型，可选参数，默认值: <code>buffer.length</code></li></ul><p>根据encoding参数（默认是 'utf8'）返回一个解码过的string类型。还会根据传入的参数start(默认是 0)和end (默认是 buffer.length)作为取值范围。</p><pre><code class=\"hljs javascript\">buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> ; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span> ; i++) {\n  buf[i] = i + <span class=\"hljs-number\"><span class=\"hljs-number\">97</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 97 is ASCII a</span></span>\n}\nbuf.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'ascii'</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 输出: abcdefghijklmnopqrstuvwxyz</span></span>\nbuf.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'ascii'</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 输出: abcde</span></span>\nbuf.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'utf8'</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 输出: abcde</span></span>\nbuf.toString(<span class=\"hljs-literal\"><span class=\"hljs-literal\">undefined</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>,<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>); <span class=\"hljs-comment\"><span class=\"hljs-comment\">// encoding defaults to 'utf8', 输出 abcde</span></span></code></pre><p>查看上面<code>buffer.write()</code>例子。</p><h3>buf.toJSON()</h3><p>返回一个<a href=\"https://www.w3cschool.cn/json/json-tutorial.html\" target=\"_blank\">JSON</a>表示的Buffer实例。<code>JSON.stringify</code> 将会默认调用字符串序列化这个Buffer实例。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-string\"><span class=\"hljs-string\">'test'</span></span>);\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> json = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">JSON</span></span>.stringify(buf);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(json);\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// '{\"type\":\"Buffer\",\"data\":[116,101,115,116]}'</span></span>\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> copy = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">JSON</span></span>.parse(json, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">key, value</span></span></span><span class=\"hljs-function\">) </span></span>{\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return</span></span> value &amp;&amp; value.type === <span class=\"hljs-string\"><span class=\"hljs-string\">'Buffer'</span></span>\n      ? <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(value.data)\n      : value;\n  });\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(copy);\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer 74 65 73 74&gt;</span></span></code></pre><h3>buf[index]</h3><p>获取或设置指定index位置的8位字节。这个值是指单个字节，所以必须在合法的范围取值，16进制的0x00到0xFF，或者0到255。</p><p>例如: 拷贝一个ASCII编码的string字符串到一个buffer，一次一个byte进行拷贝:</p><pre><code class=\"hljs javascript\">str = <span class=\"hljs-string\"><span class=\"hljs-string\">\"node.js\"</span></span>;\nbuf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(str.length);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; i &lt; str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// node.js</span></span></code></pre><h3>buf.equals(otherBuffer)</h3><ul><li><code>otherBuffer</code> {Buffer}</li></ul><p>如果 <code>this</code> 和 <code>otherBuffer</code> 拥有相同的内容，返回true。</p><h3>buf.compare(otherBuffer)</h3><ul><li><code>otherBuffer</code> {Buffer}</li></ul><p>返回一个数字，表示 <code>this</code> 在 <code>otherBuffer</code> 之前，之后或相同。</p><h3>buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])</h3><ul><li><code>targetBuffer</code> Buffer 对象 - Buffer to copy into</li><li><code>targetStart</code> Number 类型，可选参数， 默认值: 0</li><li><code>sourceStart</code> Number 类型，可选参数， 默认值: 0</li><li><code>sourceEnd</code> Number 类型，可选参数， 默认值: <code>buffer.length</code></li></ul><p>buffer拷贝，源和目标可以相同。<code>targetStart</code>目标开始偏移和<code>sourceStart</code>源开始偏移默认都是0。<code>sourceEnd</code>源结束位置偏移默认是源的长度 <code>buffer.length</code>。</p><p>例如：创建2个Buffer，然后把buf1的16到19位内容拷贝到buf2第8位之后。</p><pre><code class=\"hljs javascript\">buf1 = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span>);\nbuf2 = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> ; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span> ; i++) {\n  buf1[i] = i + <span class=\"hljs-number\"><span class=\"hljs-number\">97</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 97 is ASCII a</span></span>\n  buf2[i] = <span class=\"hljs-number\"><span class=\"hljs-number\">33</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// ASCII !</span></span>\n}\n\nbuf1.copy(buf2, <span class=\"hljs-number\"><span class=\"hljs-number\">8</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">16</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">20</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf2.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'ascii'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">25</span></span>));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// !!!!!!!!qrst!!!!!!!!!!!!!</span></span></code></pre><p>例如: 在同一个buffer中，从一个区域拷贝到另一个区域：</p><pre><code class=\"hljs javascript\">buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> ; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span> ; i++) {\n  buf[i] = i + <span class=\"hljs-number\"><span class=\"hljs-number\">97</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 97 is ASCII a</span></span>\n}\n\nbuf.copy(buf, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.toString());\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// efghijghijklmnopqrstuvwxyz</span></span></code></pre><h3>buf.slice([start][, end])</h3><ul><li><code>start</code> Number类型，可选参数，默认值: 0</li><li><code>end</code> Number类型，可选参数，默认值: <code>buffer.length</code></li></ul><p>返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，根据<code>start</code>(默认是 <code>0</code> ) 和<code>end</code> (默认是 <code>buffer.length</code> ) 偏移和裁剪了索引。 负的索引是从buffer尾部开始计算的。</p><p><strong>修改这个新的buffer实例slice切片，也会改变原来的buffer!</strong></p><p>例如: 创建一个ASCII字母的Buffer，进行slice切片，然后修改源Buffer上的一个byte。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf1 = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span>);\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> i = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span> ; i &lt; <span class=\"hljs-number\"><span class=\"hljs-number\">26</span></span> ; i++) {\n  buf1[i] = i + <span class=\"hljs-number\"><span class=\"hljs-number\">97</span></span>; <span class=\"hljs-comment\"><span class=\"hljs-comment\">// 97 is ASCII a</span></span>\n}\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf2 = buf1.slice(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>);\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf2.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'ascii'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, buf2.length));\nbuf1[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">33</span></span>;\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf2.toString(<span class=\"hljs-string\"><span class=\"hljs-string\">'ascii'</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, buf2.length));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// abc</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// !bc</span></span></code></pre><h3>buf.readUInt8(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，读取一个有符号8位整数 整形。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 如果这样<code>offset</code> 可能会超出buffer的末尾。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\n\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x3</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x4</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x23</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x42</span></span>;\n\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">for</span></span> (ii = <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>; ii &lt; buf.length; ii++) {\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt8(ii));\n}\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x3</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x4</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x23</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x42</span></span></code></pre><h3>buf.readUInt16LE(offset[, noAssert])</h3><h3>buf.readUInt16BE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从buffer对象里，根据指定的偏移量，使用特殊的endian字节序格式读取一个有符号16位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着<code>offset</code>可能会超出buffer的末尾。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\n\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x3</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x4</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x23</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x42</span></span>;\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16BE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16BE(<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16BE(<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x0304</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x0403</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x0423</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x2304</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x2342</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x4223</span></span></code></pre><h3>buf.readUInt32LE(offset[, noAssert])</h3><h3>buf.readUInt32BE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，使用指定的endian字节序格式读取一个有符号32位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着<code>offset</code>可能会超出buffer的末尾。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\n\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x3</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x4</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x23</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x42</span></span>;\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt32BE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readUInt32LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x03042342</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x42230403</span></span></code></pre><h3>buf.readInt8(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，读取一个signed 8位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着offset可能会超出buffer的末尾。默认是<code>false</code>。</p><p>返回和<code>buffer.readUInt8</code>一样，除非buffer中包含了有作为2的补码的有符号值。</p><h3>buf.readInt16LE(offset[, noAssert])</h3><h3>buf.readInt16BE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，使用特殊的endian格式读取一个signed 16位整数。</p><p>若参数<code>noAssert</code>为true将不会验证 <code>offset</code> 偏移量参数。 这意味着offset可能会超出buffer的末尾。默认是<code>false</code>。</p><p>返回和<code>buffer.readUInt16</code>一样，除非buffer中包含了有作为2的补码的有符号值。</p><h3>buf.readInt32LE(offset[, noAssert])</h3><h3>buf.readInt32BE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，使用指定的endian字节序格式读取一个signed 32位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着<code>offset</code>可能会超出buffer的末尾。默认是<code>false</code>。</p><p>和<code>buffer.readUInt32</code>一样返回，除非buffer中包含了有作为2的补码的有符号值。</p><h3>buf.readFloatLE(offset[, noAssert])</h3><h3>buf.readFloatBE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，使用指定的endian字节序格式读取一个32位浮点数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着<code>offset</code>可能会超出buffer的末尾。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\n\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x00</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x00</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x80</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x3f</span></span>;\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readFloatLE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0x01</span></span></code></pre><h3>buf.readDoubleLE(offset[, noAssert])</h3><h3>buf.readDoubleBE(offset[, noAssert])</h3><ul><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li><li>返回： Number类型</li></ul><p>从这个buffer对象里，根据指定的偏移量，使用指定的endian字节序格式读取一个64位double。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code>偏移量参数。 这意味着<code>offset</code>可能会超出buffer 的末尾。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">8</span></span>);\n\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">5</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x55</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">6</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0xd5</span></span>;\nbuf[<span class=\"hljs-number\"><span class=\"hljs-number\">7</span></span>] = <span class=\"hljs-number\"><span class=\"hljs-number\">0x3f</span></span>;\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf.readDoubleLE(<span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>));\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// 0。3333333333333333</span></span></code></pre><h3>buf.writeUInt8(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的有符号 8 位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>offset</code> 偏移量参数。 这意味着<code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\nbuf.writeUInt8(<span class=\"hljs-number\"><span class=\"hljs-number\">0x3</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\nbuf.writeUInt8(<span class=\"hljs-number\"><span class=\"hljs-number\">0x4</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">1</span></span>);\nbuf.writeUInt8(<span class=\"hljs-number\"><span class=\"hljs-number\">0x23</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>);\nbuf.writeUInt8(<span class=\"hljs-number\"><span class=\"hljs-number\">0x42</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">3</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer 03 04 23 42&gt;</span></span></code></pre><h3>buf.writeUInt16LE(value, offset[, noAssert])</h3><h3>buf.writeUInt16BE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的有符号16位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。 这意味着<code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\nbuf.writeUInt16BE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xdead</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\nbuf.writeUInt16BE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xbeef</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\nbuf.writeUInt16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xdead</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\nbuf.writeUInt16LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xbeef</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">2</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer de ad be ef&gt;</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer ad de ef be&gt;</span></span></code></pre><h3>buf.writeUInt32LE(value, offset[, noAssert])</h3><h3>buf.writeUInt32BE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的有符号32位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。 这意味着<code>value</code>可能过大，或者offset可能会超出buffer的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\nbuf.writeUInt32BE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xfeedface</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\nbuf.writeUInt32LE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xfeedface</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer fe ed fa ce&gt;</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer ce fa ed fe&gt;</span></span></code></pre><h3>buf.writeInt8(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的signed 8位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。这意味着<code>value</code>可能过大，或者offset可能会超出buffer的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>和<code>buffer.writeUInt8</code>一样工作，除非是把有2的补码的<code>有符号整数</code>有符号整形写入buffer。</p><h3>buf.writeInt16LE(value, offset[, noAssert])</h3><h3>buf.writeInt16BE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的signed 16位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。 这意味着<code>value</code>可能过大，或者offset可能会超出buffer的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code> 。</p><p>和<code>buffer.writeUInt16*</code>一样工作，除非是把有2的补码的有符号整数 有符号整形写入<code>buffer</code>。</p><h3>buf.writeInt32LE(value, offset[, noAssert])</h3><h3>buf.writeInt32BE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：<code>value</code>必须是一个合法的signed 32位整数。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。 这意味着<code>value</code>可能过大，或者<code>offset</code>可能会超出 buffer 的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>和<code>buffer.writeUInt32*</code>一样工作，除非是把有2的补码的有符号整数、有符号整形写入buffer。</p><h3>buf.writeFloatLE(value, offset[, noAssert])</h3><h3>buf.writeFloatBE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：当<code>value</code>不是一个32位浮点数类型的值时，结果将是不确定的。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。这意味着value可能过大，或者offset可能会超出buffer的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">4</span></span>);\nbuf.writeFloatBE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xcafebabe</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\nbuf.writeFloatLE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xcafebabe</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer 4f 4a fe bb&gt;</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer bb fe 4a 4f&gt;</span></span></code></pre><h3>buf.writeDoubleLE(value, offset[, noAssert])</h3><h3>buf.writeDoubleBE(value, offset[, noAssert])</h3><ul><li><code>value</code> Number类型</li><li><code>offset</code> Number类型</li><li><code>noAssert</code> Boolean，可选参数， 默认值: false</li></ul><p>根据传入的<code>offset</code>偏移量和指定的endian格式将<code>value</code>写入buffer。注意：<code>value</code>必须是一个有效的64位double类型的值。</p><p>若参数<code>noAssert</code>为true将不会验证<code>value</code>和<code>offset</code>偏移量参数。 这意味着<code>value</code>可能过大，或者offset可能会超出buffer的末尾从而造成<code>value</code>被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是<code>false</code>。</p><p>例如:</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> buf = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">8</span></span>);\nbuf.writeDoubleBE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xdeadbeefcafebabe</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\nbuf.writeDoubleLE(<span class=\"hljs-number\"><span class=\"hljs-number\">0xdeadbeefcafebabe</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(buf);\n\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;</span></span>\n<span class=\"hljs-comment\"><span class=\"hljs-comment\">// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</span></span></code></pre><h3>buf.fill(value[, offset][, end])</h3><ul><li><code>value</code></li><li><code>offset</code> Number类型， Optional</li><li><code>end</code> Number类型， Optional</li></ul><p>使用指定的<code>value</code>来填充这个buffer。如果没有指定<code>offset</code> (默认是 0) 并且<code>end</code>(默认是<code>buffer.length</code>) ，将会填充整个buffer。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> b = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> Buffer(<span class=\"hljs-number\"><span class=\"hljs-number\">50</span></span>);\nb.fill(<span class=\"hljs-string\"><span class=\"hljs-string\">\"h\"</span></span>);</code></pre><h2 class=\"head2\">buffer.iNSPECT_MAX_BYTES</h2><ul><li>Number 类型，默认值: 50</li></ul><p>设置当调用<code>buffer.inspect()</code>方法后，将会返回多少bytes 。用户模块重写这个值可以。</p><p>注意这个属性是<code>require('buffer')</code>模块返回的。这个属性不是在全局变量Buffer中，也不在buffer的实例里。</p><h2 class=\"head2\">类: SlowBuffer</h2><p>返回一个不被池管理的<code>Buffer</code>。</p><p>大量独立分配的Buffer容易带来垃圾，为了避免这个情况，小于4KB的空间都是切割自一个较大的独立对象。这种策略既提高了性能也改善了内存使用率。V8不需要跟踪和清理过多的<code>Persistent</code>对象。</p><p>当开发者需要将池中一小块数据保留一段时间，比较好的办法是用SlowBuffer创建一个不被池管理的Buffer实例，并将相应数据拷贝出来，如下所示：</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// need to keep around a few small chunks of memory</span></span>\n<span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> store = [];\n\nsocket。on(<span class=\"hljs-string\"><span class=\"hljs-string\">'readable'</span></span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\">(</span><span class=\"hljs-params\"></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> data = socket。read();\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// allocate for retained data</span></span>\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> sb = <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">new</span></span> SlowBuffer(<span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>);\n  <span class=\"hljs-comment\"><span class=\"hljs-comment\">// copy the data into the new allocation</span></span>\n  data。copy(sb, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">0</span></span>, <span class=\"hljs-number\"><span class=\"hljs-number\">10</span></span>);\n  store。push(sb);\n});</code></pre><p>请谨慎使用，仅作为经常发现他们的应用中过度的内存保留时的最后手段。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 5,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "774443c5eeaf93d465eea10028ea7716",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js Punycode",
      "chapter_level_two_url": "/nodejs/syrl1itg.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Punycode</h2><p>Punycode是根据RFC 3492标准定义的字符编码方案，主要用于把域名从地方语言所采用的Unicode编码转换成为可用于DNS系统的编码。<br></p><pre><code class=\"hljs\">稳定性: 2 - 不稳定</code></pre><p><a rel=\"nofollow\" href=\"http://mths.be/punycode\" target=\"_blank\">Punycode.js</a>从Node.js v0.6.2+开始内置. 使用<code>require('punycode')</code>来访问。 (要在其他Node.js版本中访问，先用npm来<code>punycode</code>安装)。</p><h2 class=\"head2\">punycode.decode(string)</h2><p>将一个纯ASCII的Punycode字符串转换为Unicode字符串。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// decode domain name parts</span>\npunycode.decode(<span class=\"hljs-string\">'maana-pta'</span>); <span class=\"hljs-comment\">// 'mañana'</span>\npunycode.decode(<span class=\"hljs-string\">'--dqo34k'</span>); <span class=\"hljs-comment\">// '☃-⌘'</span></code></pre><h2 class=\"head2\">punycode.encode(string)</h2><p>将一个纯Unicode  Punycode字符串转换为纯ASCII字符串。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// encode domain name parts</span>\npunycode.encode(<span class=\"hljs-string\">'mañana'</span>); <span class=\"hljs-comment\">// 'maana-pta'</span>\npunycode.encode(<span class=\"hljs-string\">'☃-⌘'</span>); <span class=\"hljs-comment\">// '--dqo34k'</span></code></pre><h2 class=\"head2\">punycode.toUnicode(domain)</h2><p>将一个表示域名的Punycode字符串转换为Unicode。只有域名中的Punycode部分会被转换，也就是说你也可以在一个已经转换为Unicode的字符串上调用它。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// decode domain names</span>\npunycode.toUnicode(<span class=\"hljs-string\">'xn--maana-pta.com'</span>); <span class=\"hljs-comment\">// 'mañana.com'</span>\npunycode.toUnicode(<span class=\"hljs-string\">'xn----dqo34k.com'</span>); <span class=\"hljs-comment\">// '☃-⌘.com'</span></code></pre><h2 class=\"head2\">punycode.toASCII(domain)</h2><p>将一个表示域名的Unicode字符串转换为Punycode。只有域名中的非ASCII部分会被转换，也就是说你也可以在一个已经转换为ASCII的字符串上调用它。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// encode domain names</span>\npunycode.toASCII(<span class=\"hljs-string\">'mañana.com'</span>); <span class=\"hljs-comment\">// 'xn--maana-pta.com'</span>\npunycode.toASCII(<span class=\"hljs-string\">'☃-⌘.com'</span>); <span class=\"hljs-comment\">// 'xn----dqo34k.com'</span></code></pre><h2 class=\"head2\">punycode.ucs2</h2><h3>punycode.ucs2.decode(string)</h3><p>创建一个包含字符串中每个Unicode符号的数字编码点的数组。由于<a rel=\"nofollow\" href=\"http://mathiasbynens.be/notes/javascript-encoding\" target=\"_blank\">JavaScript在内部使用UCS-2</a>， 该函数会按照UTF-16将一对代半数（UCS-2暴露的单独的字符）转换为单独一个编码点。</p><pre><code class=\"hljs javascript\">punycode.ucs2.decode(<span class=\"hljs-string\">'abc'</span>); <span class=\"hljs-comment\">// [0x61, 0x62, 0x63]</span>\n<span class=\"hljs-comment\">// surrogate pair for U+1D306 tetragram for centre:</span>\npunycode.ucs2.decode(<span class=\"hljs-string\">'\\uD834\\uDF06'</span>); <span class=\"hljs-comment\">// [0x1D306]</span></code></pre><h3>punycode.ucs2.encode(codePoints)</h3><p>创建以一组数字编码点为基础一个字符串。</p><pre><code class=\"hljs ruby\">punycode.ucs2.encode([<span class=\"hljs-number\">0x61</span>, <span class=\"hljs-number\">0x62</span>, <span class=\"hljs-number\">0x63</span>]); <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">'abc'</span>\npunycode.ucs2.encode([<span class=\"hljs-number\">0x1D306</span>]); <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">'\\uD834\\uDF06'</span></code></pre><h2 class=\"head2\">punycode.version</h2><p>表示当前Punycode.js版本数字的字符串。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 4,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "cfab00a9acce84da029aee76438b7df9",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 事件",
      "chapter_level_two_url": "/nodejs/aue11itf.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>事件</h2><pre><code class=\"hljs\">文档: 4 - API 冻结</code></pre><p>Node里很多对象会分发事件： 每次有连接的时候<code>net.Server</code>会分发事件，当文件打开的时候<code>fs.readStream</code>会分发事件。所有能分发事件的对象都是 <code>events.EventEmitter</code>的实例。通过<code>require(\"events\");</code>能访问这个模块。</p><p>一般来说，事件名都遵照驼峰规则，但这不是强制规定，任何形式的字符串都可以做为事件名。</p><p>为了处理事件，通常将函数关联到对象上。这些函数也叫监听者(listeners)。在这个函数里，<code>this</code>指向监听者所关联的<code>EventEmitter</code>。</p><p><a name=\"events_class_events_eventemitter\"></a></p><h2 class=\"head2\">类: events.EventEmitter</h2><p>你可以通过<code>require('events').EventEmitter</code>获取EventEmitter类。</p><p><code>EventEmitter</code>实例遇到错误后，通常会触发一个错误事件。错误事件在node里是特殊例子。如果没有监听者，默认的操作是打印一个堆栈信息并退出程序。</p><p>当添加新的监听者时， EventEmitters会触发<code>'newListener'</code>事件，当移除时会触发<code>'removeListener'</code>。</p><h3>emitter.addListener(event, listener)</h3><h3>emitter.on(event, listener)</h3><p>添加一个监听者到特定<code>event</code>的监听数组的尾部，触发器不会检查是否已经添加过这个监听者。 多次调用相同的<code>event</code>和<code>listener</code>将会导致<code>listener</code>添加多次。</p><pre><code class=\"hljs javascript\">server.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'someone connected!'</span>);\n});</code></pre><p>返回emitter。</p><h3>emitter.once(event, listener)</h3><p>给事件添加一个一次性的listener，这个listener只会被触发一次，之后就会被移除。</p><pre><code class=\"hljs javascript\">server.once(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Ah, we have our first user!'</span>);\n});</code></pre><p>返回emitter。</p><h3>emitter.removeListener(event, listener)</h3><p>从一个某个事件的listener数组中移除一个listener。<strong>注意</strong>，这个操作会改变listener数组内容的次序。</p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> callback = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'someone connected!'</span>);\n};\nserver.on(<span class=\"hljs-string\">'connection'</span>, callback);\n<span class=\"hljs-comment\">// ...</span>\nserver.removeListener(<span class=\"hljs-string\">'connection'</span>, callback);</code></pre><p><code>removeListener</code>最多会移除数组里的一个listener。如果多次添加同一个listener到数组，那就需要多次调用<code>removeListener</code>来移除每一个实例。</p><p>返回emitter。</p><h3>emitter.removeAllListeners([event])</h3><p>移除所有的listener，或者某个事件listener。最好不要移除全部listener，尤其是那些不是你传入的（比如socket或文件流）。</p><p>返回emitter。  </p><h3>emitter.setMaxListeners(n)</h3><p>默认情况下，给单个事件添加超过10个listener，事件分发器会打印警告。这样有利于检查内存泄露。不过不是所有的分发器都应该限制在10个，这个函数允许改变 listener数量，无论是0还是更多。</p><p>返回emitter。  </p><h3>EventEmitter.defaultMaxListeners</h3><p><code>emitter.setMaxListeners(n)</code>设置一个分发器的最大listener数，而这个函数会立即设置<strong>所有</strong><code>EventEmitter</code>的当前值和默认值。要小心使用。</p><p>请注意，<code>emitter.setMaxListeners(n)</code>的优先级高于<code>EventEmitter.defaultMaxListeners</code>.</p><h3>emitter.listeners(event)</h3><p>用于返回事件的listener数组。</p><pre><code class=\"hljs javascript\">server.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">stream</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'someone connected!'</span>);\n});\n<span class=\"hljs-built_in\">console</span>.log(util.inspect(server.listeners(<span class=\"hljs-string\">'connection'</span>))); <span class=\"hljs-comment\">// [ [Function] ]</span></code></pre><h3>emitter.emit(event[, arg1][, arg2][, ...])</h3><p>允许你使用指定的参数顺序的执行每一个listener.</p><p>如果事件有 listener,返回<code>true</code>， 否则<code>false</code> </p><h3>类方法: EventEmitter.listenerCount(emitter, event)</h3><p>返回指定事件的listener数量。</p><h3>Event: 'newListener'</h3><ul><li><code>event</code>{String}事件名</li><li><code>listener</code>{Function}事件处理函数</li></ul><p>添加listener的时候会触发这个事件。当这个事件触发的时候，listener可能还没添加到listener数组。</p><h3>Event: 'removeListener'</h3><ul><li><code>event</code>{String}事件名</li><li><code>listener</code>{Function}事件处理函数</li></ul><p>删除listener的时候会触发这个事件。当这个事件触发的时候，listener可能还还没从listener数组移除。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 3,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "133e8f1d4cdcc1ea8bc64dff7271917f",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 断言测试",
      "chapter_level_two_url": "/nodejs/368p1ite.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>断言测试</h2><p>Node.js的assert模块主要用于编写程序的单元测试时使用，通过断言可以提早发现和排查出错误。<br></p><pre lang=\"html\"><code class=\"html\">稳定性: 5 - 锁定</code></pre><p>这个模块可用于应用的单元测试，通过 <code>require('assert')</code> 可以使用这个模块。</p><h3>assert.fail(actual, expected, message, operator)</h3><p>使用参数operator测试参数<code>actual</code> (实际值) 和<code>expected</code>（期望值）是否相等。</p><h3>assert(value[, message]), assert.ok(value[, message])</h3><p>测试参数<code>value</code>是否为<code>true</code>,此函数和<code>assert.equal(true, !!value, message);</code>等价。</p><h3>assert.equal(actual, expected[, message])</h3><p>判断实际值<code>actual</code>和期望值<code>expected</code>是否相等。</p><h3>assert.notEqual(actual, expected[, message])</h3><p>判断实际值<code>actual</code>和期望值<code>expected</code>是否不等。</p><h3>assert.deepEqual(actual, expected[, message])</h3><p>执行深度比较，判断实际值<code>actual</code>和期望值<code>expected</code>是否相等。</p><h3>assert.notDeepEqual(actual, expected[, message])</h3><p>深度比较两个参数是否不相等。</p><h3>assert.strictEqual(actual, expected[, message])</h3><p>深度比较两个参数是否相等。  </p><h3>assert.notStrictEqual(actual, expected[, message])</h3><p>此函数使用操作符 ‘!==’ 严格比较是否两参数不相等。</p><h3>assert.throws(block[, error][, message])</h3><p>声明一个<code>block</code>用来抛出错误（<code>error</code>），<code>error</code>可以是构造函数，正则表达式或其他验证器。</p><p>使用构造函数验证实例：</p><pre><code class=\"hljs javascript\">    assert.throws(\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"Wrong value\"</span>);\n      },\n      <span class=\"hljs-built_in\">Error</span>\n    );</code></pre><p>使用正则表达式验证错误信息：</p><pre><code class=\"hljs javascript\">    assert.throws(\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"Wrong value\"</span>);\n      },\n      <span class=\"hljs-regexp\">/value/</span>\n    );</code></pre><p>用户自定义的错误验证器：</p><pre><code class=\"hljs javascript\">    assert.throws(\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"Wrong value\"</span>);\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>{\n        <span class=\"hljs-keyword\">if</span> ( (err <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Error</span>) &amp;&amp; <span class=\"hljs-regexp\">/value/</span>.test(err) ) {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n      },\n      <span class=\"hljs-string\">\"unexpected error\"</span>\n    );</code></pre><h3>assert.doesNotThrow(block[, message])</h3><p>声明<code>block</code>不抛出错误，详细信息参见<code>assert.throws</code>。</p><h3>assert.ifError(value)</h3><p>判断参数value是否为false ，如果是true，则抛出异常。通常用来测试回调中第一个参数error。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 2,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "a93e1ea03116dd7bb56e3839bfabee69",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "Node.js 示例",
      "chapter_level_two_url": "/nodejs/2vku1itd.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2><span style=\"font-family: inherit;\">Node.js</span>示例</h2><p>第一个<a href=\"1v9k1itp.html\" target=\"_blank\">服务器</a>的例子就从 “Hello World” 开始：  </p><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">var</span></span> http = <span class=\"hljs-built_in\"><span class=\"hljs-built_in\">require</span></span>(<span class=\"hljs-string\"><span class=\"hljs-string\">'http'</span></span>);\n\nhttp.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> (</span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">request, response</span></span></span><span class=\"hljs-function\">) </span></span>{\n  response.writeHead(<span class=\"hljs-number\"><span class=\"hljs-number\">200</span></span>, {<span class=\"hljs-string\"><span class=\"hljs-string\">'Content-Type'</span></span>: <span class=\"hljs-string\"><span class=\"hljs-string\">'text/plain'</span></span>});\n  response.end(<span class=\"hljs-string\"><span class=\"hljs-string\">'Hello World\\n'</span></span>);\n}).listen(<span class=\"hljs-number\"><span class=\"hljs-number\">8124</span></span>);\n\n<span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console</span></span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\">'Server running at http://127.0.0.1:8124/'</span></span>);</code></pre><p>把代码拷贝到<code>example.js</code>文件里，使用node程序执行：</p><pre><code class=\"hljs javascript\">&gt; node example.js\nServer running at http:<span class=\"hljs-comment\"><span class=\"hljs-comment\">//127.0.0.1:8124/</span></span></code></pre><p>在该Node.js官方文档中的所有的例子都可以使用上述方法执行。</p></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 1,
      "parent_sort_index": 2,
      "chapter_level_one_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 官方文档",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "97ab23c0a4f7722314b322858d6d1067",
      "chapter_level_two_parent_id": "e072192796ad212fb1211c2d48c5008c",
      "chapter_level_two_name": "关于 Node.js",
      "chapter_level_two_url": "/nodejs/8boq1itc.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"wkcontent\"><h2>Node.js 官方文档中文版</h2><blockquote><p>本文档翻译自 <a rel=\"nofollow\" href=\"https://nodejs.org/api/\" target=\"_blank\">Node.js</a> 官方文档，适用于 V0.12.2。</p></blockquote><p>本文档将从引用参考和概念两个方面来对Node.js API进行全面的解释，让你更加了解Node.js API。<br></p><p>Node.js官方文档的每个章节描述了一个内置模块或高级概念。</p><p>一般情况下，属性、方法参数，以及提供给事件处理程序的参数都会在主标题下的列表中详细说明。</p><p>每个<code>.html</code>文档都有对应的<code>.json</code>，它们包含相同的结构化内容。这些东西目前还是实验性的，主要为各种集成开发环境（IDE）和开发工具提供便利。</p><p>每个<code>.html</code>和<code>.json</code>文件都和<code>doc/api/</code>目录下的<code>.markdown</code>文件相对应。这些文档使用<code>tools/doc/generate.js</code>程序生成。 HTML模板位于<code>doc/template.html</code>。</p><h2 class=\"head2\">稳定性标志</h2><p>在文档中，你会看到每个章节的稳定性标志。Node.js API还在改进中，成熟的部分会比其他章节值得信赖。经过大量验证和依赖的API是一般是不会变的。其他新增的，试验性的，或被证明具有危险性的部分正被重新设计。<br></p><p>稳定性标志包括以下内容:</p><pre><code class=\"hljs\">稳定性（Stability）: 0 - 抛弃\n这部分内容有问题，并已计划改变。不要使用这些内容，可能会引起警告。不要想什么向后兼容性了。</code></pre><pre><code class=\"hljs\">稳定性（Stability）: 1 - 试验\n这部分内容最近刚引进，将来的版本可能会改变也可能会被移除。你可以试试并提供反馈。如果你用到的部分对你来说非常重要，可以告诉 node 的核心团队。</code></pre><pre><code class=\"hljs\">稳定性（Stability）: 2 - 不稳定\n这部分 API 正在调整中，还没在实际工作测试中达到满意的程度。如果合理的话会保证向后兼容性。</code></pre><pre><code class=\"hljs\">稳定性（Stability）: 3 - 稳定\n这部分 API 验证过基本能令人满意，但是清理底层代码时可能会引起小的改变。保证向后的兼容性。</code></pre><pre><code class=\"hljs\">稳定性（Stability）: 4 - API 冻结\n这部分的 API 已经在产品中广泛试验，不太可能被改变。</code></pre><pre><code class=\"hljs\">稳定性（Stability）: 5 - 锁定\n除非发现了严重 bug，否则这部分代码永远不会改变。请不要对这部分内容提出更改建议，否则会被拒绝。\n</code></pre><h2 class=\"head2\">JSON 输出</h2><pre><code class=\"hljs\">稳定性（Stability）: 1 - 试验</code></pre><p>每个通过 markdown 生成的 HTML 文件都有相应的 JSON 文件。</p><p>这个特性从 v0.6.12 开始,是试验性功能。</p><table><thead><tr><th>更新日期</th><th>更新内容</th></tr></thead><tbody><tr><td>2015-04-21</td><td>第一版发布，翻译自 Node.js V0.12.2 官方文档</td></tr></tbody></table></div><h2>相关教程</h2><p><a href=\"https://www.w3cschool.cn/json/json-tutorial.html\" target=\"_blank\">JSON教程</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 22,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "43a3fe8481da34068a8cbf17bb41ea90",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js JXcore 打包",
      "chapter_level_two_url": "/nodejs/nodejs-jxcore-packaging.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n    <div class=\"article-intro\" id=\"content\">\n        \t<h2>Node.js JXcore 打包</h2>\n\n        <p>Node.js是一个开放源代码、跨平台的、用于服务器端和网络应用的运行环境。\n            <br>\n        </p>\n        <p>JXcore是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。</p>\n        <p>本文主要介绍JXcore的打包功能。</p>\n        <hr>\n        \n<h2>JXcore 安装</h2>\n\n        <p>下载JXcore安装包，然后进行解压，在解压的目录下提供了jx二进制文件命令，接下来我们主要使用这个命令。</p>\n        \n<h3>步骤1、下载</h3>在 <span style=\"background-color: rgb(255, 255, 255);\"><a href=\"https://github.com/jxcore/jxcore-release\" rel=\"external nofollow\" target=\"_blank\">https://github.com/jxcore/jxcore-release</a></span><a href=\"http://\" rel=\"external nofollow\" target=\"_blank\"> </a>中下载JXcore安装包，你需要根据你自己的系统环境来下载安装包：</div>\n    <div class=\"article-intro\" id=\"content\">\n        <p>1、Window系统下载：<a href=\"https://jxcore.s3.amazonaws.com/0305/jx_winsetup.zip\" rel=\"external nofollow\" target=\"_blank\">Download</a>，</p>\n        <p>2、Linux/OSX下载安装命令，直接下载解压包下的jx二进制文件，然后拷贝到/usr/bin目录下：</p>\n<pre>$ wget https://s3.amazonaws.com/nodejx/jx_rh64.zip\n$ unzip jx_rh64.zip\n$ cp jx_rh64/jx /usr/bin\n</pre>\n\n        <p>将/usr/bin添加到PATH路径中：</p>\n<pre>$ export PATH=$PATH:/usr/bin\n</pre>\n\n        <p>以上步骤如果操作正确，使用以下命令，会输出版本号信息：</p>\n<pre>$ jx --version\nv0.10.32\n</pre>\n\n        <hr>\n        \n<h2>包代码</h2>\n\n        <p>例如，我们的Node.js项目包含以下几个文件，其中index.js是主文件：</p>\n<pre>drwxr-xr-x  2 root root  4096 Nov 13 12:42 images\n-rwxr-xr-x  1 root root 30457 Mar  6 12:19 index.htm\n-rwxr-xr-x  1 root root 30452 Mar  1 12:54 index.js\ndrwxr-xr-x 23 root root  4096 Jan 15 03:48 node_modules\ndrwxr-xr-x  2 root root  4096 Mar 21 06:10 scripts\ndrwxr-xr-x  2 root root  4096 Feb 15 11:56 style\n</pre>\n\n        <p>接下来我们使用<b>jx</b>命令打包以上项目，并指定index.js为Node.js项目的主文件：</p>\n<pre>$ jx package index.js index\n</pre>\n\n        <p>以上命令执行成功，会生成以下两个文件：</p>\n        <ul>\n            <li>\n                <p><b>index.jxp</b>：这是一个中间件文件，包含了需要编译的完整项目信息。</p>\n            </li>\n            <li>\n                <p><b>index.jx：</b>这是一个完整包信息的二进制文件，可运行在客户端上。</p>\n            </li>\n        </ul>\n        <hr>\n        \n<h2>载入 JX  文件</h2>\n\n        <p>我们使用<b>jx</b>命令打包项目：</p>\n<pre>$ node index.js command_line_arguments\n</pre>\n\n        <p>使用JXcore编译后，我们可以使用以下命令来执行生成的jx二进制文件：</p>\n<pre>$ jx index.jx command_line_arguments</pre>\n\n        <hr>\n        <p>更多JXcore功能特性你可以参考官网：<a href=\"http://jxcore.com/\" rel=\"external nofollow\" target=\"_blank\">http://jxcore.com/</a>。</p>\n    </div>\n</div><p><br></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 21,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "dec6741c9629ca1d742edb8cbeb42e2b",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 多进程",
      "chapter_level_two_url": "/nodejs/nodejs-process.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js 多进程</h2><p>Node.js本身是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p>\n<p>每个子进程总是带有三个流对象：child.stdin, child.stdout和child.stderr。他们可能会共享父进程的stdio流，或者也可以是独立的被导流的流对象。</p>\n\n<p>Node提供了child_process模块来创建子进程，方法有：</p>\n<ul>\n<li><p><b>exec</b> - child_process.exec使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</p></li>\n<li><p><b>spawn</b> - child_process.spawn使用指定的命令行参数创建新进程。</p></li>\n<li><p><b>fork</b> - child_process.fork是spawn()的特殊形式，用于在子进程中运行的模块，如fork('./son.js')相当于spawn('node', ['./son.js']) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p></li>\n</ul>\n<hr>\n<h2>exec() 方法</h2>\n<p>child_process.exec使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</p>\n<p>语法如下所示：</p>\n<pre>child_process.exec(command[, options], callback)\n</pre>\n<h3>参数</h3>\n<p>参数说明如下：</p>\n\n<p><b>command：</b> 字符串， 将要运行的命令，参数使用空格隔开</p>\n<p><strong>options ：对象，可以是：</strong></p>\n<ul>\n<li>cwd，字符串，子进程的当前工作目录</li>\n<li>env，对象，环境变量键值对</li>\n<li>encoding，字符串，字符编码（默认： 'utf8'）</li>\n<li>shell，字符串，将要执行命令的Shell（默认: 在UNIX中为<code>/bin/sh</code>， 在Windows中为<code>cmd.exe</code>， Shell应当能识别<code>-c</code>开关在UNIX中，或<code>/s /c</code>在 Windows中。 在Windows中，命令行解析应当能兼容<code>cmd.exe</code>）</li>\n<li>timeout，数字，超时时间（默认： 0）</li>\n<li>maxBuffer，数字， 在stdout或stderr中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死（默认: 200*1024）</li>\n<li>killSignal，字符串，结束信号（默认：'SIGTERM'）</li>\n<li>uid，数字，设置用户进程的ID</li>\n<li>gid，数字，设置进程组的ID</li>\n</ul>\n\n<p><strong>callback ：</strong>回调函数，包含三个参数error, stdout和stderr。</p>\n<p>\nexec()方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。\n</p>\n<h3>实例</h3>\n<p>\n让我们创建两个js文件support.js和master.js。</p>\n<p>support.js文件代码：</p>\n<pre>console.log(\"进程 \" + process.argv[2] + \" 执行。\" );\n</pre>\n<p>master.js文件代码：</p>\n<pre>const fs = require('fs');\nconst child_process = require('child_process');\n\nfor(var i=0; i&lt;3; i++) {\n   var workerProcess = child_process.exec('node support.js '+i,\n      function (error, stdout, stderr) {\n         if (error) {\n            console.log(error.stack);\n            console.log('Error code: '+error.code);\n            console.log('Signal received: '+error.signal);\n         }\n         console.log('stdout: ' + stdout);\n         console.log('stderr: ' + stderr);\n      });\n\n      workerProcess.on('exit', function (code) {\n      console.log('子进程已退出，退出码 '+code);\n   });\n}\n</pre>\n<p>执行以上代码，输出结果为：</p>\n<pre>$ node master.js \n子进程已退出，退出码 0\nstdout: 进程 1 执行。\n\nstderr: \n子进程已退出，退出码 0\nstdout: 进程 0 执行。\n\nstderr: \n子进程已退出，退出码 0\nstdout: 进程 2 执行。\n\nstderr: \n</pre>\n<hr>\n<h2>spawn() 方法</h2>\n<p>child_process.spawn使用指定的命令行参数创建新进程，语法格式如下：</p>\n<pre>child_process.spawn(command[, args][, options])\n</pre>\n<h3>参数</h3>\n<p>参数说明如下：</p>\n\n<p><b>command：</b> 将要运行的命令</p>\n\n\n<p><b>args：</b> Array字符串参数数组</p>\n\n<p><strong>options Object</strong></p>\n<ul>\n<li>cwd：String，子进程的当前工作目录</li>\n<li>env：Object，环境变量键值对</li>\n<li>stdio：Array|String，子进程的stdio配置</li>\n<li>detached：Boolean，这个子进程将会变成进程组的领导</li>\n<li>uid：Number，设置用户进程的ID</li>\n<li>gid：Number，设置进程组的ID</li>\n</ul>\n\n<p>spawn()方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程开始执行spawn()时就开始接收响应。</p>\n<h3>实例</h3>\n<p>\n在这个实例中我们创建两个js文件support.js和master.js。</p>\n<p>support.js文件代码：</p>\n<pre>console.log(\"进程 \" + process.argv[2] + \" 执行。\" );\n</pre>\n<p>master.js文件代码：</p>\n<pre>const fs = require('fs');\nconst child_process = require('child_process');\n \nfor(var i=0; i&lt;3; i++) {\n   var workerProcess = child_process.spawn('node', ['support.js', i]);\n\n   workerProcess.stdout.on('data', function (data) {\n      console.log('stdout: ' + data);\n   });\n\n   workerProcess.stderr.on('data', function (data) {\n      console.log('stderr: ' + data);\n   });\n\n   workerProcess.on('close', function (code) {\n      console.log('子进程已退出，退出码 '+code);\n   });\n}\n</pre>\n<p>执行以上代码，输出结果为：</p>\n<pre>$ node master.js stdout: 进程 0 执行。\n\n子进程已退出，退出码 0\nstdout: 进程 1 执行。\n\n子进程已退出，退出码 0\nstdout: 进程 2 执行。\n\n子进程已退出，退出码 0\n</pre>\n<hr>\n<h2>fork 方法</h2>\n<p>child_process.fork是spawn()方法的特殊形式，用于创建进程，语法格式如下：</p>\n<pre>child_process.fork(modulePath[, args][, options])\n</pre>\n<h3>参数</h3>\n<p>参数说明如下：</p>\n\n<p><b>modulePath</b>： String，将要在子进程中运行的模块</p>\n\n<p><b>args</b>： Array，字符串参数数组</p>\n\n<p><strong>options</strong>：Object</p><ul>\n<li>cwd：String，子进程的当前工作目录</li>\n<li>env：Object，环境变量键值对</li>\n<li>execPath：String，创建子进程的可执行文件</li>\n<li>execArgv：Array，子进程的可执行文件的字符串参数数组（默认： process.execArgv）</li>\n<li>silent：Boolean，如果为<code>true</code>，子进程的<code>stdin</code>，<code>stdout</code>和<code>stderr</code>将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：<code>false</code>）</li>\n<li>uid：Number，设置用户进程的ID</li>\n<li>gid：Number，设置进程组的ID</li>\n</ul>\n<p>\n返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。\n</p><h3>实例\n</h3><p>\n让我们创建两个js文件support.js和master.js。</p>\n<p>support.js文件代码如下所示：</p>\n<pre>console.log(\"进程 \" + process.argv[2] + \" 执行。\" );\n</pre>\n<p>master.js文件代码如下所示：</p>\n<pre>const fs = require('fs');\nconst child_process = require('child_process');\n \nfor(var i=0; i&lt;3; i++) {\n   var worker_process = child_process.fork(\"support.js\", [i]);\t\n\n   worker_process.on('close', function (code) {\n      console.log('子进程已退出，退出码 ' + code);\n   });\n}\n</pre>\n<p>执行以上代码，输出结果为：</p>\n<pre>$ node master.js \n进程 0 执行。\n子进程已退出，退出码 0\n进程 1 执行。\n子进程已退出，退出码 0\n进程 2 执行。\n子进程已退出，退出码 0</pre></div></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 20,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "40f5a3b37c28b0eed78a6936a817a099",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js RESTful API",
      "chapter_level_two_url": "/nodejs/nodejs-restful-api.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h2>Node.js RESTful API</h2><p>本节介绍Node.js的RESTful API。</p>\n<h2>什么是 REST？</h2>\n<p>REST中文解释为，表述性状态传递（英文：Representational State Transfer，简称REST），是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>\n<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。</p><p>需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI和XML（标准通用标记语言下的一个子集）以及<a href=\"https://www.w3cschool.cn/html/html-intro.html\" target=\"_blank\">HTML</a>（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST通常使用JSON数据格式。</p>\n<h3>\nHTTP 方法</h3>\n以下为REST基本架构的四个方法：\n<ul>\n<li><p><b>GET</b> - 用于获取数据。</p></li>\n<li><p><b>PUT</b> - 用于添加数据。</p></li>\n<li><p><b>DELETE</b> - 用于删除数据。</p></li>\n<li><p><b>POST</b> - 用于更新或添加数据。</p></li>\n</ul>\n<hr>\n<h2>RESTful Web Services\n</h2>\n<p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。\n</p>\n<p>RESTful是基于REST架构的Web Services。</p>\n\n<p>由于轻量级以及通过HTTP直接传输数据的特性，Web服务的RESTful方法已经成为最常见的替代方法。可以使用各种语言（比如，Java程序、Perl、Ruby、Python、PHP和Javascript[包括Ajax]）实现客户端。</p><p>RESTful Web服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的Web浏览器构建一个GET URL并读取返回的内容。\n</p>\n\n<p>更多介绍，可以查看：<a href=\"/w3cnote/restful-architecture.html\" target=\"_blank\">RESTful 架构详解</a></p>\n<hr>\n<h2>创建 RESTful </h2>\n<p>首先，创建一个json数据资源文件users.json，内容如下：</p>\n<pre>{\n   \"user1\" : {\n      \"name\" : \"mahesh\",\n\t  \"password\" : \"password1\",\n\t  \"profession\" : \"teacher\",\n\t  \"id\": 1\n   },\n   \"user2\" : {\n      \"name\" : \"suresh\",\n\t  \"password\" : \"password2\",\n\t  \"profession\" : \"librarian\",\n\t  \"id\": 2\n   },\n   \"user3\" : {\n      \"name\" : \"ramesh\",\n\t  \"password\" : \"password3\",\n\t  \"profession\" : \"clerk\",\n\t  \"id\": 3\n   }\n}\n</pre>\n<p>基于以上数据，我们创建以下RESTful API：</p>\n<table class=\"reference\">\n<tbody><tr><th>序号</th><th>URI</th><th>HTTP 方法</th><th>发送内容</th><th>结果</th>\n</tr><tr><td>1</td><td>listUsers</td><td>GET</td><td>空</td><td>显示所有用户列表</td>\n</tr><tr><td>2</td><td>addUser</td><td>POST</td><td>JSON 字符串</td><td>添加新用户</td>\n</tr><tr><td>3</td><td>deleteUser</td><td>DELETE</td><td>JSON 字符串</td><td>删除用户</td>\n</tr><tr><td>4</td><td>:id</td><td>GET</td><td>空</td><td>显示用户详细信息</td>\n</tr></tbody></table>\n<h3>获取用户列表：</h3>\n<p>以下代码，我们创建了RESTful API <b>listUsers</b>，用于读取用户的信息列表， server.js文件代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n\napp.get('/listUsers', function (req, res) {\n   fs.readFile( __dirname + \"/\" + \"users.json\", 'utf8', function (err, data) {\n       console.log( data );\n       res.end( data );\n   });\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>接下来执行以下命令：</p>\n<pre>$ node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre><p>\n在浏览器中访问http://127.0.0.1:8081/listUsers，结果如下所示：</p>\n<pre>{\n   \"user1\" : {\n      \"name\" : \"mahesh\",\n      \"password\" : \"password1\",\n      \"profession\" : \"teacher\",\n      \"id\": 1\n   },\n   \"user2\" : {\n      \"name\" : \"suresh\",\n      \"password\" : \"password2\",\n      \"profession\" : \"librarian\",\n      \"id\": 2\n   },\n   \"user3\" : {\n      \"name\" : \"ramesh\",\n      \"password\" : \"password3\",\n      \"profession\" : \"clerk\",\n      \"id\": 3\n   }\n}\n</pre>\n<h3>添加用户</h3>\n<p>如果要添加新的用户数据，可以通过创建RESTful API <b>addUser实现</b>，server.js文件代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n\n//添加的新用户数据\nvar user = {\n   \"user4\" : {\n      \"name\" : \"mohit\",\n      \"password\" : \"password4\",\n      \"profession\" : \"teacher\",\n      \"id\": 4\n   }\n}\n\napp.get('/addUser', function (req, res) {\n   // 读取已存在的数据\n   fs.readFile( __dirname + \"/\" + \"users.json\", 'utf8', function (err, data) {\n       data = JSON.parse( data );\n       data[\"user4\"] = user[\"user4\"];\n       console.log( data );\n       res.end( JSON.stringify(data));\n   });\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>接下来执行以下命令：</p>\n<pre>$ node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre><p>\n在浏览器中访问http://127.0.0.1:8081/addUser，结果如下所示：</p>\n<pre>{ user1:\n   { name: 'mahesh',\n     password: 'password1',\n     profession: 'teacher',\n     id: 1 },\n  user2:\n   { name: 'suresh',\n     password: 'password2',\n     profession: 'librarian',\n     id: 2 },\n  user3:\n   { name: 'ramesh',\n     password: 'password3',\n     profession: 'clerk',\n     id: 3 },\n  user4:\n   { name: 'mohit',\n     password: 'password4',\n     profession: 'teacher',\n     id: 4 } \n}\n</pre>\n\n<h3>显示用户详情</h3>\n<p>以下代码，我们创建了RESTful API <b>:id（用户id）</b>， 用于读取指定用户的详细信息，server.js文件代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n\napp.get('/:id', function (req, res) {\n   // 首先我们读取已存在的用户\n   fs.readFile( __dirname + \"/\" + \"users.json\", 'utf8', function (err, data) {\n       data = JSON.parse( data );\n       var user = data[\"user\" + req.params.id] \n       console.log( user );\n       res.end( JSON.stringify(user));\n   });\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n\n\n<p>接下来执行以下命令：</p>\n<pre>$ node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre><p>\n在浏览器中访问http://127.0.0.1:8081/2，结果如下所示：</p>\n<pre>{\n   \"name\":\"suresh\",\n   \"password\":\"password2\",\n   \"profession\":\"librarian\",\n   \"id\":2\n}\n</pre>\n<h3>删除用户</h3>\n<p>以下代码，我们创建了RESTful API <b>deleteUser</b>， 用于删除指定用户的详细信息，以下实例中，用户id为2，server.js文件代码如下所示：</p>\n<pre>var express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n\nvar id = 2;\n\napp.get('/deleteUser', function (req, res) {\n\n   // First read existing users.\n   fs.readFile( __dirname + \"/\" + \"users.json\", 'utf8', function (err, data) {\n       data = JSON.parse( data );\n       delete data[\"user\" + 2];\n       \n       console.log( data );\n       res.end( JSON.stringify(data));\n   });\n})\n\nvar server = app.listen(8081, function () {\n\n  var host = server.address().address\n  var port = server.address().port\n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\n</pre>\n<p>接下来执行以下命令：</p>\n<pre>$ node server.js \n应用实例，访问地址为 http://0.0.0.0:8081\n</pre><p>\n在浏览器中访问http://127.0.0.1:8081/deleteUser，结果如下所示：</p>\n<pre>{ user1:\n   { name: 'mahesh',\n     password: 'password1',\n     profession: 'teacher',\n     id: 1 },\n  user3:\n   { name: 'ramesh',\n     password: 'password3',\n     profession: 'clerk',\n     id: 3 } \n}</pre></div></div></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 4,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "80e6c21834f6681170b0160ed2c09993",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js NPM 使用介绍",
      "chapter_level_two_url": "/nodejs/nodejs-npm.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>NPM 使用介绍</h2> <p>本文介绍了 Node.js 中 NPM 的使用，我们先来了解什么是 NPM。</p><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p> <ul><li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。 </li><li> 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 </li><li> 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li></ul> <p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 </p><strong>\"npm -v\" </strong><p>来测试是否成功安装。命令如下，出现版本提示表示安装成功: </p><pre style=\"\" class=\"prettyprint prettyprinted\"><span class=\"pln\">$ npm </span><span class=\"pun\">-</span><span class=\"pln\">v\n</span><span class=\"lit\">2.3</span><span class=\"pun\">.</span><span class=\"lit\">0</span></pre><p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p><pre style=\"\" class=\"prettyprint prettyprinted\"><span class=\"pln\">$ sudo npm install npm </span><span class=\"pun\">-</span><span class=\"pln\">g\n</span><span class=\"pun\">/</span><span class=\"pln\">usr</span><span class=\"pun\">/</span><span class=\"kwd\">local</span><span class=\"pun\">/</span><span class=\"pln\">bin</span><span class=\"pun\">/</span><span class=\"pln\">npm </span><span class=\"pun\">-&gt;</span><span class=\"pln\"> </span><span class=\"str\">/usr/</span><span class=\"kwd\">local</span><span class=\"pun\">/</span><span class=\"pln\">lib</span><span class=\"pun\">/</span><span class=\"pln\">node_modules</span><span class=\"pun\">/</span><span class=\"pln\">npm</span><span class=\"pun\">/</span><span class=\"pln\">bin</span><span class=\"pun\">/</span><span class=\"pln\">npm</span><span class=\"pun\">-</span><span class=\"pln\">cli</span><span class=\"pun\">.</span><span class=\"pln\">js\nnpm@2</span><span class=\"pun\">.</span><span class=\"lit\">14.2</span><span class=\"pln\"> </span><span class=\"pun\">/</span><span class=\"pln\">usr</span><span class=\"pun\">/</span><span class=\"kwd\">local</span><span class=\"pun\">/</span><span class=\"pln\">lib</span><span class=\"pun\">/</span><span class=\"pln\">node_modules</span><span class=\"pun\">/</span><span class=\"pln\">npm</span></pre><p>如果是 Window 系统使用以下命令即可：</p><pre style=\"\" class=\"prettyprint prettyprinted\"><span class=\"pln\">npm install npm </span><span class=\"pun\">-</span><span class=\"pln\">g</span></pre><hr><h2>全局安装与本地安装</h2><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p><pre>npm install express          # 本地安装\nnpm install express -g   # 全局安装</pre><p>如果出现以下错误：</p><pre>npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 </pre><p>解决办法为：</p><pre>$ npm config set proxy null</pre><h3>本地安装</h3><ul><li>1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li><li>2. 可以通过 require() 来引入本地安装的包。</li></ul><h3>全局安装</h3><ul><li>1. 将安装包放在 /usr/local 下或者你 node 的安装目录。</li><li>2. 可以直接在命令行里使用。</li></ul><p>如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。</p> <h2>NPM 应用</h2> <p>NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下介绍NPM应用的三种场景：</p> <h3>下载第三方包 </h3> <p> 我们可以使用以下命令来下载第三方包。 </p> <pre>$ npm install argv\n...\nargv@0.0.2 node_modules\\argv\n</pre><p> 下载好之后，argv包就放在了工程目录下的node_modules目录中，因此在代码中只需要通过require('argv')的方式就好，无需指定第三方包路径。 </p> <p> 以上命令默认下载最新版第三方包，如果想要下载指定版本的话，可以在包名后边加上@&lt;version&gt;，例如通过以下命令可下载0.0.1版的argv。 </p> <pre>$ npm install argv@0.0.1\n...\nargv@0.0.1 node_modules\\argv\n</pre> <p> NPM对package.json的字段做了扩展，允许在其中申明第三方包依赖。因此，上边例子中的package.json可以改写如下： </p> <pre>{\n    \"name\": \"node-echo\",\n    \"main\": \"./lib/echo.js\",\n    \"dependencies\": {\n        \"argv\": \"0.0.2\"\n    }\n}\n</pre> <p> 这样处理后，在工程目录下就可以使用npm install命令批量安装第三方包了。</p> <p>更重要的是，当以后node-echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的第三方包依赖自动下载进一步依赖的第三方包。</p><p>例如，使用npm install node-echo命令时，NPM会自动创建以下目录结构。 </p> <pre>- project/\n    - node_modules/\n        - node-echo/\n            - node_modules/\n                + argv/\n            ...\n    ...\n</pre> <p>如此一来，用户只需关心自己直接使用的第三方包，不需要自己去解决所有包的依赖关系。 </p> <h3> 安装命令行程序 </h3> <p> 从NPM服务上下载安装一个命令行程序的方法与第三方包类似。</p> <p>例如上例中的node-echo提供了命令行使用方式，只要node-echo自己配置好了相关的package.json字段，对于用户而言，只需要使用以下命令安装程序。 </p> <pre>$ npm install node-echo -g\n</pre> <p> 参数中的-g表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的.cmd文件。 </p> <pre>- /usr/local/               # Linux系统下\n    - lib/node_modules/\n        + node-echo/\n        ...\n    - bin/\n        node-echo\n        ...\n    ...\n\n- %APPDATA%\\npm\\            # Windows系统下\n    - node_modules\\\n        + node-echo\\\n        ...\n    node-echo.cmd\n    ...\n</pre> <h3>发布代码 </h3> <p> 第一次使用NPM发布代码前需要注册一个账号。终端下运行npm adduser，之后按照提示做即可。</p> <p>账号注册完成后，接着我们需要编辑package.json文件，加入NPM必需的字段。接着上边node-echo的例子，package.json里必要的字段如下。 </p> <pre>{\n    \"name\": \"node-echo\",           # 包名，在NPM服务器上须要保持唯一\n    \"version\": \"1.0.0\",            # 当前版本号\n    \"dependencies\": {              # 第三方包依赖，需要指定包名和版本号\n        \"argv\": \"0.0.2\"\n      },\n    \"main\": \"./lib/echo.js\",       # 入口模块位置\n    \"bin\" : {\n        \"node-echo\": \"./bin/node-echo\"      # 命令行程序名和主模块位置\n    }\n}\n</pre> <p> 之后，我们就可以在package.json所在目录下运行npm publish发布代码了。 </p> <hr> <h2> 版本号 </h2> <p> 使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。 </p> <p> 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 </p> <ul> <li> 如果只是修复bug，需要更新Z位。</li><li> 如果是新增了功能，但是向下兼容，需要更新Y位。</li><li> 如果有大变动，向下不兼容，需要更新X位。</li></ul> <p> 版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如\"argv\": \"0.0.x\"表示依赖于0.0.x系列的最新版argv。</p> <p>NPM支持的所有版本号范围指定方式可以查看<a href=\"https://npmjs.org/doc/files/package.json.html#dependencies\" rel=\"external nofollow\" target=\"_blank\">官方文档</a>。 </p> <hr> <h2>NPM常用命令</h2> <p> 除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。</p> <p>除了可以在<a href=\"https://npmjs.org/doc/\" rel=\"external nofollow\" target=\"_blank\">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。 </p> <p> NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 </p> <ul> <li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p> </li> <li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p> </li> <li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p> </li> <li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p> </li> <li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p> </li> <li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p> </li> <li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p></li></ul></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 3,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "fc27f1118533f17f0e26e3a9a6e4576f",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 创建第一个应用",
      "chapter_level_two_url": "/nodejs/nodejs-http-server.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2> </h2>\n<h2>Node.js 创建第一个应用</h2>\n<p>如果我们使用<a href=\"https://www.w3cschool.cn/php/php-intro.html\" target=\"_blank\">PHP</a>来编写后端的代码时，需要Apache或者Nginx的HTTP服务器，并配上mod_php5模块和php-cgi。</p>\n<p>从这个角度看，整个\"接收HTTP请求并提供Web页面\"的需求根本不需要PHP来处理。</p>\n<p>不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。</p>\n<p>在我们创建Node.js第一个\"Hello, World!\"应用前，让我们先了解下Node.js应用是由哪几部分组成的：</p>\n<ol>\n    <li>\n        <p><strong>引入required模块：</strong>我们可以使用<strong>require</strong>指令来载入Node.js模块。</p>\n    </li>\n    <li>\n        <p><strong>创建服务器：</strong>服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p>\n    </li>\n    <li>\n        <p><strong>接收请求与响应请求</strong>：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p>\n    </li>\n</ol>\n<hr>\n<h2>创建 Node.js 应用</h2>\n<h3>步骤一、引入required模块</h3>\n<p>我们使用<strong>require</strong>指令来载入http模块，并将实例化的HTTP赋值给变量http，实例如下:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var http = require(\"http\");</code></pre>\n<h3>步骤一、创建服务器</h3>\n<p>接下来我们使用http.createServer()方法创建服务器，并使用listen方法绑定8888端口。 函数通过request, response参数来接收和响应数据。</p>\n<p>实例如下，在你项目的根目录下创建一个叫server.js的文件，并写入以下代码：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">var http = require('http');\n\nhttp.createServer(function (request, response) {\n\n\t// 发送 HTTP 头部 \n\t// HTTP 状态值: 200 : OK\n\t// 内容类型: text/plain\n\tresponse.writeHead(200, {'Content-Type': 'text/plain'});\n\n\t// 发送响应数据 \"Hello World\"\n\tresponse.end('Hello World\\n');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');</code></pre>\n<p>以上代码我们完成了一个可以工作的HTTP服务器。</p>\n<p>使用<strong>node</strong>命令执行以上的代码：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">node server.js\nServer running at http://127.0.0.1:8888/</code></pre>\n<p style=\"text-align: center; \">\n    <img src=\"https://atts.w3cschool.cn/attachments/image/20170627/1498557906641916.jpg\" alt=\"cmdrun\" class=\"\">\n    <br>\n</p>\n<p>接下来，打开浏览器访问http://127.0.0.1:8888/，你会看到一个写着\"Hello World\"的网页。</p>\n<p style=\"text-align: center; \">\n    <img src=\"https://atts.w3cschool.cn/attachments/image/20170627/1498557954225656.jpg\" alt=\"nodejs-helloworld\" class=\"\">\n    <br>\n</p>\n<p><strong>分析Node.js的HTTP服务器：</strong>\n</p>\n<ul>\n    <li>第一行请求（require）Node.js自带的 http 模块，并且把它赋值给http变量。</li>\n    <li>接下来我们调用http模块提供的函数：createServer 。这个函数会返回 一个对象，这个对象有一个叫做listen的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。</li>\n</ul>\n<hr>\n<h2>Gif 实例演示</h2>\n<p>接下来我们通过Gif图为大家演示实例操作：</p>\n<p style=\"text-align: center; \"><img src=\"//atts.w3cschool.cn/attachments/image/20190621/1561100595532221.gif\" alt=\"3-1-3\"><br></p><p><br></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "Node.js 教程",
      "teach_introduction": "Node.js 是运行在服务端的 JavaScript。",
      "sort_index": 2,
      "parent_sort_index": 1,
      "chapter_level_one_id": "5116f21e061867ab762063579329e921",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "Node.js 教程",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e58630bd127660c6ece0334d8cff805b",
      "chapter_level_two_parent_id": "5116f21e061867ab762063579329e921",
      "chapter_level_two_name": "Node.js 安装配置",
      "chapter_level_two_url": "/nodejs/nodejs-install-setup.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>Node.js 安装配置</h2> <p>本章节我们将向大家介绍在window和Linux上安装Node.js的方法。 </p> <p>本安装教程以Node.js v0.10.26 版本为例。</p> <p>Node.js安装包及源码下载地址为：<a href=\"https://nodejs.org/en/download/\" rel=\"external nofollow\" target=\"_blank\">http://www.nodejs.org/en/download/</a>。 </p><p style=\"text-align: center; \"><img src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/nodejs_download.jpg\" alt=\"nodejs_download\" width=\"659\" height=\"417\" class=\"alignnone size-full wp-image-6549\"></p> <p></p><p>根据不同平台系统选择你需要的Node.js安装包。</p><p></p> <p><strong>注意：</strong>Linux上安装Node.js需要安装Python 2.6 或 2.7 ，不建议安装Python 3.0以上版本。</p> <hr> <h2>Windowv 上安装Node.js</h2><p> <strong>Windows 安装包(.msi)</strong> :</p><p> 32 位安装包下载地址 : <a href=\"//nodejs.org/dist/v0.10.26/node-v0.10.26-x86.msi\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/dist/v0.10.26/node-v0.10.26-x86.msi</a></p><p> 64 位安装包下载地址 : <a href=\"//nodejs.org/dist/v0.10.26/x64/node-v0.10.26-x64.msi\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/dist/v0.10.26/x64/node-v0.10.26-x64.msi</a></p><p> 安装步骤：</p><p> 步骤 1 : 双击下载后的安装包 node-v0.10.26-x86.msi，如下所示：</p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step1\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step1.png\" width=\"414\" height=\"308\"> </p><p> 步骤 2 : 点击以上的Run(运行)，将出现如下界面： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step2\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step2.png\" width=\"508\" height=\"395\"> </p><p> 步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 : </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step3\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step3.png\" width=\"511\" height=\"400\"> </p><p> 步骤 4 : Node.js默认安装目录为 \"C:\\Program Files\\nodejs\\\" , 你可以修改目录，并点击 next（下一步）： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step4\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step4.png\" width=\"509\" height=\"400\"> </p><p> 步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步） </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step5\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step5.png\" width=\"506\" height=\"399\"> </p><p> 步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step6\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step6.png\" width=\"509\" height=\"397\"> </p><p> 安装过程： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step7\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step7.png\" width=\"511\" height=\"399\"></p><p> 点击 Finish（完成）按钮退出安装向导。 </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-windows-step8\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-windows-step8.png\" width=\"510\" height=\"397\"> </p> <p>检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入\"cmd\" =&gt; 输入命令\"path\"，输出如下结果：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32;\nC:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;\nc:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;\nC:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;\nC:\\Users\\rg\\AppData\\Roaming\\npm</code></pre> <p>我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\</p> <p>检查Node.js版本 </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"node-version-test\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/node-version-test.png\" width=\"240\" height=\"62\"> </p><p> <strong>Windows 二进制文件 (.exe)安装</strong> : </p><p> 32 位安装包下载地址 : <a href=\"//nodejs.org/dist/v0.10.26/node.exe\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/dist/v0.10.26/node.exe</a> </p><p> 64 位安装包下载地址 : <a href=\"//nodejs.org/dist/v0.10.26/x64/node.exe\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/dist/v0.10.26/x64/node.exe</a> </p><p> <strong>安装步骤</strong> </p><p> 步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 : </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-exe-on-windows-step1\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-exe-on-windows-step1.png\" width=\"417\" height=\"311\"> </p><p> 点击 Run（运行）按钮将出现命令行窗口： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-exe-on-windows-step21\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-exe-on-windows-step21.png\" width=\"436\" height=\"204\"> </p><p> 版本测试</p><p> 进入 node.exe 所在的目录，如下所示： </p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"node-version\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/node-version.png\" width=\"243\" height=\"62\"> </p><p> 如果你获得以上输出结果，说明你已经成功安装了Node.js。</p> <hr> <h2>Linux上安装 Node.js</h2> <h3>Ubuntu 源码安装</h3> <p> 以下部分我们将介绍在Ubuntu Linux下安装 Node.js 。 其他的Linux系统，如Centos等类似如下安装步骤。 </p><p> 在 Github 上获取 Node.js 源码：</p><p> </p><p style=\"text-align: center; \"><img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step1\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step1.png\" width=\"722\" height=\"52\"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step2\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step2.png\" width=\"724\" height=\"132\"> </p><p> 在完成下载后，将源码包名改为 'node'。</p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step3\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step3.png\" width=\"723\" height=\"188\"> </p><p> 修改目录权限：</p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step4\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step4.png\" width=\"724\" height=\"38\"> </p><p> 使用 './configure' 创建编译文件。</p><p style=\"text-align: center; \"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step5\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step5.png\" width=\"672\" height=\"687\"> </p><p> 编译: make。</p><p style=\"text-align: center;\"> <img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step6\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step6.png\" width=\"1303\" height=\"375\"> </p><p>完成安装: make install。 </p><p style=\"text-align: center; \"><img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step7\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step7.png\" width=\"452\" height=\"44\"> </p><p>最后我们输入'node --version' 命令来查看Node.js是否安装成功。 </p><p style=\"text-align: center; \"><img class=\"attachment-full\" alt=\"install-node-msi-version-on-linux-step8\" src=\"https://atts.w3cschool.cn/attachments/uploads/2014/03/install-node-msi-version-on-linux-step8.png\" width=\"431\" height=\"73\"> </p> <h3>Ubuntu apt-get命令安装</h3> <p>命令格式如下：</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">sudo apt-get install nodejs\nsudo apt-get install npm</code></pre> <h3>centOS下安装nodejs</h3> <p>1、下载源码，你需要在<a href=\"//nodejs.org/\" rel=\"external nofollow\" target=\"_blank\">http://nodejs.org/</a>下载最新的Nodejs版本，本文以v4.5.0为例:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">cd /usr/local/src/\nwget http://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz</code></pre> <p>2、解压源码</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">tar zxvf node-v4.5.0.tar.gz</code></pre> <p>3、 编译安装</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">cd node-v4.5.0\n./configure --prefix=/usr/local/node/4.5.0\nmake\nmake install</code></pre> <p>4、 配置NODE_HOME，进入profile编辑环境变量</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">vim /etc/profile</code></pre> <p> 设置nodejs环境变量，在<em>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</em> 一行的上面添加如下内容:</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">#set for nodejs\nexport NODE_HOME=/usr/local/node/4.5.0\nexport PATH=$NODE_HOME/bin:$PATH</code></pre> <p> :wq保存并退出，编译/etc/profile 使配置生效</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">source /etc/profile</code></pre> <p> 验证是否安装配置成功</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">node -v</code></pre> <p> 输出 v4.5.0 表示配置成功 </p> <p> npm模块安装路径</p><pre lang=\"javascript\" style=\"max-width: 100%;\"><code class=\"javascript\">/usr/local/node/4.5.0/lib/node_modules/</code></pre> <p><strong>注：</strong>Nodejs 官网提供了编译好的Linux二进制包，你也可以下载下来直接应用。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    }
  ]
}
