{
  "name": "TypeScript 教程",
  "author": "admin",
  "type": "前端进阶",
  "introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
  "data": [{
    "teach_name": "TypeScript 教程",
    "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
    "sort_index": 1,
    "parent_sort_index": 5,
    "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
    "chapter_level_one_parent_id": "0",
    "chapter_level_one_name": "TypeScript 手册指南",
    "chapter_level_one_url": "",
    "chapter_level_two_id": "f0ae7863b9f5c5855da6dab6af0c1de9",
    "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
    "chapter_level_two_name": "TypeScript 基础类型",
    "chapter_level_two_url": "/typescript/typescript-basic-types.html",
    "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>基础类型</h1><h1>介绍</h1><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><h1>布尔值</h1><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p><pre><code><span>let</span> isDone: <span>boolean</span> = <span>false</span>;\n</code></pre><h1>数字</h1><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，Typescript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><pre><code><span>let</span> decLiteral: <span>number</span> = <span>6</span>;\n<span>let</span> hexLiteral: <span>number</span> = <span>0xf00d</span>;\n<span>let</span> binaryLiteral: <span>number</span> = <span>0b1010</span>;\n<span>let</span> octalLiteral: <span>number</span> = <span>0o744</span>;\n</code></pre><h1>字符串</h1><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（ <code>\"</code>）或单引号（<code>'</code>）表示字符串。</p><pre><code><span>let</span> name: <span>string</span> = <span>\"bob\"</span>;\nname = <span>\"smith\"</span>;\n</code></pre><p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>`</code>），并且以<code>${ expr }</code>这种形式嵌入表达式</p><pre><code><span>let</span> name: <span>string</span> = <span>`Gene`</span>;\n<span>let</span> age: <span>number</span> = <span>37</span>;\n<span>let</span> sentence: <span>string</span> = <span>`Hello, my name is <span>${ name }</span>.\n\nI'll be <span>${ age + 1 }</span> years old next month.`</span>;\n</code></pre><p>这与下面定义<code>sentence</code>的方式效果相同：</p><pre><code><span>let</span> sentence: <span>string</span> = <span>\"Hello, my name is \"</span> + name + <span>\".\\n\\n\"</span> +\n    <span>\"I'll be \"</span> + (age + <span>1</span>) + <span>\" years old next month.\"</span>;\n</code></pre><h1>数组</h1><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</p><pre><code><span>let</span> list: <span>number</span>[] = [<span>1</span>, <span>2</span>, <span>3</span>];\n</code></pre><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p><pre><code><span>let</span> list: <span>Array</span>&lt;<span>number</span>&gt; = [<span>1</span>, <span>2</span>, <span>3</span>];\n</code></pre><h1>元组 Tuple</h1><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p><pre><code><span>// Declare a tuple type</span>\n<span>let</span> x: [<span>string</span>, <span>number</span>];\n<span>// Initialize it</span>\nx = [<span>'hello'</span>, <span>10</span>]; <span>// OK</span>\n<span>// Initialize it incorrectly</span>\nx = [<span>10</span>, <span>'hello'</span>]; <span>// Error</span>\n</code></pre><p>当访问一个已知索引的元素，会得到正确的类型：</p><pre><code><span>console</span>.log(x[<span>0</span>].substr(<span>1</span>)); <span>// OK</span>\n<span>console</span>.log(x[<span>1</span>].substr(<span>1</span>)); <span>// Error, 'number' does not have 'substr'</span>\n</code></pre><p>当访问一个越界的元素，会使用联合类型替代：</p><pre><code>x[<span>3</span>] = <span>'world'</span>; <span>// OK, 字符串可以赋值给(string | number)类型</span>\n\n<span>console</span>.log(x[<span>5</span>].toString()); <span>// OK, 'string' 和 'number' 都有 toString</span>\n\nx[<span>6</span>] = <span>true</span>; <span>// Error, 布尔不是(string | number)类型</span>\n</code></pre><p>联合类型是高级主题，我们会在以后的章节里讨论它。</p><h1>枚举</h1><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><pre><code><span>enum</span> Color {Red, Green, Blue};\n<span>let</span> c: Color = Color.Green;\n</code></pre><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p><pre><code><span>enum</span> Color {Red = <span>1</span>, Green, Blue};\n<span>let</span> c: Color = Color.Green;\n</code></pre><p>或者，全部都采用手动赋值：</p><pre><code><span>enum</span> Color {Red = <span>1</span>, Green = <span>2</span>, Blue = <span>4</span>};\n<span>let</span> c: Color = Color.Green;\n</code></pre><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><pre><code><span>enum</span> Color {Red = <span>1</span>, Green, Blue};\n<span>let</span> colorName: <span>string</span> = Color[<span>2</span>];\n\nalert(colorName);\n</code></pre><h1>任意值</h1><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p><pre><code><span>let</span> notSure: <span>any</span> = <span>4</span>;\nnotSure = <span>\"maybe a string instead\"</span>;\nnotSure = <span>false</span>; <span>// okay, definitely a boolean</span>\n</code></pre><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 <code>Object</code>有相似的作用，就像它在其它语言中那样。 但是 <code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><pre><code><span>let</span> notSure: <span>any</span> = <span>4</span>;\nnotSure.ifItExists(); <span>// okay, ifItExists might exist at runtime</span>\nnotSure.toFixed(); <span>// okay, toFixed exists (but the compiler doesn't check)</span>\n\n<span>let</span> prettySure: <span>Object</span> = <span>4</span>;\nprettySure.toFixed(); <span>// Error: Property 'toFixed' doesn't exist on type 'Object'.</span>\n</code></pre><p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><pre><code><span>let</span> list: <span>any</span>[] = [<span>1</span>, <span>true</span>, <span>\"free\"</span>];\n\nlist[<span>1</span>] = <span>100</span>;\n</code></pre><h1>空值</h1><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p><pre><code><span><span>function</span> <span>warnUser</span>(<span></span>): <span>void</span> </span>{\n    alert(<span>\"This is my warning message\"</span>);\n}\n</code></pre><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p><pre><code><span>let</span> unusable: <span>void</span> = <span>undefined</span>;\n</code></pre><h1>Null 和 Undefined</h1><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p><pre><code><span>// Not much else we can assign to these variables!</span>\n<span>let</span> u: <span>undefined</span> = <span>undefined</span>;\n<span>let</span> n: <span>null</span> = <span>null</span>;\n</code></pre><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p><p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免<em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p><blockquote><p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p></blockquote><h1>Never</h1><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p><p>下面是一些返回<code>never</code>类型的函数：</p><pre><code><span>// 返回never的函数必须存在无法达到的终点</span>\n<span><span>function</span> <span>error</span>(<span>message: <span>string</span></span>): <span>never</span> </span>{\n    <span>throw</span> <span>new</span> <span>Error</span>(message);\n}\n\n<span>// 推断的返回值类型为never</span>\n<span><span>function</span> <span>fail</span>(<span></span>) </span>{\n    <span>return</span> error(<span>\"Something failed\"</span>);\n}\n\n<span>// 返回never的函数必须存在无法达到的终点</span>\n<span><span>function</span> <span>infiniteLoop</span>(<span></span>): <span>never</span> </span>{\n    <span>while</span> (<span>true</span>) {\n    }\n}\n</code></pre><h1>类型断言</h1><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是“尖括号”语法：</p><pre><code><span>let</span> someValue: <span>any</span> = <span>\"this is a string\"</span>;\n\n<span>let</span> strLength: <span>number</span> = (&lt;<span>string</span>&gt;someValue).length;\n</code></pre><p>另一个为<code>as</code>语法：</p><pre><code><span>let</span> someValue: <span>any</span> = <span>\"this is a string\"</span>;\n\n<span>let</span> strLength: <span>number</span> = (someValue as <span>string</span>).length;\n</code></pre><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p><h1>关于<code>let</code></h1><p>你可能已经注意到了，我们使用<code>let</code>关键字来代替大家所熟悉的JavaScript关键字<code>var</code>。 <code>let</code>关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 <code>let</code>来解决，所以尽可能地使用<code>let</code>来代替<code>var</code>吧。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
  },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 20,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "06dd83f3da1da6af252e3a18a8555b4e",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript Mixins",
      "chapter_level_two_url": "/typescript/typescript-mixins.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript Mixins<span style=\"line-height: 1.7;\">介绍</span></h1><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。</p><h1>混入示例</h1><p>下面的代码演示了如何在TypeScript里使用混入。 后面我们还会解释这段代码是怎么工作的。</p><pre><code><span>// Disposable Mixin</span>\n<span>class</span> Disposable {\n    isDisposed: <span>boolean</span>;\n    dispose() {\n        <span>this</span>.isDisposed = <span>true</span>;\n    }\n\n}\n\n<span>// Activatable Mixin</span>\n<span>class</span> Activatable {\n    isActive: <span>boolean</span>;\n    activate() {\n        <span>this</span>.isActive = <span>true</span>;\n    }\n    deactivate() {\n        <span>this</span>.isActive = <span>false</span>;\n    }\n}\n\n<span>class</span> SmartObject <span>implements</span> Disposable, Activatable {\n    <span>constructor</span>() {\n        setInterval(() =&gt; <span>console</span>.log(<span>this</span>.isActive + <span>\" : \"</span> + <span>this</span>.isDisposed), <span>500</span>);\n    }\n\n    interact() {\n        <span>this</span>.activate();\n    }\n\n    <span>// Disposable</span>\n    isDisposed: <span>boolean</span> = <span>false</span>;\n    dispose: () =&gt; <span>void</span>;\n    <span>// Activatable</span>\n    isActive: <span>boolean</span> = <span>false</span>;\n    activate: () =&gt; <span>void</span>;\n    deactivate: () =&gt; <span>void</span>;\n}\napplyMixins(SmartObject, [Disposable, Activatable]);\n\n<span>let</span> smartObj = <span>new</span> SmartObject();\nsetTimeout(() =&gt; smartObj.interact(), <span>1000</span>);\n\n<span>////////////////////////////////////////</span>\n<span>// In your runtime library somewhere</span>\n<span>////////////////////////////////////////</span>\n\n<span><span>function</span> <span>applyMixins</span>(<span>derivedCtor: <span>any</span>, baseCtors: <span>any</span>[]</span>) </span>{\n    baseCtors.forEach(baseCtor =&gt; {\n        <span>Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n</code></pre><h1>理解这个例子</h1><p>代码里首先定义了两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。</p><pre><code><span>// Disposable Mixin</span>\n<span>class</span> Disposable {\n    isDisposed: <span>boolean</span>;\n    dispose() {\n        <span>this</span>.isDisposed = <span>true</span>;\n    }\n\n}\n\n<span>// Activatable Mixin</span>\n<span>class</span> Activatable {\n    isActive: <span>boolean</span>;\n    activate() {\n        <span>this</span>.isActive = <span>true</span>;\n    }\n    deactivate() {\n        <span>this</span>.isActive = <span>false</span>;\n    }\n}\n</code></pre><p>下面创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：</p><pre><code><span>class</span> SmartObject <span>implements</span> Disposable, Activatable {\n</code></pre><p>首先应该注意到的是，没使用<code>extends</code>而是使用<code>implements</code>。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。</p><p>我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。</p><pre><code><span>// Disposable</span>\nisDisposed: <span>boolean</span> = <span>false</span>;\ndispose: () =&gt; <span>void</span>;\n<span>// Activatable</span>\nisActive: <span>boolean</span> = <span>false</span>;\nactivate: () =&gt; <span>void</span>;\ndeactivate: () =&gt; <span>void</span>;\n</code></pre><p>最后，把mixins混入定义的类，完成全部实现部分。</p><pre><code>applyMixins(SmartObject, [Disposable, Activatable]);\n</code></pre><p>最后，创建这个帮助函数，帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</p><pre><code><span><span>function</span> <span>applyMixins</span>(<span>derivedCtor: <span>any</span>, baseCtors: <span>any</span>[]</span>) </span>{\n    baseCtors.forEach(baseCtor =&gt; {\n        <span>Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        })\n    });\n}\n</code><div>\n</div></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 19,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "4ee9e140834f68ac593246ca9ccc86d2",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 装饰器",
      "chapter_level_two_url": "/typescript/typescript-decorators.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript装饰器<span style=\"line-height: 1.7;\">介绍</span></h1><p>随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在 <a href=\"https://github.com/wycats/javascript-decorators/blob/master/README.md\" rel=\"external nofollow\" target=\"_blank\">建议征集的第一阶段</a>，但在TypeScript里已做为一项实验性特性予以支持。</p><blockquote><p>注意  装饰器是一项实验性特性，在未来的版本中可能会发生改变。</p></blockquote><p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p><p><strong>命令行</strong>:</p><pre><code>tsc --target ES5 --experimentalDecorators\n</code></pre><p><strong>tsconfig.json</strong>:</p><pre><code>{\n    <span>\"compilerOptions\"</span>: {\n        <span>\"target\"</span>: <span>\"ES5\"</span>,\n        <span>\"experimentalDecorators\"</span>: <span>true</span>\n    }\n}\n</code></pre><h1>装饰器</h1><p><em>装饰器</em>是一种特殊类型的声明，它能够被附加到<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#class-decorators\" rel=\"external nofollow\" target=\"_blank\">类声明</a>，<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#method-decorators\" rel=\"external nofollow\" target=\"_blank\">方法</a>， <a href=\"http://www.tslang.cn/docs/handbook/decorators.html#accessor-decorators\" rel=\"external nofollow\" target=\"_blank\">访问符</a>，<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#property-decorators\" rel=\"external nofollow\" target=\"_blank\">属性</a>或<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#parameter-decorators\" rel=\"external nofollow\" target=\"_blank\">参数</a>上。 装饰器使用<code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><p>例如，有一个<code>@sealed</code>装饰器，我们会这样定义<code>sealed</code>函数：</p><pre><code><span><span>function</span> <span>sealed</span>(<span>target</span>) </span>{\n    <span>// do something with \"target\" ...</span>\n}\n</code></pre><blockquote><p>注意  后面<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#class-decorators\" rel=\"external nofollow\" target=\"_blank\">类装饰器</a>小节里有一个更加详细的例子。</p></blockquote><h2><a name=\"decorator-factories\"></a>装饰器工厂</h2><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 <em>装饰器工厂</em>就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p><p>我们可以通过下面的方式来写一个装饰器工厂函数：</p><pre><code><span><span>function</span> <span>color</span>(<span>value: <span>string</span></span>) </span>{ <span>// 这是一个装饰器工厂</span>\n    <span>return</span> <span><span>function</span> (<span>target</span>) </span>{ <span>//  这是装饰器</span>\n        <span>// do something with \"target\" and \"value\"...</span>\n    }\n}\n</code></pre><blockquote><p>注意  下面<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#method-decorators\" rel=\"external nofollow\" target=\"_blank\">方法装饰器</a>小节里有一个更加详细的例子。</p></blockquote><h2>装饰器组合</h2><p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p><ul><li>书写在同一行上：</li></ul><pre><code>@f @g x\n</code></pre><ul><li>书写在多行上：</li></ul><pre><code>@f\n@g\nx\n</code></pre><p>当多个装饰器应用于一个声明上，它们求值方式与<a href=\"http://en.wikipedia.org/wiki/Function_composition\" rel=\"external nofollow\" target=\"_blank\">复合函数</a>相似。在这个模型下，当复合<em>f</em>和<em>g</em>时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于<em>f</em>(<em>g</em>(<em>x</em>))。</p><p>同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ol><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用。</li></ol><p>如果我们使用<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#decorator-factories\" rel=\"external nofollow\" target=\"_blank\">装饰器工厂</a>的话，可以通过下面的例子来观察它们求值的顺序：</p><pre><code><span><span>function</span> <span>f</span>(<span></span>) </span>{\n    <span>console</span>.log(<span>\"f(): evaluated\"</span>);\n    <span>return</span> <span><span>function</span> (<span>target, propertyKey: <span>string</span>, descriptor: PropertyDescriptor</span>) </span>{\n        <span>console</span>.log(<span>\"f(): called\"</span>);\n    }\n}\n\n<span><span>function</span> <span>g</span>(<span></span>) </span>{\n    <span>console</span>.log(<span>\"g(): evaluated\"</span>);\n    <span>return</span> <span><span>function</span> (<span>target, propertyKey: <span>string</span>, descriptor: PropertyDescriptor</span>) </span>{\n        <span>console</span>.log(<span>\"g(): called\"</span>);\n    }\n}\n\n<span>class</span> C {\n    @f()\n    @g()\n    method() {}\n}\n</code></pre><p>在控制台里会打印出如下结果：</p><pre><code>f(): evaluated\ng(): evaluated\ng(): called\nf(): called\n</code></pre><h2>装饰器求值</h2><p>类中不同声明上的装饰器将按以下规定的顺序应用：</p><ol><li><em>参数装饰器</em>，其次是<em>方法</em>，<em>访问符</em>，或<em>属性装饰器</em>应用到每个实例成员。</li><li><em>参数装饰器</em>，其次是<em>方法</em>，<em>访问符</em>，或<em>属性装饰器</em>应用到每个静态成员。</li><li><em>参数装饰器</em>应用到构造函数。</li><li><em>类装饰器</em>应用到类。</li></ol><h2><a name=\"class-decorators\"></a>类装饰器</h2><p><em>类装饰器</em>在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中( <code>.d.ts</code>)，也不能用在任何外部上下文中（比如<code>declare</code>的类）。</p><p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p><p>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p><blockquote><p>注意  如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中 <em>不会</em>为你做这些。</p></blockquote><p>下面是使用类装饰器(<code>@sealed</code>)的例子，应用在<code>Greeter</code>类：</p><pre><code>@sealed\n<span>class</span> Greeter {\n    greeting: <span>string</span>;\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;\n    }\n    greet() {\n        <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;\n    }\n}\n</code></pre><p>我们可以这样定义<code>@sealed</code>装饰器：</p><pre><code><span><span>function</span> <span>sealed</span>(<span>constructor: <span>Function</span></span>) </span>{\n    <span>Object</span>.seal(<span>constructor</span>);\n    Object.seal(<span>constructor</span>.prototype);\n}\n</code></pre><p>当<code>@sealed</code>被执行的时候，它将密封此类的构造函数和原型。(注：参见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\" rel=\"external nofollow\" target=\"_blank\">Object.seal</a>)</p><h2><a name=\"method-decorators\"></a>方法装饰器</h2><p><em>方法装饰器</em>声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 <em>属性描述符</em>上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件( <code>.d.ts</code>)，重载或者任何外部上下文（比如<code>declare</code>的类）中。</p><p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>成员的<em>属性描述符</em>。</li></ol><blockquote><p>注意  如果代码输出目标版本小于<code>ES5</code>，<em>Property Descriptor</em>将会是<code>undefined</code>。</p></blockquote><p>如果方法装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p><blockquote><p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p></blockquote><p>下面是一个方法装饰器（<code>@enumerable</code>）的例子，应用于<code>Greeter</code>类的方法上：</p><pre><code><span>class</span> Greeter {\n    greeting: <span>string</span>;\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;\n    }\n\n    @enumerable(<span>false</span>)\n    greet() {\n        <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;\n    }\n}\n</code></pre><p>我们可以用下面的函数声明来定义<code>@enumerable</code>装饰器：</p><pre><code><span><span>function</span> <span>enumerable</span>(<span>value: <span>boolean</span></span>) </span>{\n    <span>return</span> <span><span>function</span> (<span>target: <span>any</span>, propertyKey: <span>string</span>, descriptor: PropertyDescriptor</span>) </span>{\n        descriptor.enumerable = value;\n    };\n}\n</code></pre><p>这里的<code>@enumerable(false)</code>是一个<a href=\"http://www.tslang.cn/docs/handbook/decorators.html#decorator-factories\" rel=\"external nofollow\" target=\"_blank\">装饰器工厂</a>。 当装饰器 <code>@enumerable(false)</code>被调用时，它会修改属性描述符的<code>enumerable</code>属性。</p><h2><a name=\"accessor-decorators\"></a>访问器装饰器</h2><p><em>访问器装饰器</em>声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 <em>属性描述符</em>并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 <code>declare</code>的类）里。</p><blockquote><p>注意  TypeScript不允许同时装饰一个成员的<code>get</code>和<code>set</code>访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个<em>属性描述符</em>时，它联合了<code>get</code>和<code>set</code>访问器，而不是分开声明的。</p></blockquote><p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>成员的<em>属性描述符</em>。</li></ol><blockquote><p>注意  如果代码输出目标版本小于<code>ES5</code>，<em>Property Descriptor</em>将会是<code>undefined</code>。</p></blockquote><p>如果访问器装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p><blockquote><p>注意  如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p></blockquote><p>下面是使用了访问器装饰器（<code>@configurable</code>）的例子，应用于<code>Point</code>类的成员上：</p><pre><code><span>class</span> Point {\n    <span>private</span> _x: <span>number</span>;\n    <span>private</span> _y: <span>number</span>;\n    <span>constructor</span>(x: number, y: number) {\n        <span>this</span>._x = x;\n        <span>this</span>._y = y;\n    }\n\n    @configurable(<span>false</span>)\n    <span>get</span> x() { <span>return</span> <span>this</span>._x; }\n\n    @configurable(<span>false</span>)\n    <span>get</span> y() { <span>return</span> <span>this</span>._y; }\n}\n</code></pre><p>我们可以通过如下函数声明来定义<code>@configurable</code>装饰器：</p><pre><code><span><span>function</span> <span>configurable</span>(<span>value: <span>boolean</span></span>) </span>{\n    <span>return</span> <span><span>function</span> (<span>target: <span>any</span>, propertyKey: <span>string</span>, descriptor: PropertyDescriptor</span>) </span>{\n        descriptor.configurable = value;\n    };\n}\n</code></pre><h2><a name=\"property-decorators\"></a>属性装饰器</h2><p><em>属性装饰器</em>声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 <code>declare</code>的类）里。</p><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li></ol><blockquote><p>注意  <em>属性描述符</em>不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。 因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p></blockquote><p>如果属性装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p><blockquote><p>注意  如果代码输出目标版本小于<code>ES5</code>，返回值会被忽略。</p></blockquote><p>如果访问符装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p><p>我们可以用它来记录这个属性的元数据，如下例所示：</p><pre><code><span>class</span> Greeter {\n    @format(<span>\"Hello, %s\"</span>)\n    greeting: <span>string</span>;\n\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;\n    }\n    greet() {\n        <span>let</span> formatString = getFormat(<span>this</span>, <span>\"greeting\"</span>);\n        <span>return</span> formatString.replace(<span>\"%s\"</span>, <span>this</span>.greeting);\n    }\n}\n</code></pre><p>然后定义<code>@format</code>装饰器和<code>getFormat</code>函数：</p><pre><code><span>import</span> <span>\"reflect-metadata\"</span>;\n\n<span>const</span> formatMetadataKey = Symbol(<span>\"format\"</span>);\n\n<span><span>function</span> <span>format</span>(<span>formatString: <span>string</span></span>) </span>{\n    <span>return</span> Reflect.metadata(formatMetadataKey, formatString);\n}\n\n<span><span>function</span> <span>getFormat</span>(<span>target: <span>any</span>, propertyKey: <span>string</span></span>) </span>{\n    <span>return</span> Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n</code></pre><p>这个<code>@format(\"Hello, %s\")</code>装饰器是个 <a href=\"http://www.tslang.cn/docs/handbook/decorators.html#decorator-factories\" rel=\"external nofollow\" target=\"_blank\">装饰器工厂</a>。 当 <code>@format(\"Hello, %s\")</code>被调用时，它添加一条这个属性的元数据，通过<code>reflect-metadata</code>库里的<code>Reflect.metadata</code>函数。 当 <code>getFormat</code>被调用时，它读取格式的元数据。</p><blockquote><p>注意  这个例子需要使用<code>reflect-metadata</code>库。 查看 <a href=\"http://www.tslang.cn/docs/handbook/decorators.html#metadata\" rel=\"external nofollow\" target=\"_blank\">元数据</a>了解<code>reflect-metadata</code>库更详细的信息。</p></blockquote><h2><a name=\"parameter-decorators\"></a>参数装饰器</h2><p><em>参数装饰器</em>声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如 <code>declare</code>的类）里。</p><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>参数在函数参数列表中的索引。</li></ol><blockquote><p>注意  参数装饰器只能用来监视一个方法的参数是否被传入。</p></blockquote><p>参数装饰器的返回值会被忽略。</p><p>下例定义了参数装饰器（<code>@required</code>）并应用于<code>Greeter</code>类方法的一个参数：</p><pre><code><span>class</span> Greeter {\n    greeting: <span>string</span>;\n\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;\n    }\n\n    @validate\n    greet(@required name: <span>string</span>) {\n        <span>return</span> <span>\"Hello \"</span> + name + <span>\", \"</span> + <span>this</span>.greeting;\n    }\n}\n</code></pre><p>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器：</p><pre><code><span>import</span> <span>\"reflect-metadata\"</span>;\n\n<span>const</span> requiredMetadataKey = Symbol(<span>\"required\"</span>);\n\n<span><span>function</span> <span>required</span>(<span>target: <span>Object</span>, propertyKey: <span>string</span> | symbol, parameterIndex: <span>number</span></span>) </span>{\n    <span>let</span> existingRequiredParameters: <span>number</span>[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n    existingRequiredParameters.push(parameterIndex);\n    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\n<span><span>function</span> <span>validate</span>(<span>target: <span>any</span>, propertyName: <span>string</span>, descriptor: TypedPropertyDescriptor&lt;<span>Function</span>&gt;</span>) </span>{\n    <span>let</span> method = descriptor.value;\n    descriptor.value = <span><span>function</span> (<span></span>) </span>{\n        <span>let</span> requiredParameters: <span>number</span>[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n        <span>if</span> (requiredParameters) {\n            <span>for</span> (<span>let</span> parameterIndex of requiredParameters) {\n                <span>if</span> (parameterIndex &gt;= <span>arguments</span>.length || <span>arguments</span>[parameterIndex] === <span>undefined</span>) {\n                    <span>throw</span> <span>new</span> <span>Error</span>(<span>\"Missing required argument.\"</span>);\n                }\n            }\n        }\n\n        <span>return</span> method.apply(<span>this</span>, <span>arguments</span>);\n    }\n}\n</code></pre><p><code>@required</code>装饰器添加了元数据实体把参数标记为必需的。 <code>@validate</code>装饰器把<code>greet</code>方法包裹在一个函数里在调用原先的函数前验证函数参数。</p><blockquote><p>注意  这个例子使用了<code>reflect-metadata</code>库。 查看 <a href=\"http://www.tslang.cn/docs/handbook/decorators.html#metadata\" rel=\"external nofollow\" target=\"_blank\">元数据</a>了解<code>reflect-metadata</code>库的更多信息。</p></blockquote><h2>元数据</h2><p>一些例子使用了<code>reflect-metadata</code>库来支持<a href=\"https://github.com/rbuckton/ReflectDecorators\" rel=\"external nofollow\" target=\"_blank\">实验性的metadata API</a>。 这个库还不是ECMAScript (JavaScript)标准的一部分。 然而，当装饰器被ECMAScript官方标准采纳后，这些扩展也将被推荐给ECMAScript以采纳。</p><p>你可以通过npm安装这个库：</p><pre><code>npm i reflect-metadata --save\n</code></pre><p>TypeScript支持为带有装饰器的声明生成元数据。 你需要在命令行或 <code>tsconfig.json</code>里启用<code>emitDecoratorMetadata</code>编译器选项。</p><p><strong>Command Line</strong>:</p><pre><code>tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n</code></pre><p><strong>tsconfig.json</strong>:</p><pre><code>{\n    <span>\"compilerOptions\"</span>: {\n        <span>\"target\"</span>: <span>\"ES5\"</span>,\n        <span>\"experimentalDecorators\"</span>: <span>true</span>,\n        <span>\"emitDecoratorMetadata\"</span>: <span>true</span>\n    }\n}\n</code></pre><p>当启用后，只要<code>reflect-metadata</code>库被引入了，设计阶段添加的类型信息可以在运行时使用。</p><p>如下例所示：</p><pre><code><span>import</span> <span>\"reflect-metadata\"</span>;\n\n<span>class</span> Point {\n    x: <span>number</span>;\n    y: <span>number</span>;\n}\n\n<span>class</span> Line {\n    <span>private</span> _p0: Point;\n    <span>private</span> _p1: Point;\n\n    @validate\n    <span>set</span> p0(value: Point) { <span>this</span>._p0 = value; }\n    <span>get</span> p0() { <span>return</span> <span>this</span>._p0; }\n\n    @validate\n    <span>set</span> p1(value: Point) { <span>this</span>._p1 = value; }\n    <span>get</span> p1() { <span>return</span> <span>this</span>._p1; }\n}\n\n<span><span>function</span> <span>validate</span>&lt;<span>T</span>&gt;(<span>target: <span>any</span>, propertyKey: <span>string</span>, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) </span>{\n    <span>let</span> <span>set</span> = descriptor.set;\n    descriptor.set = <span><span>function</span> (<span>value: T</span>) </span>{\n        <span>let</span> <span>type</span> = Reflect.getMetadata(<span>\"design:type\"</span>, target, propertyKey);\n        <span>if</span> (!(value <span>instanceof</span> <span>type</span>)) {\n            <span>throw</span> <span>new</span> <span>TypeError</span>(<span>\"Invalid type.\"</span>);\n        }\n    }\n}\n</code></pre><p>TypeScript编译器可以通过<code>@Reflect.metadata</code>装饰器注入设计阶段的类型信息。 你可以认为它相当于下面的TypeScript：</p><pre><code><span>class</span> Line {\n    <span>private</span> _p0: Point;\n    <span>private</span> _p1: Point;\n\n    @validate\n    @Reflect.metadata(<span>\"design:type\"</span>, Point)\n    <span>set</span> p0(value: Point) { <span>this</span>._p0 = value; }\n    <span>get</span> p0() { <span>return</span> <span>this</span>._p0; }\n\n    @validate\n    @Reflect.metadata(<span>\"design:type\"</span>, Point)\n    <span>set</span> p1(value: Point) { <span>this</span>._p1 = value; }\n    <span>get</span> p1() { <span>return</span> <span>this</span>._p1; }\n}\n\n</code></pre><blockquote><p>注意  装饰器元数据是个实验性的特性并且可能在以后的版本中发生破坏性的改变（breaking changes）。</p></blockquote></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 18,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e6c84eb52c16d394fd7b47ed49f14180",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript JSX",
      "chapter_level_two_url": "/typescript/typescript-jsx.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript JSX<span style=\"line-height: 1.7;\">介绍</span></h1><p><a href=\"https://facebook.github.io/jsx/\" rel=\"external nofollow\" target=\"_blank\">JSX</a>是一种嵌入式的类似XML的语法。 它可以被转换成合法的JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX因 <a href=\"http://facebook.github.io/react/\" rel=\"external nofollow\" target=\"_blank\">React</a>框架而流行，但是也被其它应用所使用。 TypeScript支持内嵌，类型检查和将JSX直接编译为JavaScript。</p><h1>基本用法</h1><p>想要使用JSX必须做两件事：</p><ol><li>给文件一个<code>.tsx</code>扩展名</li><li>启用<code>jsx</code>选项</li></ol><p>TypeScript具有两种JSX模式：<code>preserve</code>和<code>react</code>。 这些模式只在代码生成阶段起作用 - 类型检查并不受影响。 在 <code>preserve</code>模式下生成代码中会保留JSX以供后续的转换操作使用（比如：<a href=\"https://babeljs.io/\" rel=\"external nofollow\" target=\"_blank\">Babel</a>）。 另外，输出文件会带有<code>.jsx</code>扩展名。 <code>react</code>模式会生成<code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为<code>.js</code>。</p><table><thead><tr><th>模式</th><th>输入</th><th>输出</th><th>输出文件扩展名</th></tr></thead><tbody><tr><td><code>preserve</code></td><td><code>&lt;div /&gt;</code></td><td><code>&lt;div /&gt;</code></td><td><code>.jsx</code></td></tr><tr><td><code>react</code></td><td><code>&lt;div /&gt;</code></td><td><code>React.createElement(\"div\")</code></td><td><code>.js</code></td></tr></tbody></table><p>你可以通过在命令行里使用<code>--jsx</code>标记或<a href=\"http://www.tslang.cn/docs/handbook/tsconfig.json.md\" rel=\"external nofollow\" target=\"_blank\">tsconfig.json</a>里的选项来指定模式。</p><blockquote><p><em>注意：<code>React</code>标识符是写死的硬代码，所以你必须保证React（大写的R）是可用的。 Note: The identifier<code>React</code> is hard-coded, so you must make React available with an uppercase R.</em></p></blockquote><h1><code>as</code>操作符</h1><p>回想一下怎么写类型断言：</p><pre><code><span>var</span> foo = &lt;foo&gt;bar;\n</code></pre><p>这里我们断言<code>bar</code>变量是<code>foo</code>类型的。 因为TypeScript也使用尖括号来表示类型断言，JSX的语法带来了解析的困难。因此，TypeScript在 <code>.tsx</code>文件里禁用了使用尖括号的类型断言。</p><p>为了弥补<code>.tsx</code>里的这个功能，新加入了一个类型断言符号：<code>as</code>。 上面的例子可以很容易地使用 <code>as</code>操作符改写：</p><pre><code><span>var</span> foo = bar as foo;\n</code></pre><p><code>as</code>操作符在<code>.ts</code>和<code>.tsx</code>里都可用，并且与其它类型断言行为是等价的。</p><h1>类型检查</h1><p>为了理解JSX的类型检查，你必须首先理解固有元素与基于值的元素之间的区别。 假设有这样一个JSX表达式 <code>&lt;expr /&gt;</code>，<code>expr</code>可能引用环境自带的某些东西（比如，在DOM环境里的<code>div</code>或<code>span</code>）或者是你自定义的组件。 这是非常重要的，原因有如下两点：</p><ol><li>对于React，固有元素会生成字符串（<code>React.createElement(\"div\")</code>），然而由你自定义的组件却不会生成（<code>React.createElement(MyComponent)</code>）。</li><li>传入JSX元素里的属性类型的查找方式不同。 固有元素属性 <em>本身</em>就支持，然而自定义的组件会自己去指定它们具有哪个属性。</li></ol><p>TypeScript使用<a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\" rel=\"external nofollow\" target=\"_blank\">与React相同的规范</a> 来区别它们。 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。</p><h2>固有元素</h2><p>固有元素使用特殊的接口<code>JSX.IntrinsicElements</code>来查找。 默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。 然而，如果接口存在，那么固有元素的名字需要在 <code>JSX.IntrinsicElements</code>接口的属性里查找。 例如：</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n    <span>interface</span> IntrinsicElements {\n        foo: <span>any</span>\n    }\n}\n\n&lt;foo /&gt;; <span>// 正确</span>\n&lt;bar /&gt;; <span>// 错误</span>\n</code></pre><p>在上例中，<code>&lt;foo /&gt;</code>没有问题，但是<code>&lt;bar /&gt;</code>会报错，因为它没在<code>JSX.IntrinsicElements</code>里指定。</p><blockquote><p>注意：你也可以在<code>JSX.IntrinsicElements</code>上指定一个用来捕获所有字符串索引：</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n   <span>interface</span> IntrinsicElements {\n       [elemName: <span>string</span>]: <span>any</span>;\n   }\n}\n</code></pre></blockquote><h2>基于值的元素</h2><p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p><pre><code><span>import</span> MyComponent from <span>\"./myComponent\"</span>;\n\n&lt;MyComponent /&gt;; <span>// 正确</span>\n&lt;SomeOtherComponent /&gt;; <span>// 错误</span>\n</code></pre><p>可以限制基于值的元素的类型。 然而，为了这么做我们需要引入两个新的术语： <em>元素类的类型</em>和<em>元素实例的类型</em>。</p><p>现在有<code>&lt;Expr /&gt;</code>，<em>元素类的类型</em>为<code>Expr</code>的类型。 所以在上面的例子里，如果 <code>MyComponent</code>是ES6的类，那么它的类类型就是这个类。 如果 <code>MyComponent</code>是个工厂函数，类类型为这个函数。</p><p>一旦建立起了类类型，实例类型就确定了，为类类型调用签名的返回值与构造签名的联合类型。 再次说明，在ES6类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。</p><pre><code><span>class</span> MyComponent {\n  render() {}\n}\n\n<span>// 使用构造签名</span>\n<span>var</span> myComponent = <span>new</span> MyComponent();\n\n<span>// 元素类的类型 =&gt; MyComponent</span>\n<span>// 元素实例的类型 =&gt; { render: () =&gt; void }</span>\n\n<span><span>function</span> <span>MyFactoryFunction</span>(<span></span>) </span>{\n  <span>return</span> {\n    render: () =&gt; {\n    }\n  }\n}\n\n<span>// 使用调用签名</span>\n<span>var</span> myComponent = MyFactoryFunction();\n\n<span>// 元素类的类型 =&gt; FactoryFunction</span>\n<span>// 元素实例的类型 =&gt; { render: () =&gt; void }</span>\n</code></pre><p>元素的实例类型很有趣，因为它必须赋值给<code>JSX.ElementClass</code>或抛出一个错误。 默认的 <code>JSX.ElementClass</code>为<code>{}</code>，但是它可以被扩展用来限制JSX的类型以符合相应的接口。</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n  <span>interface</span> ElementClass {\n    render: <span>any</span>;\n  }\n}\n\n<span>class</span> MyComponent {\n  render() {}\n}\n<span><span>function</span> <span>MyFactoryFunction</span>(<span></span>) </span>{\n  <span>return</span> { render: () =&gt; {} }\n}\n\n&lt;MyComponent /&gt;; <span>// 正确</span>\n&lt;MyFactoryFunction /&gt;; <span>// 正确</span>\n\n<span>class</span> NotAValidComponent {}\n<span><span>function</span> <span>NotAValidFactoryFunction</span>(<span></span>) </span>{\n  <span>return</span> {};\n}\n\n&lt;NotAValidComponent /&gt;; <span>// 错误</span>\n&lt;NotAValidFactoryFunction /&gt;; <span>// 错误</span>\n</code></pre><h2>属性类型检查</h2><p>属性类型检查的第一步是确定<em>元素属性类型</em>。 这在固有元素和基于值的元素之间稍有不同。</p><p>对于固有元素，这是<code>JSX.IntrinsicElements</code>属性的类型。</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n  <span>interface</span> IntrinsicElements {\n    foo: { bar?: <span>boolean</span> }\n  }\n}\n\n<span>// `foo`的元素属性类型为`{bar?: boolean}`</span>\n&lt;foo bar /&gt;;\n</code></pre><p>对于基于值的元素，就稍微复杂些。 它取决于先前确定的在元素实例类型上的某个属性的类型。 至于该使用哪个属性来确定类型取决于 <code>JSX.ElementAttributesProperty</code>。 它应该使用单一的属性来定义。 这个属性名之后会被使用。</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n  <span>interface</span> ElementAttributesProperty {\n    props; <span>// 指定用来使用的属性名</span>\n  }\n}\n\n<span>class</span> MyComponent {\n  <span>// 在元素实例类型上指定属性</span>\n  props: {\n    foo?: <span>string</span>;\n  }\n}\n\n<span>// `MyComponent`的元素属性类型为`{foo?: string}`</span>\n&lt;MyComponent foo=<span>\"bar\"</span> /&gt;\n</code></pre><p>元素属性类型用于的JSX里进行属性的类型检查。 支持可选属性和必须属性。</p><pre><code><span>declare</span> <span>namespace</span> JSX {\n  <span>interface</span> IntrinsicElements {\n    foo: { requiredProp: <span>string</span>; optionalProp?: <span>number</span> }\n  }\n}\n\n&lt;foo requiredProp=<span>\"bar\"</span> /&gt;; <span>// 正确</span>\n&lt;foo requiredProp=<span>\"bar\"</span> optionalProp={<span>0</span>} /&gt;; <span>// 正确</span>\n&lt;foo /&gt;; <span>// 错误, 缺少 requiredProp</span>\n&lt;foo requiredProp={<span>0</span>} /&gt;; <span>// 错误, requiredProp 应该是字符串</span>\n&lt;foo requiredProp=<span>\"bar\"</span> unknownProp /&gt;; <span>// 错误, unknownProp 不存在</span>\n&lt;foo requiredProp=<span>\"bar\"</span> some-unknown-prop /&gt;; <span>// 正确, `some-unknown-prop`不是个合法的标识符</span>\n</code></pre><blockquote><p>注意：如果一个属性名不是个合法的JS标识符（像<code>data-*</code>属性），并且它没出现在元素属性类型里时不会当做一个错误。</p></blockquote><p>延展操作符也可以使用：</p><pre><code><span>var</span> props = { requiredProp: <span>'bar'</span> };\n&lt;foo {...props} /&gt;; // 正确\n\nvar badProps = {};\n&lt;foo {...badProps} /&gt;; // 错误\n</code></pre><h1>JSX结果类型</h1><p>默认地JSX表达式结果的类型为<code>any。 你可以自定义这个类型，通过指定</code>JSX.Element`接口。 然而，不能够从接口里检索元素，属性或JSX的子元素的类型信息。 它是一个黑盒。</p><h1>嵌入的表达式</h1><p>JSX允许你使用<code>{ }</code>标签来内嵌表达式。</p><pre><code><span>var</span> a = <span><span>&lt;<span>div</span>&gt;</span>\n  {['foo', 'bar'].map(i =&gt; <span>&lt;<span>span</span>&gt;</span>{i / 2}<span>&lt;/<span>span</span>&gt;</span>)}\n<span>&lt;/<span>div</span>&gt;</span></span>\n</code></pre><p>上面的代码产生一个错误，因为你不能用数字来除以一个字符串。 输出如下，若你使用了 <code>preserve</code>选项：</p><pre><code><span>var</span> a = <span><span>&lt;<span>div</span>&gt;</span>\n  {['foo', 'bar'].map(function (i) { return <span>&lt;<span>span</span>&gt;</span>{i / 2}<span>&lt;/<span>span</span>&gt;</span>; })}\n<span>&lt;/<span>div</span>&gt;</span></span>\n</code></pre><h1>React整合</h1><p>要想一起使用JSX和React，你应该使用<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react\" rel=\"external nofollow\" target=\"_blank\">React类型定义</a>。 这些类型声明定义了 <code>JSX</code>合适命名空间来使用React。</p><pre><code><span>/// &lt;reference path=\"react.d.ts\" /&gt;</span>\n\n<span>interface</span> Props {\n  foo: <span>string</span>;\n}\n\n<span>class</span> MyComponent extends React.Component&lt;Props, {}&gt; {\n  render() {\n    <span>return</span> &lt;span&gt;{<span>this</span>.props.foo}&lt;<span>/span&gt;\n  }\n}\n\n&lt;MyComponent foo=\"bar\" /</span>&gt;; <span>// 正确</span>\n&lt;MyComponent foo={<span>0</span>} /&gt;; <span>// 错误</span></code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 17,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "bc14f0ad8a14dd06a98f78d5c8cea7c3",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 声明合并",
      "chapter_level_two_url": "/typescript/typescript-declaration-merging.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>声明合并</h1><h1>介绍</h1><p>TypeScript中有些独特的概念可以在类型层面上描述JavaScript对象的模型。 这其中尤其独特的一个例子是“声明合并”的概念。 理解了这个概念，将有助于操作现有的JavaScript代码。 同时，也会有助于理解更多高级抽象的概念。</p><p>对本文件来讲，“声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。</p><h1>基础概念</h1><p>Typescript中的声明会创建以下三种实体之一：命名空间，类型或值。 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。</p><table><thead><tr><th>Declaration Type</th><th>Namespace</th><th>Type</th><th>Value</th></tr></thead><tbody><tr><td>Namespace</td><td>X</td><td> </td><td>X</td></tr><tr><td>Class</td><td> </td><td>X</td><td>X</td></tr><tr><td>Enum</td><td> </td><td>X</td><td>X</td></tr><tr><td>Interface</td><td> </td><td>X</td><td> </td></tr><tr><td>Type Alias</td><td> </td><td>X</td><td> </td></tr><tr><td>Function</td><td> </td><td> </td><td>X</td></tr><tr><td>Variable</td><td> </td><td> </td><td>X</td></tr></tbody></table><p>理解每个声明创建了什么，有助于理解当声明合并时有哪些东西被合并了。</p><h1>合并接口</h1><p>最简单也最常见的声明合并类型是接口合并。 从根本上说，合并的机制是把双方的成员放到一个同名的接口里。</p><pre><code><span>interface</span> Box {\n    height: <span>number</span>;\n    width: <span>number</span>;\n}\n\n<span>interface</span> Box {\n    scale: <span>number</span>;\n}\n\n<span>let</span> box: Box = {height: <span>5</span>, width: <span>6</span>, scale: <span>10</span>};\n</code></pre><p>接口的非函数的成员必须是唯一的。 如果两个接口中同时声明了同名的非函数成员编译器则会报错。</p><p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口 <code>A</code>与后来的接口<code>A</code>合并时，后面的接口具有更高的优先级。</p><p>如下例所示：</p><pre><code><span>interface</span> Cloner {\n    clone(animal: Animal): Animal;\n}\n\n<span>interface</span> Cloner {\n    clone(animal: Sheep): Sheep;\n}\n\n<span>interface</span> Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n}\n</code></pre><p>这三个接口合并成一个声明：</p><pre><code><span>interface</span> Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n    clone(animal: Sheep): Sheep;\n    clone(animal: Animal): Animal;\n}\n</code></pre><p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。</p><p>这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 <em>单一</em>的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。</p><p>比如，下面的接口会合并到一起：</p><pre><code><span>interface</span> Document {\n    createElement(tagName: <span>any</span>): Element;\n}\n<span>interface</span> Document {\n    createElement(tagName: <span>\"div\"</span>): HTMLDivElement;\n    createElement(tagName: <span>\"span\"</span>): HTMLSpanElement;\n}\n<span>interface</span> Document {\n    createElement(tagName: <span>string</span>): HTMLElement;\n    createElement(tagName: <span>\"canvas\"</span>): HTMLCanvasElement;\n}\n</code></pre><p>合并后的<code>Document</code>将会像下面这样：</p><pre><code><span>interface</span> Document {\n    createElement(tagName: <span>\"canvas\"</span>): HTMLCanvasElement;\n    createElement(tagName: <span>\"div\"</span>): HTMLDivElement;\n    createElement(tagName: <span>\"span\"</span>): HTMLSpanElement;\n    createElement(tagName: <span>string</span>): HTMLElement;\n    createElement(tagName: <span>any</span>): Element;\n}\n</code></pre><h1>合并命名空间</h1><p>与接口相似，同名的命名空间也会合并其成员。 命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</p><p>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</p><p>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</p><p><code>Animals</code>声明合并示例：</p><pre><code><span>namespace</span> Animals {\n    <span>export</span> <span>class</span> Zebra { }\n}\n\n<span>namespace</span> Animals {\n    <span>export</span> <span>interface</span> Legged { numberOfLegs: <span>number</span>; }\n    <span>export</span> <span>class</span> Dog { }\n}\n</code></pre><p>等同于：</p><pre><code><span>namespace</span> Animals {\n    <span>export</span> <span>interface</span> Legged { numberOfLegs: <span>number</span>; }\n\n    <span>export</span> <span>class</span> Zebra { }\n    <span>export</span> <span>class</span> Dog { }\n}\n</code></pre><p>除了这些合并外，你还需要了解非导出成员是如何处理的。 非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</p><p>下例提供了更清晰的说明：</p><pre><code><span>namespace</span> Animal {\n    <span>let</span> haveMuscles = <span>true</span>;\n\n    <span>export</span> <span><span>function</span> <span>animalsHaveMuscles</span>(<span></span>) </span>{\n        <span>return</span> haveMuscles;\n    }\n}\n\n<span>namespace</span> Animal {\n    <span>export</span> <span><span>function</span> <span>doAnimalsHaveMuscles</span>(<span></span>) </span>{\n        <span>return</span> haveMuscles;  <span>// &lt;-- error, haveMuscles is not visible here</span>\n    }\n}\n</code></pre><p>因为<code>haveMuscles</code>并没有导出，只有<code>animalsHaveMuscles</code>函数共享了原始未合并的命名空间可以访问这个变量。 <code>doAnimalsHaveMuscles</code>函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p><h1>命名空间与类和函数和枚举类型合并</h1><p>命名空间可以与其它类型的声明进行合并。 只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。 Typescript使用这个功能去实现一些JavaScript里的设计模式。</p><h2>合并命名空间和类</h2><p>这让我们可以表示内部类。</p><pre><code><span>class</span> Album {\n    label: Album.AlbumLabel;\n}\n<span>namespace</span> Album {\n    <span>export</span> <span>class</span> AlbumLabel { }\n}\n</code></pre><p>合并规则与上面<code>合并命名空间</code>小节里讲的规则一致，我们必须导出<code>AlbumLabel</code>类，好让合并的类能访问。 合并结果是一个类并带有一个内部类。 你也可以使用命名空间为类增加一些静态属性。</p><p>除了内部类的模式，你在JavaScript里，创建一个函数稍后扩展它增加一些属性也是很常见的。 Typescript使用声明合并来达到这个目的并保证类型安全。</p><pre><code><span><span>function</span> <span>buildLabel</span>(<span>name: <span>string</span></span>): <span>string</span> </span>{\n    <span>return</span> buildLabel.prefix + name + buildLabel.suffix;\n}\n\n<span>namespace</span> buildLabel {\n    <span>export</span> <span>let</span> suffix = <span>\"\"</span>;\n    <span>export</span> <span>let</span> prefix = <span>\"Hello, \"</span>;\n}\n\nalert(buildLabel(<span>\"Sam Smith\"</span>));\n</code></pre><p>相似的，命名空间可以用来扩展枚举型：</p><pre><code><span>enum</span> Color {\n    red = <span>1</span>,\n    green = <span>2</span>,\n    blue = <span>4</span>\n}\n\n<span>namespace</span> Color {\n    <span>export</span> <span><span>function</span> <span>mixColor</span>(<span>colorName: <span>string</span></span>) </span>{\n        <span>if</span> (colorName == <span>\"yellow\"</span>) {\n            <span>return</span> Color.red + Color.green;\n        }\n        <span>else</span> <span>if</span> (colorName == <span>\"white\"</span>) {\n            <span>return</span> Color.red + Color.green + Color.blue;\n        }\n        <span>else</span> <span>if</span> (colorName == <span>\"magenta\"</span>) {\n            <span>return</span> Color.red + Color.blue;\n        }\n        <span>else</span> <span>if</span> (colorName == <span>\"cyan\"</span>) {\n            <span>return</span> Color.green + Color.blue;\n        }\n    }\n}\n</code></pre><h1>非法的合并</h1><p>TypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考<a href=\"http://www.tslang.cn/docs/handbook/Mixins.md\" rel=\"external nofollow\" target=\"_blank\">TypeScript的混入</a>。</p><h1>模块扩展</h1><p>虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。让我们考察一下这个玩具性的示例：</p><pre><code><span>// observable.js</span>\n<span>export</span> <span><span>class</span> <span>Observable</span>&lt;<span>T</span>&gt; </span>{\n    <span>// ... implementation left as an exercise for the reader ...</span>\n}\n\n<span>// map.js</span>\n<span>import</span> { Observable } <span>from</span> <span>\"./observable\"</span>;\nObservable.prototype.map = <span><span>function</span> (<span>f</span>) </span>{\n    <span>// ... another exercise for the reader</span>\n}\n</code></pre><p>它也可以很好地工作在TypeScript中， 但编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器：</p><pre><code><span>// observable.ts stays the same</span>\n<span>// map.ts</span>\n<span>import</span> { Observable } from <span>\"./observable\"</span>;\n<span>declare</span> <span>module</span> \"./observable\" {\n    <span>interface</span> Observable&lt;T&gt; {\n        map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;\n    }\n}\nObservable.prototype.map = <span><span>function</span> (<span>f</span>) </span>{\n    <span>// ... another exercise for the reader</span>\n}\n\n\n<span>// consumer.ts</span>\n<span>import</span> { Observable } from <span>\"./observable\"</span>;\n<span>import</span> <span>\"./map\"</span>;\n<span>let</span> o: Observable&lt;<span>number</span>&gt;;\no.map(x =&gt; x.toFixed());\n</code></pre><p>模块名的解析和用<code>import</code>/<code>export</code>解析模块标识符的方式是一致的。 更多信息请参考 <a href=\"http://www.tslang.cn/docs/handbook/Modules.md\" rel=\"external nofollow\" target=\"_blank\">Modules</a>。 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。但是，你不能在扩展中声明新的顶级声明--仅可以扩展模块中已经存在的声明。</p><h2>全局扩展</h2><p>你也以在模块内部添加声明到全局作用域中。</p><pre><code><span>// observable.ts</span>\n<span>export</span> <span>class</span> Observable&lt;T&gt; {\n    <span>// ... still no implementation ...</span>\n}\n\n<span>declare</span> global {\n    <span>interface</span> Array&lt;T&gt; {\n        toObservable(): Observable&lt;T&gt;;\n    }\n}\n\n<span>Array</span>.prototype.toObservable = <span><span>function</span> (<span></span>) </span>{\n    <span>// ...</span>\n}\n</code></pre><p>全局扩展与模块扩展的行为和限制是相同的。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 16,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "0bbae62a00256af1aa04df4044debaba",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 模块解析",
      "chapter_level_two_url": "/typescript/typescript-module-resolution.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>模块解析</h1><p></p><blockquote><p>这节假设你已经了解了模块的一些基本知识 请阅读<a href=\"/typescript/typescript-modules.html\" target=\"_blank\"> 模块</a>文档了解更多信息。</p></blockquote><p><em>模块解析</em>就是指编译器所要依据的一个流程，用它来找出某个导入操作所引用的具体值。 假设有一个导入语句<code>import { a } from \"moduleA\"</code>; 为了去检查任何对 <code>a</code>的使用，编译器需要准确的知道它表示什么，并且会需要检查它的定义<code>moduleA</code>。</p><p>这时候，编译器会想知道“<code>moduleA</code>的shape是怎样的？” 这听上去很简单， <code>moduleA</code>可能在你写的某个<code>.ts</code>/<code>.tsx</code>文件里或者在你的代码所依赖的<code>.d.ts</code>里。</p><p>首先，编译器会尝试定位表示导入模块的文件。 编译会遵循下列二种策略之一： <a href=\"#classic\" target=\"_blank\">Classic</a>或<a href=\"#node\" target=\"_blank\">Node</a>。 这些策略会告诉编译器到 <em>哪里</em>去查找<code>moduleA</code>。</p><p>如果它们失败了并且如果模块名是非相对的（且是在<code>\"moduleA\"</code>的情况下），编译器会尝试定位一个<a href=\"/typescript/typescript-modules.html#ambient-modules\" target=\"_blank\">外部模块声明</a>。 我们接下来会讲到非相对导入。</p><p>最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 <code>error TS2307: Cannot find module 'moduleA'.</code></p><h2>相对 vs. 非相对模块导入</h2><p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p><p><em>相对导入</em>是以<code>/</code>，<code>./</code>或<code>../</code>开头的。 下面是一些例子：</p><ul><li><code>import Entry from \"./components/Entry\";</code></li><li><code>import { DefaultHeaders } from \"../constants/http\";</code></li><li><code>import \"/mod\";</code></li></ul><p>所有其它形式的导入被当作<em>非相对</em>的。 下面是一些例子：</p><ul><li><code>import * as $ from \"jQuery\";</code></li><li><code>import { Component } from \"angular2/core\";</code></li></ul><p>相对导入解析时是相对于导入它的文件来的，并且<em>不能</em>解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p><h2>模块解析策略</h2><p>共有两种可用的模块解析策略：<a href=\"#node\" target=\"_blank\">Node</a>和<a href=\"#classic\" target=\"_blank\">Classic</a>。 你可以使用 <code>--moduleResolution</code>标记为指定使用哪个。 默认值为 <a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html#node\" rel=\"external nofollow\" target=\"_blank\">Node</a>。</p><h3>Classic</h3><p>这种策略以前是TypeScript默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p><p>相对导入的模块是相对于导入它的文件进行解析的。 因此 <code>/root/src/folder/A.ts</code>文件里的<code>import { b } from \"./moduleB\"</code>会使用下面的查找流程：</p><ol><li><code>/root/src/folder/moduleB.ts</code></li><li><code>/root/src/folder/moduleB.d.ts</code></li></ol><p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p><p>比如：</p><p>有一个对<code>moduleB</code>的非相对导入<code>import { b } from \"moduleB\"</code>，它是在<code>/root/src/folder/A.ts</code>文件里，会以如下的方式来定位<code>\"moduleB\"</code>：</p><ol><li><code>/root/src/folder/moduleB.ts</code></li><li><code>/root/src/folder/moduleB.d.ts</code></li><li><code>/root/src/moduleB.ts</code></li><li><code>/root/src/moduleB.d.ts</code></li><li><code>/root/moduleB.ts</code></li><li><code>/root/moduleB.d.ts</code></li><li><code>/moduleB.ts</code></li><li><code>/moduleB.d.ts</code></li></ol><h3>Node</h3><p>这个解析策略试图在运行时模仿<a href=\"https://nodejs.org/\" rel=\"external nofollow\" target=\"_blank\">Node.js</a>模块解析机制。 完整的Node.js解析算法可以在 <a href=\"https://nodejs.org/api/modules.html#modules_all_together\" rel=\"external nofollow\" target=\"_blank\">Node.js module documentation</a>找到。</p><h4>Node.js如何解析模块</h4><p>为了理解TypeScript编译依照的解析步骤，先弄明白Node.js模块是非常重要的。 通常，在Node.js里导入是通过<code>require</code>函数调用进行的。 Node.js会根据 <code>require</code>的是相对路径还是非相对路径做出不同的行为。</p><p>相对路径很简单。 例如，假设有一个文件路径为 <code>/root/src/moduleA.js</code>，包含了一个导入<code>var x = require(\"./moduleB\");</code> Node.js以下面的顺序解析这个导入：</p><ol><li><p>将<code>/root/src/moduleB.js</code>视为文件，检查是否存在。</p></li><li><p>将<code>/root/src/moduleB</code>视为目录，检查是否它包含<code>package.json</code>文件并且其指定了一个<code>\"main\"</code>模块。 在我们的例子里，如果Node.js发现文件 <code>/root/src/moduleB/package.json</code>包含了<code>{ \"main\": \"lib/mainModule.js\" }</code>，那么Node.js会引用<code>/root/src/moduleB/lib/mainModule.js</code>。</p></li><li><p>将<code>/root/src/moduleB</code>视为目录，检查它是否包含<code>index.js</code>文件。 这个文件会被隐式地当作那个文件夹下的\"main\"模块。</p></li></ol><p>你可以阅读Node.js文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\" rel=\"external nofollow\" target=\"_blank\">file modules</a> 和 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\" rel=\"external nofollow\" target=\"_blank\">folder modules</a>。</p><p>但是，<a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html#relative-vs-non-relative-module-imports\" rel=\"external nofollow\" target=\"_blank\">非相对模块名</a>的解析是个完全不同的过程。 Node会在一个特殊的文件夹 <code>node_modules</code>里查找你的模块。<code>node_modules</code>可能与当前文件在同一级目录下，或者在上层目录里。 Node会向上级目录遍历，查找每个<code>node_modules</code>直到它找到要加载的模块。</p><p>还是用上面例子，但假设<code>/root/src/moduleA.js</code>里使用的是非相对路径导入<code>var x = require(\"moduleB\");</code>。 Node则会以下面的顺序去解析 <code>moduleB</code>，直到有一个匹配上。</p><ol><li><code>/root/src/node_modules/moduleB.js</code></li><li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>\"main\"</code>属性)</li><li><code>/root/src/node_modules/moduleB/index.js</code> <br><br></li><li><code>/root/node_modules/moduleB.js</code></li><li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>\"main\"</code>属性)</li><li><code>/root/node_modules/moduleB/index.js</code> <br><br></li><li><code>/node_modules/moduleB.js</code></li><li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>\"main\"</code>属性)</li><li><code>/node_modules/moduleB/index.js</code></li></ol><p>注意Node.js在步骤（4）和（7）会向上跳一级目录。</p><p>你可以阅读Node.js文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\" rel=\"external nofollow\" target=\"_blank\">loading modules from <code>node_modules</code></a>。</p><h4>TypeScript如何解析模块</h4><p>TypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（ <code>.ts</code>，<code>.tsx</code>和<code>.d.ts</code>）。 同时，TypeScript在 <code>package.json</code>里使用字段<code>\"typings\"</code>来表示类似<code>\"main\"</code>的意义 - 编译器会使用它来找到要使用的\"main\"定义文件。</p><p>比如，有一个导入语句<code>import { b } from \"./moduleB\"</code>在<code>/root/src/moduleA.ts</code>里，会以下面的流程来定位<code>\"./moduleB\"</code>：</p><ol><li><code>/root/src/moduleB.ts</code></li><li><code>/root/src/moduleB.tsx</code></li><li><code>/root/src/moduleB.d.ts</code></li><li><code>/root/src/moduleB/package.json</code> (如果指定了<code>\"typings\"</code>属性)</li><li><code>/root/src/moduleB/index.ts</code></li><li><code>/root/src/moduleB/index.tsx</code></li><li><code>/root/src/moduleB/index.d.ts</code></li></ol><p>回想一下Node.js先查找<code>moduleB.js</code>文件，然后是合适的<code>package.json</code>，再之后是<code>index.js</code>。</p><p>类似地，非相对的导入会遵循Node.js的解析逻辑，首先查找文件，然后是合适的文件夹。 因此<code>/src/moduleA.ts</code>文件里的<code>import { b } from \"moduleB\"</code>会以下面的查找顺序解析：</p><ol><li><code>/root/src/node_modules/moduleB.ts</code></li><li><code>/root/src/node_modules/moduleB.tsx</code></li><li><code>/root/src/node_modules/moduleB.d.ts</code></li><li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>\"typings\"</code>属性)</li><li><code>/root/src/node_modules/moduleB/index.ts</code></li><li><code>/root/src/node_modules/moduleB/index.tsx</code></li><li><code>/root/src/node_modules/moduleB/index.d.ts</code> <br><br></li><li><code>/root/node_modules/moduleB.ts</code></li><li><code>/root/node_modules/moduleB.tsx</code></li><li><code>/root/node_modules/moduleB.d.ts</code></li><li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>\"typings\"</code>属性)</li><li><code>/root/node_modules/moduleB/index.ts</code></li><li><code>/root/node_modules/moduleB/index.tsx</code></li><li><code>/root/node_modules/moduleB/index.d.ts</code> <br><br></li><li><code>/node_modules/moduleB.ts</code></li><li><code>/node_modules/moduleB.tsx</code></li><li><code>/node_modules/moduleB.d.ts</code></li><li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>\"typings\"</code>属性)</li><li><code>/node_modules/moduleB/index.ts</code></li><li><code>/node_modules/moduleB/index.tsx</code></li><li><code>/node_modules/moduleB/index.d.ts</code></li></ol><p>不要被这里步骤的数量吓到 - TypeScript只是在步骤（8）和（15）向上跳了两次目录。 这并不比Node.js里的流程复杂。</p><h2>使用<code>--noResolve</code></h2><p>正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 <code>import</code>，这个文件被会加到一个文件列表里，以供编译器稍后处理。</p><p><code>--noResolve</code>编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。</p><p>比如</p><h4>app.ts</h4><pre><code class=\"hljs javascript\"><span><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">import</span></span></span></span> * <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">as</span></span></span> A <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">from</span></span></span> <span><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"moduleA\"</span></span></span></span> <span><span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// OK, moduleA passed on the command-line</span></span></span></span>\n<span><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">import</span></span></span></span> * <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">as</span></span></span> B <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">from</span></span></span> <span><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\"moduleB\"</span></span></span></span> <span><span class=\"hljs-comment\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">// Error TS2307: Cannot find module 'moduleB'.</span></span></span></span>\n</code></pre><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">tsc</span></span></span> <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">app</span></span></span><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\">.ts</span></span></span> <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">moduleA</span></span></span><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\"><span class=\"hljs-selector-class\">.ts</span></span></span> <span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\"><span class=\"hljs-selector-tag\">--noResolve</span></span></span>\n</code></pre><p>使用<code>--noResolve</code>编译<code>app.ts</code>：</p><ul><li>可能正确找到<code>moduleA</code>，因为它在命令行上指定了。</li><li>找不到<code>moduleB</code>，因为没有在命令行上传递。</li></ul><h2>常见问题</h2><h3>为什么在<code>exclude</code>列表里的模块还会被编译器使用</h3><p><code>tsconfig.json</code>将文件夹转变一个“工程” 如果不指定任何 <code>“exclude”</code>或<code>“files”</code>，文件夹里的所有文件包括<code>tsconfig.json</code>和所有的子目录都会在编译列表里。 如果你想利用 <code>“exclude”</code>排除某些文件，甚至你想指定所有要编译的文件列表，请使用<code>“files”</code>。</p><p>有些是被<code>tsconfig.json</code>自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。</p><p>因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行<code>import</code>或使用了<code>/// &lt;reference path=\"...\" /&gt;</code>指令的文件。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 15,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "1dc55df23e666d496f23ca4141e35d6f",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 命名空间和模块",
      "chapter_level_two_url": "/typescript/typescript-namespaces-and-modules.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>命名空间和模块</h1><p></p><blockquote><p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\" rel=\"external nofollow\" target=\"_blank\">ECMAScript 2015</a>里的术语保持一致，(也就是说<code>module X {</code>相当于现在推荐的写法 <code>namespace X {</code>)。</p></blockquote><h1>介绍</h1><p>这篇文章将概括介绍在TypeScript里使用模块与命名空间来组织代码的方法。 我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。</p><p>查看<a href=\"http://www.tslang.cn/docs/handbook/Modules.md\" rel=\"external nofollow\" target=\"_blank\">模块</a>章节了解关于模块的更多信息。 查看 <a href=\"http://www.tslang.cn/docs/handbook/Namespaces.md\" rel=\"external nofollow\" target=\"_blank\">命名空间</a>章节了解关于命名空间的更多信息。</p><h1>使用命名空间</h1><p>命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。 这令命名空间十分容易使用。 它们可以在多文件中同时使用，并通过 <code>--outFile</code>结合在一起。 命名空间是帮你组织Web应用不错的方式，你可以把所有依赖都放在HTML页面的 <code>&lt;script&gt;</code>标签里。</p><p>但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。</p><h1>使用模块</h1><p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 <em>声明</em>它的依赖。</p><p>模块会把依赖添加到模块加载器上（例如CommonJs / Require.js）。 对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。 模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。</p><p>对于Node.js应用来说，模块是默认并推荐的组织代码的方式。</p><p>从ECMAScript 2015开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。 因此，对于新项目来说推荐使用模块做为组织代码的方式。</p><h1>命名空间和模块的陷阱</h1><p>这部分我们会描述常见的命名空间和模块的使用陷阱和如何去避免它们。</p><h2>对模块使用<code>/// &lt;reference&gt;</code></h2><p>一个常见的错误是使用<code>/// &lt;reference&gt;</code>引用模块文件，应该使用<code>import</code>。 要理解这之间的区别，我们首先应该弄清编译器是如何根据 <code>import</code>路径（例如，<code>import x from \"...\";</code>或<code>import x = require(\"...\")</code>里面的<code>...</code>，等等）来定位模块的类型信息的。</p><p>编译器首先尝试去查找相应路径下的<code>.ts</code>，<code>.tsx</code>再或者<code>.d.ts</code>。 如果这些文件都找不到，编译器会查找 <em>外部模块声明</em>。 回想一下，它们是在 <code>.d.ts</code>文件里声明的。</p><ul><li><code>myModules.d.ts</code></li></ul><pre><code><span>// In a .d.ts file or .ts file that is not a module:</span>\n<span>declare</span> <span>module</span> \"SomeModule\" {\n    <span>export</span> <span><span>function</span> <span>fn</span>(<span></span>): <span>string</span></span>;\n}\n</code></pre><ul><li><code>myOtherModule.ts</code></li></ul><pre><code><span>/// &lt;reference path=\"myModules.d.ts\" /&gt;</span>\n<span>import</span> * as m from <span>\"SomeModule\"</span>;\n</code></pre><p>这里的引用标签指定了外来模块的位置。 这就是一些Typescript例子中引用 <code>node.d.ts</code>的方法。</p><h2>不必要的命名空间</h2><p>如果你想把命名空间转换为模块，它可能会像下面这个文件一件：</p><ul><li><code>shapes.ts</code></li></ul><pre><code><span>export</span> <span>namespace</span> Shapes {\n    <span>export</span> <span>class</span> Triangle { <span>/* ... */</span> }\n    <span>export</span> <span>class</span> Square { <span>/* ... */</span> }\n}\n</code></pre><p>顶层的模块<code>Shapes</code>包裹了<code>Triangle</code>和<code>Square</code>。 对于使用它的人来说这是令人迷惑和讨厌的：</p><ul><li><code>shapeConsumer.ts</code></li></ul><pre><code><span>import</span> * as shapes from <span>\"./shapes\"</span>;\n<span>let</span> t = <span>new</span> shapes.Shapes.Triangle(); <span>// shapes.Shapes?</span>\n</code></pre><p>TypeScript里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。 因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。</p><p>再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。 模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p><p>下面是改进的例子：</p><ul><li><code>shapes.ts</code></li></ul><pre><code><span>export</span> <span>class</span> Triangle { <span>/* ... */</span> }\n<span>export</span> <span>class</span> Square { <span>/* ... */</span> }\n</code></pre><ul><li><code>shapeConsumer.ts</code></li></ul><pre><code><span>import</span> * as shapes from <span>\"./shapes\"</span>;\n<span>let</span> t = <span>new</span> shapes.Triangle();\n</code></pre><h2>模块的取舍</h2><p>就像每个JS文件对应一个模块一样，TypeScript里模块文件与生成的JS文件也是一一对应的。 这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。 例如当目标模块系统为 <code>commonjs</code>或<code>umd</code>时，无法使用<code>outFile</code>选项，但是在TypeScript 1.8以上的版本<a href=\"https://www.typescriptlang.org/docs/release-notes/typescript-1.8.html#concatenate-amd-and-system-modules-with---outfile\" rel=\"external nofollow\" target=\"_blank\">能够</a>使用<code>outFile</code>当目标为<code>amd</code>或<code>system</code>。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 14,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "91979ba9bd64fa22b222dc562b422c10",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 命名空间",
      "chapter_level_two_url": "/typescript/typescript-namespaces.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>命名空间</h1><p></p><blockquote><p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\" rel=\"external nofollow\" target=\"_blank\">ECMAScript 2015</a>里的术语保持一致，(也就是说<code>module X {</code> 相当于现在推荐的写法 <code>namespace X {</code>)。</p></blockquote><h1>介绍</h1><p>这篇文章描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。</p><p>就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。</p><p>另外，任何使用<code>module</code>关键字来声明一个内部模块的地方都应该使用<code>namespace</code>关键字来替换。</p><p>这就避免了让新的使用者被相似的名称所迷惑。</p><h1>第一步</h1><p>我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p><h2>所有的验证器都放在一个文件里</h2><pre><code><span>interface</span> StringValidator {\n    isAcceptable(s: <span>string</span>): <span>boolean</span>;\n}\n\n<span>let</span> lettersRegexp = <span>/^[A-Za-z]+$/</span>;\n<span>let</span> numberRegexp = <span>/^[0-9]+$/</span>;\n\n<span>class</span> LettersOnlyValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> lettersRegexp.test(s);\n    }\n}\n\n<span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n    }\n}\n\n<span>// Some samples to try</span>\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n<span>// Validators to use</span>\n<span>let</span> validators: { [s: <span>string</span>]: StringValidator; } = {};\nvalidators[<span>\"ZIP code\"</span>] = <span>new</span> ZipCodeValidator();\nvalidators[<span>\"Letters only\"</span>] = <span>new</span> LettersOnlyValidator();\n<span>// Show whether each string passed each validator</span>\nstrings.forEach(s =&gt; {\n    <span>for</span> (<span>let</span> name <span>in</span> validators) {\n        <span>console</span>.log(<span>\"\"</span><span>\" + s + \"</span><span>\" \"</span> + (validators[name].isAcceptable(s) ? <span>\" matches \"</span> : <span>\" does not match \"</span>) + name);\n    }\n});\n</code></pre><h1>命名空间</h1><p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p><p>下面的例子里，把所有与验证器相关的类型都放到一个叫做<code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。 相反的，变量 <code>lettersRegexp</code>和<code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p><h2>使用命名空间的验证器</h2><pre><code><span>namespace</span> Validation {\n    <span>export</span> <span>interface</span> StringValidator {\n        isAcceptable(s: <span>string</span>): <span>boolean</span>;\n    }\n\n    <span>const</span> lettersRegexp = <span>/^[A-Za-z]+$/</span>;\n    <span>const</span> numberRegexp = <span>/^[0-9]+$/</span>;\n\n    <span>export</span> <span>class</span> LettersOnlyValidator <span>implements</span> StringValidator {\n        isAcceptable(s: <span>string</span>) {\n            <span>return</span> lettersRegexp.test(s);\n        }\n    }\n\n    <span>export</span> <span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n        isAcceptable(s: <span>string</span>) {\n            <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}\n\n<span>// Some samples to try</span>\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n<span>// Validators to use</span>\n<span>let</span> validators: { [s: <span>string</span>]: Validation.StringValidator; } = {};\nvalidators[<span>\"ZIP code\"</span>] = <span>new</span> Validation.ZipCodeValidator();\nvalidators[<span>\"Letters only\"</span>] = <span>new</span> Validation.LettersOnlyValidator();\n<span>// Show whether each string passed each validator</span>\nstrings.forEach(s =&gt; {\n    <span>for</span> (<span>let</span> name <span>in</span> validators) {\n        <span>console</span>.log(<span>`\"<span>${ s }</span>\" - <span>${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" }</span> <span>${ name }</span>`</span>);\n    }\n});\n</code></pre><h1>分离到多文件</h1><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p><h2>多文件中的命名空间</h2><p>现在，我们把<code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。</p><h5>Validation.ts</h5><pre><code><span>namespace</span> Validation {\n    <span>export</span> <span>interface</span> StringValidator {\n        isAcceptable(s: <span>string</span>): <span>boolean</span>;\n    }\n}\n</code></pre><h5>LettersOnlyValidator.ts</h5><pre><code><span>/// &lt;reference path=\"Validation.ts\" /&gt;</span>\n<span>namespace</span> Validation {\n    <span>const</span> lettersRegexp = <span>/^[A-Za-z]+$/</span>;\n    <span>export</span> <span>class</span> LettersOnlyValidator <span>implements</span> StringValidator {\n        isAcceptable(s: <span>string</span>) {\n            <span>return</span> lettersRegexp.test(s);\n        }\n    }\n}\n</code></pre><h5>ZipCodeValidator.ts</h5><pre><code><span>/// &lt;reference path=\"Validation.ts\" /&gt;</span>\n<span>namespace</span> Validation {\n    <span>const</span> numberRegexp = <span>/^[0-9]+$/</span>;\n    <span>export</span> <span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n        isAcceptable(s: <span>string</span>) {\n            <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n        }\n    }\n}\n</code></pre><h5>Test.ts</h5><pre><code><span>/// &lt;reference path=\"Validation.ts\" /&gt;</span>\n<span>/// &lt;reference path=\"LettersOnlyValidator.ts\" /&gt;</span>\n<span>/// &lt;reference path=\"ZipCodeValidator.ts\" /&gt;</span>\n\n<span>// Some samples to try</span>\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n<span>// Validators to use</span>\n<span>let</span> validators: { [s: <span>string</span>]: Validation.StringValidator; } = {};\nvalidators[<span>\"ZIP code\"</span>] = <span>new</span> Validation.ZipCodeValidator();\nvalidators[<span>\"Letters only\"</span>] = <span>new</span> Validation.LettersOnlyValidator();\n<span>// Show whether each string passed each validator</span>\nstrings.forEach(s =&gt; {\n    <span>for</span> (<span>let</span> name <span>in</span> validators) {\n        <span>console</span>.log(<span>\"\"</span><span>\" + s + \"</span><span>\" \"</span> + (validators[name].isAcceptable(s) ? <span>\" matches \"</span> : <span>\" does not match \"</span>) + name);\n    }\n});\n</code></pre><p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p><p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用<code>--outFile</code>标记：</p><pre><code>tsc --outFile sample.js Test.ts\n</code></pre><p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p><pre><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n</code></pre><p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 <code>&lt;script&gt;</code>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p><h5>MyTestPage.html (excerpt)</h5><pre><code>    &lt;script src=<span>\"Validation.js\"</span> <span>type</span>=<span>\"text/javascript\"</span> /&gt;\n    &lt;script src=<span>\"LettersOnlyValidator.js\"</span> <span>type</span>=<span>\"text/javascript\"</span> /&gt;\n    &lt;script src=<span>\"ZipCodeValidator.js\"</span> <span>type</span>=<span>\"text/javascript\"</span> /&gt;\n    &lt;script src=<span>\"Test.js\"</span> <span>type</span>=<span>\"text/javascript\"</span> /&gt;\n</code></pre><h1>别名</h1><p>另一种简化命名空间操作的方法是使用<code>import q = x.y.z</code>给常用的对象起一个短的名字。 不要与用来加载模块的 <code>import x = require('name')</code>语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p><pre><code><span>namespace</span> Shapes {\n    <span>export</span> <span>namespace</span> Polygons {\n        <span>export</span> <span>class</span> Triangle { }\n        <span>export</span> <span>class</span> Square { }\n    }\n}\n\n<span>import</span> polygons = Shapes.Polygons;\n<span>let</span> sq = <span>new</span> polygons.Square(); <span>// Same as \"new Shapes.Polygons.Square()\"</span>\n</code></pre><p>注意，我们并没有使用<code>require</code>关键字，而是直接使用导入符号的限定名赋值。 这与使用 <code>var</code>相似，但它还适用于类型和导入的具有命名空间含义的符号。 重要的是，对于值来讲， <code>import</code>会生成与原始符号不同的引用，所以改变别名的<code>var</code>值并不会影响原始变量的值。</p><h1>使用其它的JavaScript库</h1><p>为了描述不是用TypeScript编写的类库的类型，我们需要声明类库导出的API。 由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。</p><p>我们称其为声明是因为它不是外部程序的具体实现。 我们通常在 <code>.d.ts</code>里写这些声明。 如果你熟悉C/C++，你可以把它们当做 <code>.h</code>文件。 让我们看一些例子。</p><h2>外部命名空间</h2><p>流行的程序库D3在全局对象<code>d3</code>里定义它的功能。 因为这个库通过一个 <code>&lt;script&gt;</code>标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写：</p><h5>D3.d.ts (部分摘录)</h5><pre><code><span>declare</span> <span>namespace</span> D3 {\n    <span>export</span> <span>interface</span> Selectors {\n        select: {\n            (selector: <span>string</span>): Selection;\n            (element: EventTarget): Selection;\n        };\n    }\n\n    <span>export</span> <span>interface</span> Event {\n        x: <span>number</span>;\n        y: <span>number</span>;\n    }\n\n    <span>export</span> <span>interface</span> Base <span>extends</span> Selectors {\n        event: Event;\n    }\n}\n\n<span>declare</span> <span>let</span> d3: D3.Base;</code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 13,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "14eae4f70d72b3218b12308da8380c05",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 模块",
      "chapter_level_two_url": "/typescript/typescript-modules.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>模块</h1><p></p><blockquote><p><strong>关于术语的一点说明:</strong> 请务必注意一点，TypeScript 1.5里术语名已经发生了变化。 “内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 <a href=\"http://www.ecma-international.org/ecma-262/6.0/\" rel=\"external nofollow\" target=\"_blank\">ECMAScript 2015</a>里的术语保持一致，(也就是说<code>module X {</code> 相当于现在推荐的写法 <code>namespace X {</code>)。</p></blockquote><h1>介绍</h1><p>从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。</p><p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用<a href=\"http://www.tslang.cn/docs/handbook/modules.html#export\" rel=\"external nofollow\" target=\"_blank\"><code>export</code>形式</a>之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 <a href=\"http://www.tslang.cn/docs/handbook/modules.html#import\" rel=\"external nofollow\" target=\"_blank\"><code>import</code>形式</a>之一。</p><p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。</p><p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于Node.js的 <a href=\"https://en.wikipedia.org/wiki/CommonJS\" rel=\"external nofollow\" target=\"_blank\">CommonJS</a>和服务于Web应用的<a href=\"http://requirejs.org/\" rel=\"external nofollow\" target=\"_blank\">Require.js</a>。</p><p>TypeScript与ECMAScript 2015一样，任何包含顶级<code>import</code>或者<code>export</code>的文件都被当成一个模块。</p><h1><a name=\"export\"></a>导出</h1><h2>导出声明</h2><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p><h5>Validation.ts</h5><pre><code><span>export</span> <span>interface</span> StringValidator {\n    isAcceptable(s: <span>string</span>): <span>boolean</span>;\n}\n</code></pre><h5>ZipCodeValidator.ts</h5><pre><code><span>export</span> <span>const</span> numberRegexp = <span>/^[0-9]+$/</span>;\n\n<span>export</span> <span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n    }\n}\n</code></pre><h2>导出语句</h2><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p><pre><code><span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n    }\n}\n<span>export</span> { ZipCodeValidator };\n<span>export</span> { ZipCodeValidator as mainValidator };\n</code></pre><h2>重新导出</h2><p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p><h5>ParseIntBasedZipCodeValidator.ts</h5><pre><code><span>export</span> <span>class</span> ParseIntBasedZipCodeValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; <span>parseInt</span>(s).toString() === s;\n    }\n}\n\n<span>// 导出原先的验证器但做了重命名</span>\n<span>export</span> {ZipCodeValidator as RegExpBasedZipCodeValidator} from <span>\"./ZipCodeValidator\"</span>;\n</code></pre><p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from \"module\"</code>。</p><h5>AllValidators.ts</h5><pre><code><span>export</span> * from <span>\"./StringValidator\"</span>; <span>// exports interface StringValidator</span>\n<span>export</span> * from <span>\"./LettersOnlyValidator\"</span>; <span>// exports class LettersOnlyValidator</span>\n<span>export</span> * from <span>\"./ZipCodeValidator\"</span>;  <span>// exports class ZipCodeValidator</span>\n</code></pre><h1><a name=\"import\"></a>导入</h1><p>模块的导入操作与导出一样简单。 可以使用以下 <code>import</code>形式之一来导入其它模块中的导出内容。</p><h2>导入一个模块中的某个导出内容</h2><pre><code><span>import</span> { ZipCodeValidator } from <span>\"./ZipCodeValidator\"</span>;\n\n<span>let</span> myValidator = <span>new</span> ZipCodeValidator();\n</code></pre><p>可以对导入内容重命名</p><pre><code><span>import</span> { ZipCodeValidator as ZCV } from <span>\"./ZipCodeValidator\"</span>;\n<span>let</span> myValidator = <span>new</span> ZCV();\n</code></pre><h2>将整个模块导入到一个变量，并通过它来访问模块的导出部分</h2><pre><code><span>import</span> * as validator from <span>\"./ZipCodeValidator\"</span>;\n<span>let</span> myValidator = <span>new</span> validator.ZipCodeValidator();\n</code></pre><h2>具有副作用的导入模块</h2><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：</p><pre><code><span>import</span> <span>\"./my-module.js\"</span>;\n</code></pre><h1>默认导出</h1><p>每个模块都可以有一个<code>default</code>导出。 默认导出使用 <code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。 需要使用一种特殊的导入形式来导入 <code>default</code>导出。</p><p><code>default</code>导出十分便利。 比如，像JQuery这样的类库可能有一个默认导出 <code>jQuery</code>或<code>$</code>，并且我们基本上也会使用同样的名字<code>jQuery</code>或<code>$</code>导出JQuery。</p><h5>JQuery.d.ts</h5><pre><code><span>declare</span> <span>let</span> $: JQuery;\n<span>export</span> <span>default</span> $;\n</code></pre><h5>App.ts</h5><pre><code><span>import</span> $ from <span>\"JQuery\"</span>;\n\n$(<span>\"button.continue\"</span>).html( <span>\"Next Step...\"</span> );\n</code></pre><p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p><h5>ZipCodeValidator.ts</h5><pre><code><span>export</span> <span>default</span> <span>class</span> ZipCodeValidator {\n    <span>static</span> numberRegexp = <span>/^[0-9]+$/</span>;\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; ZipCodeValidator.numberRegexp.test(s);\n    }\n}\n</code></pre><h5>Test.ts</h5><pre><code><span>import</span> validator from <span>\"./ZipCodeValidator\"</span>;\n\n<span>let</span> myValidator = <span>new</span> validator();\n</code></pre><p>或者</p><h5>StaticZipCodeValidator.ts</h5><pre><code><span>const</span> numberRegexp = <span>/^[0-9]+$/</span>;\n\n<span>export</span> <span>default</span> <span><span>function</span> (<span>s: <span>string</span></span>) </span>{\n    <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n}\n</code></pre><h5>Test.ts</h5><pre><code><span>import</span> validate from <span>\"./StaticZipCodeValidator\"</span>;\n\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n\n<span>// Use function validate</span>\nstrings.forEach(s =&gt; {\n  <span>console</span>.log(<span>`\"<span>${s}</span>\" <span>${validate(s) ? \" matches\" : \" does not match\"}</span>`</span>);\n});\n</code></pre><p><code>default</code>导出也可以是一个值</p><h5>OneTwoThree.ts</h5><pre><code><span>export</span> <span>default</span> <span>\"123\"</span>;\n</code></pre><h5>Log.ts</h5><pre><code><span>import</span> num from <span>\"./OneTwoThree\"</span>;\n\n<span>console</span>.log(num); <span>// \"123\"</span>\n</code></pre><h1><code>export =</code> 和 <code>import = require()</code></h1><p>CommonJS和AMD都有一个<code>exports</code>对象的概念，它包含了一个模块的所有导出内容。</p><p>它们也支持把<code>exports</code>替换为一个自定义对象。 默认导出就好比这样一个功能；然而，它们却并不相互兼容。 TypeScript模块支持 <code>export =</code>语法以支持传统的CommonJS和AMD的工作流模型。</p><p><code>export =</code>语法定义一个模块的导出对象。 它可以是类，接口，命名空间，函数或枚举。</p><p>若要导入一个使用了<code>export =</code>的模块时，必须使用TypeScript提供的特定语法<code>import let = require(\"module\")</code>。</p><h5>ZipCodeValidator.ts</h5><pre><code><span>let</span> numberRegexp = <span>/^[0-9]+$/</span>;\n<span>class</span> ZipCodeValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n    }\n}\n<span>export</span> = ZipCodeValidator;\n</code></pre><h5>Test.ts</h5><pre><code><span>import</span> zip = <span>require</span>(<span>\"./ZipCodeValidator\"</span>);\n\n<span>// Some samples to try</span>\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n\n<span>// Validators to use</span>\n<span>let</span> validator = <span>new</span> zip();\n\n<span>// Show whether each string passed each validator</span>\nstrings.forEach(s =&gt; {\n  <span>console</span>.log(<span>`\"<span>${ s }</span>\" - <span>${ validator.isAcceptable(s) ? \"matches\" : \"does not match\" }</span>`</span>);\n});\n</code></pre><h1>生成模块代码</h1><p>根据编译时指定的模块目标参数，编译器会生成相应的供Node.js (<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" rel=\"external nofollow\" target=\"_blank\">CommonJS</a>)，Require.js (<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\" rel=\"external nofollow\" target=\"_blank\">AMD</a>)，isomorphic (<a href=\"https://github.com/umdjs/umd\" rel=\"external nofollow\" target=\"_blank\">UMD</a>), <a href=\"https://github.com/systemjs/systemjs\" rel=\"external nofollow\" target=\"_blank\">SystemJS</a>或<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\" rel=\"external nofollow\" target=\"_blank\">ECMAScript 2015 native modules</a> (ES6)模块加载系统使用的代码。 想要了解生成代码中<code>define</code>，<code>require</code> 和 <code>register</code>的意义，请参考相应模块加载器的文档。</p><p>下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。</p><h5>SimpleModule.ts</h5><pre><code><span>import</span> m = <span>require</span>(<span>\"mod\"</span>);\n<span>export</span> <span>let</span> t = m.something + <span>1</span>;\n</code></pre><h5>AMD / RequireJS SimpleModule.js</h5><pre><code>define([<span>\"require\"</span>, <span>\"exports\"</span>, <span>\"./mod\"</span>], <span><span>function</span> (<span>require, exports, mod_1</span>) </span>{\n    exports.t = mod_1.something + <span>1</span>;\n});\n</code></pre><h5>CommonJS / Node SimpleModule.js</h5><pre><code><span>let</span> mod_1 = <span>require</span>(<span>\"./mod\"</span>);\nexports.t = mod_1.something + <span>1</span>;\n</code></pre><h5>UMD SimpleModule.js</h5><pre><code>(<span><span>function</span> (<span>factory</span>) </span>{\n    <span>if</span> (<span>typeof</span> <span>module</span> === <span>\"object\"</span> &amp;&amp; <span>typeof</span> <span>module</span>.exports === <span>\"object\"</span>) {\n        <span>let</span> v = factory(<span>require</span>, exports); <span>if</span> (v !== <span>undefined</span>) <span>module</span>.exports = v;\n    }\n    <span>else</span> <span>if</span> (<span>typeof</span> define === <span>\"function\"</span> &amp;&amp; define.amd) {\n        define([<span>\"require\"</span>, <span>\"exports\"</span>, <span>\"./mod\"</span>], factory);\n    }\n})(<span><span>function</span> (<span>require, exports</span>) </span>{\n    <span>let</span> mod_1 = <span>require</span>(<span>\"./mod\"</span>);\n    exports.t = mod_1.something + <span>1</span>;\n});\n</code></pre><h5>System SimpleModule.js</h5><pre><code>System.register([<span>\"./mod\"</span>], <span><span>function</span>(<span>exports_1</span>) </span>{\n    <span>let</span> mod_1;\n    <span>let</span> t;\n    <span>return</span> {\n        setters:[\n            <span><span>function</span> (<span>mod_1_1</span>) </span>{\n                mod_1 = mod_1_1;\n            }],\n        execute: <span><span>function</span>(<span></span>) </span>{\n            exports_1(<span>\"t\"</span>, t = mod_1.something + <span>1</span>);\n        }\n    }\n});\n</code></pre><h5>Native ECMAScript 2015 modules SimpleModule.js</h5><pre><code><span>import</span> { something } <span>from</span> <span>\"./mod\"</span>;\n<span>export</span> <span>let</span> t = something + <span>1</span>;\n</code></pre><h1>简单示例</h1><p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p><p>为了编译，我们必需要在命令行上指定一个模块目标。对于Node.js来说，使用<code>--module commonjs</code>； 对于Require.js来说，使用``--module amd`。比如：</p><pre><code>tsc --module commonjs Test.ts\n</code></pre><p>编译完成后，每个模块会生成一个单独的<code>.js</code>文件。 好比使用了reference标签，编译器会根据 <code>import</code>语句编译相应的文件。</p><h5>Validation.ts</h5><pre><code><span>export</span> <span>interface</span> StringValidator {\n    isAcceptable(s: <span>string</span>): <span>boolean</span>;\n}\n</code></pre><h5>LettersOnlyValidator.ts</h5><pre><code><span>import</span> { StringValidator } from <span>\"./Validation\"</span>;\n\n<span>const</span> lettersRegexp = <span>/^[A-Za-z]+$/</span>;\n\n<span>export</span> <span>class</span> LettersOnlyValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> lettersRegexp.test(s);\n    }\n}\n</code></pre><h5>ZipCodeValidator.ts</h5><pre><code><span>import</span> { StringValidator } from <span>\"./Validation\"</span>;\n\n<span>const</span> numberRegexp = <span>/^[0-9]+$/</span>;\n\n<span>export</span> <span>class</span> ZipCodeValidator <span>implements</span> StringValidator {\n    isAcceptable(s: <span>string</span>) {\n        <span>return</span> s.length === <span>5</span> &amp;&amp; numberRegexp.test(s);\n    }\n}\n</code></pre><h5>Test.ts</h5><pre><code><span>import</span> { StringValidator } from <span>\"./Validation\"</span>;\n<span>import</span> { ZipCodeValidator } from <span>\"./ZipCodeValidator\"</span>;\n<span>import</span> { LettersOnlyValidator } from <span>\"./LettersOnlyValidator\"</span>;\n\n<span>// Some samples to try</span>\n<span>let</span> strings = [<span>\"Hello\"</span>, <span>\"98052\"</span>, <span>\"101\"</span>];\n\n<span>// Validators to use</span>\n<span>let</span> validators: { [s: <span>string</span>]: StringValidator; } = {};\nvalidators[<span>\"ZIP code\"</span>] = <span>new</span> ZipCodeValidator();\nvalidators[<span>\"Letters only\"</span>] = <span>new</span> LettersOnlyValidator();\n\n<span>// Show whether each string passed each validator</span>\nstrings.forEach(s =&gt; {\n    <span>for</span> (<span>let</span> name <span>in</span> validators) {\n        <span>console</span>.log(<span>`\"<span>${ s }</span>\" - <span>${ validators[name].isAcceptable(s) ? \"matches\" : \"does not match\" }</span> <span>${ name }</span>`</span>);\n    }\n});\n</code></pre><h1>可选的模块加载和其它高级加载场景</h1><p>有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。</p><p>编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code>这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</p><p>这种模式的核心是<code>import id = require(\"...\")</code>语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过 <code>require</code>），就像下面<code>if</code>代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意 <code>import</code>定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方）。</p><p>为了确保类型安全性，我们可以使用<code>typeof</code>关键字。 <code>typeof</code>关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</p><h5>示例：Node.js里的动态模块加载</h5><pre><code><span>declare</span> <span><span>function</span> <span>require</span>(<span>moduleName: <span>string</span></span>): <span>any</span></span>;\n\n<span>import</span> { ZipCodeValidator as Zip } from <span>\"./ZipCodeValidator\"</span>;\n\n<span>if</span> (needZipValidation) {\n    <span>let</span> ZipCodeValidator: <span>typeof</span> Zip = <span>require</span>(<span>\"./ZipCodeValidator\"</span>);\n    <span>let</span> validator = <span>new</span> ZipCodeValidator();\n    <span>if</span> (validator.isAcceptable(<span>\"...\"</span>)) { <span>/* ... */</span> }\n}\n</code></pre><h5>示例：require.js里的动态模块加载</h5><pre><code><span>declare</span> <span><span>function</span> <span>require</span>(<span>moduleNames: <span>string</span>[], onLoad: (...args: <span>any</span>[]</span>) =&gt; <span>void</span>): <span>void</span></span>;\n\n<span>import</span>  * as Zip from <span>\"./ZipCodeValidator\"</span>;\n\n<span>if</span> (needZipValidation) {\n    <span>require</span>([<span>\"./ZipCodeValidator\"</span>], (ZipCodeValidator: <span>typeof</span> Zip) =&gt; {\n        <span>let</span> validator = <span>new</span> ZipCodeValidator.ZipCodeValidator();\n        <span>if</span> (validator.isAcceptable(<span>\"...\"</span>)) { <span>/* ... */</span> }\n    });\n}\n</code></pre><h5>示例：System.js里的动态模块加载</h5><pre><code><span>declare</span> <span>const</span> System: <span>any</span>;\n\n<span>import</span> { ZipCodeValidator as Zip } from <span>\"./ZipCodeValidator\"</span>;\n\n<span>if</span> (needZipValidation) {\n    System.import(<span>\"./ZipCodeValidator\"</span>).then((ZipCodeValidator: <span>typeof</span> Zip) =&gt; {\n        <span>var</span> x = <span>new</span> ZipCodeValidator();\n        <span>if</span> (x.isAcceptable(<span>\"...\"</span>)) { <span>/* ... */</span> }\n    });\n}\n</code></pre><h1>使用其它的JavaScript库</h1><p>要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。</p><p>我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 <code>.d.ts</code>文件里定义的。 如果你熟悉C/C++，你可以把它们当做 <code>.h</code>文件。 让我们看一些例子。</p><h2>外部模块</h2><p>在Node.js里大部分工作是通过加载一个或多个模块实现的。 我们可以使用顶级的 <code>export</code>声明来为每个模块都定义一个<code>.d.ts</code>文件，但最好还是写在一个大的<code>.d.ts</code>文件里。 我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code>关键字并且把名字用引号括起来，方便之后<code>import</code>。 例如：</p><h5>node.d.ts (simplified excerpt)</h5><pre><code><span>declare</span> <span>module</span> \"url\" {\n    <span>export</span> <span>interface</span> Url {\n        protocol?: <span>string</span>;\n        hostname?: <span>string</span>;\n        pathname?: <span>string</span>;\n    }\n\n    <span>export</span> <span><span>function</span> <span>parse</span>(<span>urlStr: <span>string</span>, parseQueryString?, slashesDenoteHost?</span>): <span>Url</span></span>;\n}\n\n<span>declare</span> <span>module</span> \"path\" {\n    <span>export</span> <span><span>function</span> <span>normalize</span>(<span>p: <span>string</span></span>): <span>string</span></span>;\n    <span>export</span> <span><span>function</span> <span>join</span>(<span>...paths: <span>any</span>[]</span>): <span>string</span></span>;\n    <span>export</span> <span>let</span> sep: <span>string</span>;\n}\n</code></pre><p>现在我们可以<code>/// &lt;reference&gt;</code> <code>node.d.ts</code>并且使用<code>import url = require(\"url\");</code>加载模块。</p><pre><code><span>/// &lt;reference path=\"node.d.ts\"/&gt;</span>\n<span>import</span> * as URL from <span>\"url\"</span>;\n<span>let</span> myUrl = URL.parse(<span>\"http://www.typescriptlang.org\"</span>);\n</code></pre><h3>外部模块简写</h3><p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p><h5>declarations.d.ts</h5><pre><code><span>declare</span> <span>module</span> \"hot-new-<span>module</span>\";\n</code></pre><p>简写模块里所有导出的类型将是<code>any</code>。</p><pre><code><span>import</span> x, {y} from <span>\"hot-new-module\"</span>;\nx(y);\n</code></pre><h3>模块声明通配符</h3><p>某些模块加载器如<a href=\"https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax\" rel=\"external nofollow\" target=\"_blank\">SystemJS</a> 和 <a href=\"https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md\" rel=\"external nofollow\" target=\"_blank\">AMD</a>支持导入非JavaScript内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。 模块声明通配符可以用来表示这些情况。</p><pre><code><span>declare</span> <span>module</span> \"*!text\" {\n    <span>const</span> content: <span>string</span>;\n    <span>export</span> <span>default</span> content;\n}\n<span>// Some do it the other way around.</span>\n<span>declare</span> <span>module</span> \"json!*\" {\n    <span>const</span> value: <span>any</span>;\n    <span>export</span> <span>default</span> value;\n}\n</code></pre><p>现在你可以就导入匹配<code>\"*!text\"</code>或<code>\"json!*\"</code>的内容了。</p><pre><code><span>import</span> fileContent from <span>\"./xyz.txt!text\"</span>;\n<span>import</span> data from <span>\"json!http://example.com/data.json\"</span>;\n<span>console</span>.log(data, fileContent);\n</code></pre><h3>UMD模块</h3><p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。 它们以 <a href=\"https://github.com/umdjs/umd\" rel=\"external nofollow\" target=\"_blank\">UMD</a>或<a href=\"http://isomorphic.net/\" rel=\"external nofollow\" target=\"_blank\">Isomorphic</a>模块为代表。 这些库可以通过导入的形式或全局变量的形式访问。 例如：</p><h5>math-lib.d.ts</h5><pre><code><span>export</span> <span>const</span> isPrime(x: <span>number</span>): <span>boolean</span>;\n<span>export</span> as <span>namespace</span> mathLib;\n</code></pre><p>之后，这个库可以在某个模块里通过导入来使用：</p><pre><code><span>import</span> { isPrime } from <span>\"math-lib\"</span>;\nisPrime(<span>2</span>);\nmathLib.isPrime(<span>2</span>); <span>// ERROR: can't use the global definition from inside a module</span>\n</code></pre><p>它同样可以通过全局变量的形式使用，但只能在某个脚本里。 （脚本是指一个不带有导入或导出的文件。）</p><pre><code>mathLib.isPrime(<span>2</span>);\n</code></pre><h1>创建模块结构指导</h1><h2>尽可能地在顶层导出</h2><p>用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</p><p>从你的模块中导出一个命名空间就是一个增加嵌套的例子。 虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。 这对用户来说是很不便的并且通常是多余的。</p><p>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。 除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</p><h3>如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h3><p>就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。 如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。 这会令模块的导入和使用变得些许简单。 比如：</p><h4>MyClass.ts</h4><pre><code><span>export</span> <span>default</span> <span>class</span> SomeType {\n  <span>constructor</span>() { ... }\n}\n</code></pre><h4>MyFunc.ts</h4><pre><code><span>export</span> <span>default</span> <span><span>function</span> <span>getThing</span>(<span></span>) </span>{ <span>return</span> <span>'thing'</span>; }\n</code></pre><h4>Consumer.ts</h4><pre><code><span>import</span> t from <span>\"./MyClass\"</span>;\n<span>import</span> f from <span>\"./MyFunc\"</span>;\n<span>let</span> x = <span>new</span> t();\n<span>console</span>.log(f());\n</code></pre><p>对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为<code>t</code>）并且不需要多余的（.）来找到相关对象。</p><h3>如果要导出多个对象，把它们放在顶层里导出</h3><h4>MyThings.ts</h4><pre><code><span>export</span> <span>class</span> SomeType { <span>/* ... */</span> }\n<span>export</span> <span><span>function</span> <span>someFunc</span>(<span></span>) </span>{ <span>/* ... */</span> }\n</code></pre><p>相反地，当导入的时候：</p><h3>明确地列出导入的名字</h3><h4>Consumer.ts</h4><pre><code><span>import</span> { SomeType, SomeFunc } from <span>\"./MyThings\"</span>;\n<span>let</span> x = <span>new</span> SomeType();\n<span>let</span> y = someFunc();\n</code></pre><h3>使用命名空间导入模式当你要导出大量内容的时候</h3><h4>MyLargeModule.ts</h4><pre><code><span>export</span> <span>class</span> Dog { ... }\n<span>export</span> <span>class</span> Cat { ... }\n<span>export</span> <span>class</span> Tree { ... }\n<span>export</span> <span>class</span> Flower { ... }\n</code></pre><h4>Consumer.ts</h4><pre><code><span>import</span> * as myLargeModule from <span>\"./MyLargeModule.ts\"</span>;\n<span>let</span> x = <span>new</span> myLargeModule.Dog();\n</code></pre><h2>使用重新导出进行扩展</h2><p>你可能经常需要去扩展一个模块的功能。 JS里常用的一个模式是JQuery那样去扩展原对象。 如我们之前提到的，模块不会像全局命名空间对象那样去 <em>合并</em>。 推荐的方案是 <em>不要</em>去改变原来的对象，而是导出一个新的实体来提供新的功能。</p><p>假设<code>Calculator.ts</code>模块里定义了一个简单的计算器实现。 这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p><h4>Calculator.ts</h4><pre><code><span>export</span> <span>class</span> Calculator {\n    <span>private</span> current = <span>0</span>;\n    <span>private</span> memory = <span>0</span>;\n    <span>private</span> operator: <span>string</span>;\n\n    <span>protected</span> processDigit(digit: <span>string</span>, currentValue: <span>number</span>) {\n        <span>if</span> (digit &gt;= <span>\"0\"</span> &amp;&amp; digit &lt;= <span>\"9\"</span>) {\n            <span>return</span> currentValue * <span>10</span> + (digit.charCodeAt(<span>0</span>) - <span>\"0\"</span>.charCodeAt(<span>0</span>));\n        }\n    }\n\n    <span>protected</span> processOperator(operator: <span>string</span>) {\n        <span>if</span> ([<span>\"+\"</span>, <span>\"-\"</span>, <span>\"*\"</span>, <span>\"/\"</span>].indexOf(operator) &gt;= <span>0</span>) {\n            <span>return</span> operator;\n        }\n    }\n\n    <span>protected</span> evaluateOperator(operator: <span>string</span>, left: <span>number</span>, right: <span>number</span>): <span>number</span> {\n        <span>switch</span> (<span>this</span>.operator) {\n            <span>case</span> <span>\"+\"</span>: <span>return</span> left + right;\n            <span>case</span> <span>\"-\"</span>: <span>return</span> left - right;\n            <span>case</span> <span>\"*\"</span>: <span>return</span> left * right;\n            <span>case</span> <span>\"/\"</span>: <span>return</span> left / right;\n        }\n    }\n\n    <span>private</span> evaluate() {\n        <span>if</span> (<span>this</span>.operator) {\n            <span>this</span>.memory = <span>this</span>.evaluateOperator(<span>this</span>.operator, <span>this</span>.memory, <span>this</span>.current);\n        }\n        <span>else</span> {\n            <span>this</span>.memory = <span>this</span>.current;\n        }\n        <span>this</span>.current = <span>0</span>;\n    }\n\n    <span>public</span> handelChar(char: <span>string</span>) {\n        <span>if</span> (char === <span>\"=\"</span>) {\n            <span>this</span>.evaluate();\n            <span>return</span>;\n        }\n        <span>else</span> {\n            <span>let</span> value = <span>this</span>.processDigit(char, <span>this</span>.current);\n            <span>if</span> (value !== <span>undefined</span>) {\n                <span>this</span>.current = value;\n                <span>return</span>;\n            }\n            <span>else</span> {\n                <span>let</span> value = <span>this</span>.processOperator(char);\n                <span>if</span> (value !== <span>undefined</span>) {\n                    <span>this</span>.evaluate();\n                    <span>this</span>.operator = value;\n                    <span>return</span>;\n                }\n            }\n        }\n        <span>throw</span> <span>new</span> <span>Error</span>(<span>`Unsupported input: '<span>${char}</span>'`</span>);\n    }\n\n    <span>public</span> getResult() {\n        <span>return</span> <span>this</span>.memory;\n    }\n}\n\n<span>export</span> <span><span>function</span> <span>test</span>(<span>c: Calculator, input: <span>string</span></span>) </span>{\n    <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; input.length; i++) {\n        c.handelChar(input[i]);\n    }\n\n    <span>console</span>.log(<span>`result of '<span>${input}</span>' is '<span>${c.getResult()}</span>'`</span>);\n}\n</code></pre><p>这是使用导出的<code>test</code>函数来测试计算器。</p><h4>TestCalculator.ts</h4><pre><code><span>import</span> { Calculator, test } from <span>\"./Calculator\"</span>;\n\n\n<span>let</span> c = <span>new</span> Calculator();\ntest(c, <span>\"1+2*33/11=\"</span>); <span>// prints 9</span>\n</code></pre><p>现在扩展它，添加支持输入其它进制（十进制以外），让我们来创建<code>ProgrammerCalculator.ts</code>。</p><h4>ProgrammerCalculator.ts</h4><pre><code><span>import</span> { Calculator } from <span>\"./Calculator\"</span>;\n\n<span>class</span> ProgrammerCalculator extends Calculator {\n    <span>static</span> digits = [<span>\"0\"</span>, <span>\"1\"</span>, <span>\"2\"</span>, <span>\"3\"</span>, <span>\"4\"</span>, <span>\"5\"</span>, <span>\"6\"</span>, <span>\"7\"</span>, <span>\"8\"</span>, <span>\"9\"</span>, <span>\"A\"</span>, <span>\"B\"</span>, <span>\"C\"</span>, <span>\"D\"</span>, <span>\"E\"</span>, <span>\"F\"</span>];\n\n    <span>constructor</span>(public base: number) {\n        <span>super</span>();\n        <span>if</span> (base &lt;= <span>0</span> || base &gt; ProgrammerCalculator.digits.length) {\n            <span>throw</span> <span>new</span> <span>Error</span>(<span>\"base has to be within 0 to 16 inclusive.\"</span>);\n        }\n    }\n\n    <span>protected</span> processDigit(digit: <span>string</span>, currentValue: <span>number</span>) {\n        <span>if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span>0</span>) {\n            <span>return</span> currentValue * <span>this</span>.base + ProgrammerCalculator.digits.indexOf(digit);\n        }\n    }\n}\n\n<span>// Export the new extended calculator as Calculator</span>\n<span>export</span> { ProgrammerCalculator as Calculator };\n\n<span>// Also, export the helper function</span>\n<span>export</span> { test } from <span>\"./Calculator\"</span>;\n</code></pre><p>新的<code>ProgrammerCalculator</code>模块导出的API与原先的<code>Calculator</code>模块很相似，但却没有改变原模块里的对象。 下面是测试ProgrammerCalculator类的代码：</p><h4>TestProgrammerCalculator.ts</h4><pre><code><span>import</span> { Calculator, test } from <span>\"./ProgrammerCalculator\"</span>;\n\n<span>let</span> c = <span>new</span> Calculator(<span>2</span>);\ntest(c, <span>\"001+010=\"</span>); <span>// prints 3</span>\n</code></pre><h2>模块里不要使用命名空间</h2><p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。 模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。 记住这点，命名空间在使用模块时几乎没什么价值。</p><p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。 例如，在C#里，你会从 <code>System.Collections</code>里找到所有集合的类型。 通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。 然而，模块本身已经存在于文件系统之中，这是必须的。 我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。 我们可以创建 <code>/collections/generic/</code>文件夹，把相应模块放在这里面。</p><p>命名空间对解决全局作用域里命名冲突来说是很重要的。 比如，你可以有一个<code>My.Application.Customer.AddForm</code>和<code>My.Application.Order.AddForm</code> -- 两个类型的名字相同，但命名空间不同。 然而，这对于模块来说却不是一个问题。 在一个模块里，没有理由两个对象拥有同一个名字。 从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。</p><blockquote><p>更多关于模块和命名空间的资料查看[命名空间和模块](./Namespaces and Modules.md)</p></blockquote><h2>危险信号</h2><p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p><ul><li>文件的顶层声明是<code>export namespace Foo { ... }</code> （删除<code>Foo</code>并把所有内容向上层移动一层）</li><li>文件只有一个<code>export class</code>或<code>export function</code> （考虑使用<code>export default</code>）</li><li>多个文件的顶层具有同样的<code>export namespace Foo {</code> （不要以为这些会合并到一个<code>Foo</code>中！）</li></ul></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 12,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b5dfd00c8e4360deb758b58cae71f162",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 迭代器和生成器",
      "chapter_level_two_url": "/typescript/typescript-iterators-and-generators.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>迭代器和生成器</h1><h1>可迭代性</h1><p>当一个对象实现了<a href=\"http://www.tslang.cn/docs/handbook/Symbols.md#symboliterator\" rel=\"external nofollow\" target=\"_blank\"><code>Symbol.iterator</code></a>属性时，我们认为它是可迭代的。 一些内置的类型如<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code>等都已经实现了各自的<code>Symbol.iterator</code>。 对象上的 <code>Symbol.iterator</code>函数负责返回供迭代的值。</p><h2><code>for..of</code> 语句</h2><p><code>for..of</code>会遍历可迭代的对象，调用对象上的<code>Symbol.iterator</code>方法。 下面是在数组上使用 <code>for..of</code>的简单例子：</p><pre><code><span>let</span> someArray = [<span>1</span>, <span>\"string\"</span>, <span>false</span>];\n\n<span>for</span> (<span>let</span> entry of someArray) {\n    <span>console</span>.log(entry); <span>// 1, \"string\", false</span>\n}\n</code></pre><h3><code>for..of</code> vs. <code>for..in</code> 语句</h3><p><code>for..of</code>和<code>for..in</code>均可迭代一个列表；但是用于迭代的值却不同，<code>for..in</code>迭代的是对象的 <em>键</em> 的列表，而<code>for..of</code>则迭代对象的键对应的值。</p><p>下面的例子展示了两者之间的区别：</p><pre><code><span>let</span> list = [<span>4</span>, <span>5</span>, <span>6</span>];\n\n<span>for</span> (<span>let</span> i <span>in</span> list) {\n    <span>console</span>.log(i); <span>// \"0\", \"1\", \"2\",</span>\n}\n\n<span>for</span> (<span>let</span> i of list) {\n    <span>console</span>.log(i); <span>// \"4\", \"5\", \"6\"</span>\n}\n</code></pre><p>另一个区别是<code>for..in</code>可以操作任何对象；它提供了查看对象属性的一种方法。 但是 <code>for..of</code>关注于迭代对象的值。内置对象<code>Map</code>和<code>Set</code>已经实现了<code>Symbol.iterator</code>方法，让我们可以访问它们保存的值。</p><pre><code><span>let</span> pets = <span>new</span> Set([<span>\"Cat\"</span>, <span>\"Dog\"</span>, <span>\"Hamster\"</span>]);\npets[<span>\"species\"</span>] = <span>\"mammals\"</span>;\n\n<span>for</span> (<span>let</span> pet <span>in</span> pets) {\n    <span>console</span>.log(pet); <span>// \"species\"</span>\n}\n\n<span>for</span> (<span>let</span> pet of pets) {\n    <span>console</span>.log(pet); <span>// \"Cat\", \"Dog\", \"Hamster\"</span>\n}\n</code></pre><h3>代码生成</h3><h4>目标为 ES5 和 ES3</h4><p>当生成目标为ES5或ES3，迭代器只允许在<code>Array</code>类型上使用。 在非数组值上使用 <code>for..of</code>语句会得到一个错误，就算这些非数组值已经实现了<code>Symbol.iterator</code>属性。</p><p>编译器会生成一个简单的<code>for</code>循环做为<code>for..of</code>循环，比如：</p><pre><code><span>let</span> numbers = [<span>1</span>, <span>2</span>, <span>3</span>];\n<span>for</span> (<span>let</span> num of numbers) {\n    <span>console</span>.log(num);\n}\n</code></pre><p>生成的代码为：</p><pre><code><span>var</span> numbers = [<span>1</span>, <span>2</span>, <span>3</span>];\n<span>for</span> (<span>var</span> _i = <span>0</span>; _i &lt; numbers.length; _i++) {\n    <span>var</span> num = numbers[_i];\n    <span>console</span>.log(num);\n}\n</code></pre><h4>目标为 ECMAScript 2015 或更高</h4><p>当目标为兼容ECMAScipt 2015的引擎时，编译器会生成相应引擎的<code>for..of</code>内置迭代器实现方式。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 11,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "825a13f344dd48059476631a1b3aa758",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript Symbols",
      "chapter_level_two_url": "/typescript/typescript-symbols.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript Symbols<span style=\"line-height: 1.7;\">介绍</span></h1><p>自ECMAScript 2015起，<code>symbol</code>成为了一种新的原生类型，就像<code>number</code>和<code>string</code>一样。</p><p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p><pre><code><span>let</span> sym1 = Symbol();\n\n<span>let</span> sym2 = Symbol(<span>\"key\"</span>); <span>// 可选的字符串key</span>\n</code></pre><p>Symbols是不可改变且唯一的。</p><pre><code><span>let</span> sym2 = Symbol(<span>\"key\"</span>);\n<span>let</span> sym3 = Symbol(<span>\"key\"</span>);\n\nsym2 === sym3; <span>// false, symbols是唯一的</span>\n</code></pre><p>像字符串一样，symbols也可以被用做对象属性的键。</p><pre><code><span>let</span> sym = Symbol();\n\n<span>let</span> obj = {\n    [sym]: <span>\"value\"</span>\n};\n\n<span>console</span>.log(obj[sym]); <span>// \"value\"</span>\n</code></pre><p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p><pre><code><span>const</span> getClassNameSymbol = Symbol();\n\n<span>class</span> C {\n    [getClassNameSymbol](){\n       <span>return</span> <span>\"C\"</span>;\n    }\n}\n\n<span>let</span> c = <span>new</span> C();\n<span>let</span> className = c[getClassNameSymbol](); <span>// \"C\"</span>\n</code></pre><h1>众所周知的Symbols</h1><p>除了用户定义的symbols，还有一些已经众所周知的内置symbols。 内置symbols用来表示语言内部的行为。</p><p>以下为这些symbols的列表：</p><h2><code>Symbol.hasInstance</code></h2><p>方法，会被<code>instanceof</code>运算符调用。构造器对象用来识别一个对象是否是其实例。</p><h2><code>Symbol.isConcatSpreadable</code></h2><p>布尔值，表示当在一个对象上调用<code>Array.prototype.concat</code>时，这个对象的数组元素是否可展开。</p><h2><code>Symbol.iterator</code></h2><p>方法，被<code>for-of</code>语句调用。返回对象的默认迭代器。</p><h2><code>Symbol.match</code></h2><p>方法，被<code>String.prototype.match</code>调用。正则表达式用来匹配字符串。</p><h2><code>Symbol.replace</code></h2><p>方法，被<code>String.prototype.replace</code>调用。正则表达式用来替换字符串中匹配的子串。</p><h2><code>Symbol.search</code></h2><p>方法，被<code>String.prototype.search</code>调用。正则表达式返回被匹配部分在字符串中的索引。</p><h2><code>Symbol.species</code></h2><p>函数值，为一个构造函数。用来创建派生对象。</p><h2><code>Symbol.split</code></h2><p>方法，被<code>String.prototype.split</code>调用。正则表达式来用分割字符串。</p><h2><code>Symbol.toPrimitive</code></h2><p>方法，被<code>ToPrimitive</code>抽象操作调用。把对象转换为相应的原始值。</p><h2><code>Symbol.toStringTag</code></h2><p>方法，被内置方法<code>Object.prototype.toString</code>调用。返回创建对象时默认的字符串描述。</p><h2><code>Symbol.unscopables</code></h2><p>对象，它自己拥有的属性会被<code>with</code>作用域排除在外。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 10,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "97d88c6a8a7a3f8fbdb7520559e09ddd",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 高级类型",
      "chapter_level_two_url": "/typescript/typescript-advanced-types.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>高级类型</h1><h1>交叉类型（Intersection Types）</h1><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， <code>Person &amp; Serializable &amp; Loggable</code>同时是<code>Person</code><em>和</em><code>Serializable</code><em>和</em><code>Loggable</code>。 就是说这个类型的对象同时拥有了这三种类型的成员。</p><p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p><pre><code><span><span>function</span> <span>extend</span>&lt;<span>T</span>, <span>U</span>&gt;(<span>first: T, second: U</span>): <span>T</span> &amp; <span>U</span> </span>{\n    <span>let</span> result = &lt;T &amp; U&gt;{};\n    <span>for</span> (<span>let</span> id <span>in</span> first) {\n        (&lt;<span>any</span>&gt;result)[id] = (&lt;<span>any</span>&gt;first)[id];\n    }\n    <span>for</span> (<span>let</span> id <span>in</span> second) {\n        <span>if</span> (!result.hasOwnProperty(id)) {\n            (&lt;<span>any</span>&gt;result)[id] = (&lt;<span>any</span>&gt;second)[id];\n        }\n    }\n    <span>return</span> result;\n}\n\n<span>class</span> Person {\n    <span>constructor</span>(public name: string) { }\n}\n<span>interface</span> Loggable {\n    log(): <span>void</span>;\n}\n<span>class</span> ConsoleLogger <span>implements</span> Loggable {\n    log() {\n        <span>// ...</span>\n    }\n}\n<span>var</span> jim = extend(<span>new</span> Person(<span>\"Jim\"</span>), <span>new</span> ConsoleLogger());\n<span>var</span> n = jim.name;\njim.log();\n</code></pre><h1>联合类型</h1><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code>或<code>string</code>类型的参数。 例如下面的函数：</p><pre><code><span>/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */</span>\n<span><span>function</span> <span>padLeft</span>(<span>value: <span>string</span>, padding: <span>any</span></span>) </span>{\n    <span>if</span> (<span>typeof</span> padding === <span>\"number\"</span>) {\n        <span>return</span> <span>Array</span>(padding + <span>1</span>).join(<span>\" \"</span>) + value;\n    }\n    <span>if</span> (<span>typeof</span> padding === <span>\"string\"</span>) {\n        <span>return</span> padding + value;\n    }\n    <span>throw</span> <span>new</span> <span>Error</span>(<span>`Expected string or number, got '<span>${padding}</span>'.`</span>);\n}\n\npadLeft(<span>\"Hello world\"</span>, <span>4</span>); <span>// returns \"    Hello world\"</span>\n</code></pre><p><code>padLeft</code>存在一个问题，<code>padding</code>参数的类型指定成了<code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code>也不是<code>string</code>类型的参数，但是TypeScript却不报错。</p><pre><code><span>let</span> indentedString = padLeft(<span>\"Hello world\"</span>, <span>true</span>); <span>// 编译阶段通过，运行时报错</span>\n</code></pre><p>在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。 这么做显然是非常清晰的，但同时也存在了过度设计。 <code>padLeft</code>原始版本的好处之一是允许我们传入原始类型。 这样做的话使用起来既简单又方便。 如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。</p><p>代替<code>any</code>， 我们可以使用<em>联合类型</em>做为<code>padding</code>的参数：</p><pre><code><span>/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */</span>\n<span><span>function</span> <span>padLeft</span>(<span>value: <span>string</span>, padding: <span>string</span> | <span>number</span></span>) </span>{\n    <span>// ...</span>\n}\n\n<span>let</span> indentedString = padLeft(<span>\"Hello world\"</span>, <span>true</span>); <span>// errors during compilation</span>\n</code></pre><p>联合类型表示一个值可以是几种类型之一。 我们用竖线（ <code>|</code>）分隔每个类型，所以<code>number | string | boolean</code>表示一个值可以是<code>number</code>，<code>string</code>，或<code>boolean</code>。</p><p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p><pre><code><span>interface</span> Bird {\n    fly();\n    layEggs();\n}\n\n<span>interface</span> Fish {\n    swim();\n    layEggs();\n}\n\n<span><span>function</span> <span>getSmallPet</span>(<span></span>): <span>Fish</span> | <span>Bird</span> </span>{\n    <span>// ...</span>\n}\n\n<span>let</span> pet = getSmallPet();\npet.layEggs(); <span>// okay</span>\npet.swim();    <span>// errors</span>\n</code></pre><p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 <code>A | B</code>，我们能够<em>确定</em>的是它包含了<code>A</code><em>和</em><code>B</code>中共有的成员。 这个例子里， <code>Bird</code>具有一个<code>fly</code>成员。 我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有<code>fly</code>方法。 如果变量在运行时是 <code>Fish</code>类型，那么调用<code>pet.fly()</code>就出错了。</p><h1>类型保护与区分类型</h1><p>联合类型非常适合这样的情形，可接收的值有不同的类型。 当我们想明确地知道是否拿到 <code>Fish</code>时会怎么做？ JavaScript里常用来区分2个可能值的方法是检查它们是否存在。 像之前提到的，我们只能访问联合类型的所有类型中共有的成员。</p><pre><code><span>let</span> pet = getSmallPet();\n\n<span>// 每一个成员访问都会报错</span>\n<span>if</span> (pet.swim) {\n    pet.swim();\n}\n<span>else</span> <span>if</span> (pet.fly) {\n    pet.fly();\n}\n</code></pre><p>为了让这段代码工作，我们要使用类型断言：</p><pre><code><span>let</span> pet = getSmallPet();\n\n<span>if</span> ((&lt;Fish&gt;pet).swim) {\n    (&lt;Fish&gt;pet).swim();\n}\n<span>else</span> {\n    (&lt;Bird&gt;pet).fly();\n}\n</code></pre><h2>用户自定义的类型保护</h2><p>可以注意到我们使用了多次类型断言。 如果我们只要检查过一次类型，就能够在后面的每个分支里清楚 <code>pet</code>的类型的话就好了。</p><p>TypeScript里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <em>类型断言</em>：</p><pre><code><span><span>function</span> <span>isFish</span>(<span>pet: Fish | Bird</span>): <span>pet</span> <span>is</span> <span>Fish</span> </span>{\n    <span>return</span> (&lt;Fish&gt;pet).swim !== <span>undefined</span>;\n}\n</code></pre><p>在这个例子里，<code>pet is Fish</code>就是类型谓词。 谓词是 <code>parameterName is Type</code>这种形式，<code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</p><p>每当使用一些变量调用<code>isFish</code>时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p><pre><code><span>// 'swim' 和 'fly' 调用都没有问题了</span>\n\n<span>if</span> (isFish(pet)) {\n    pet.swim();\n}\n<span>else</span> {\n    pet.fly();\n}\n</code></pre><p>注意TypeScript不仅知道在<code>if</code>分支里<code>pet</code>是<code>Fish</code>类型； 它还清楚在 <code>else</code>分支里，一定<em>不是</em><code>Fish</code>类型，一定是<code>Bird</code>类型。</p><h2><code>typeof</code>类型保护</h2><p>现在我们回过头来看看怎么使用联合类型书写<code>padLeft</code>代码。 我们可以像下面这样利用类型断言来写：</p><pre><code><span><span>function</span> <span>isNumber</span>(<span>x: <span>any</span></span>): <span>x</span> <span>is</span> <span>number</span> </span>{\n    <span>return</span> <span>typeof</span> x === <span>\"number\"</span>;\n}\n\n<span><span>function</span> <span>isString</span>(<span>x: <span>any</span></span>): <span>x</span> <span>is</span> <span>string</span> </span>{\n    <span>return</span> <span>typeof</span> x === <span>\"string\"</span>;\n}\n\n<span><span>function</span> <span>padLeft</span>(<span>value: <span>string</span>, padding: <span>string</span> | <span>number</span></span>) </span>{\n    <span>if</span> (isNumber(padding)) {\n        <span>return</span> <span>Array</span>(padding + <span>1</span>).join(<span>\" \"</span>) + value;\n    }\n    <span>if</span> (isString(padding)) {\n        <span>return</span> padding + value;\n    }\n    <span>throw</span> <span>new</span> <span>Error</span>(<span>`Expected string or number, got '<span>${padding}</span>'.`</span>);\n}\n</code></pre><p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将 <code>typeof x === \"number\"</code>抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p><pre><code><span><span>function</span> <span>padLeft</span>(<span>value: <span>string</span>, padding: <span>string</span> | <span>number</span></span>) </span>{\n    <span>if</span> (<span>typeof</span> padding === <span>\"number\"</span>) {\n        <span>return</span> <span>Array</span>(padding + <span>1</span>).join(<span>\" \"</span>) + value;\n    }\n    <span>if</span> (<span>typeof</span> padding === <span>\"string\"</span>) {\n        <span>return</span> padding + value;\n    }\n    <span>throw</span> <span>new</span> <span>Error</span>(<span>`Expected string or number, got '<span>${padding}</span>'.`</span>);\n}\n</code></pre><p>这些*<code>typeof</code>类型保护*只有两种形式能被识别：<code>typeof v === \"typename\"</code>和<code>typeof v !== \"typename\"</code>，<code>\"typename\"</code>必须是<code>\"number\"</code>，<code>\"string\"</code>，<code>\"boolean\"</code>或<code>\"symbol\"</code>。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h2><code>instanceof</code>类型保护</h2><p>如果你已经阅读了<code>typeof</code>类型保护并且对JavaScript里的<code>instanceof</code>操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p><p><em><code>instanceof</code>类型保护</em>是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：</p><pre><code><span>interface</span> Padder {\n    getPaddingString(): <span>string</span>\n}\n\n<span>class</span> SpaceRepeatingPadder <span>implements</span> Padder {\n    <span>constructor</span>(private numSpaces: number) { }\n    getPaddingString() {\n        <span>return</span> <span>Array</span>(<span>this</span>.numSpaces + <span>1</span>).join(<span>\" \"</span>);\n    }\n}\n\n<span>class</span> StringPadder <span>implements</span> Padder {\n    <span>constructor</span>(private value: string) { }\n    getPaddingString() {\n        <span>return</span> <span>this</span>.value;\n    }\n}\n\n<span><span>function</span> <span>getRandomPadder</span>(<span></span>) </span>{\n    <span>return</span> <span>Math</span>.random() &lt; <span>0.5</span> ?\n        <span>new</span> SpaceRepeatingPadder(<span>4</span>) :\n        <span>new</span> StringPadder(<span>\"  \"</span>);\n}\n\n<span>// 类型为SpaceRepeatingPadder | StringPadder</span>\n<span>let</span> padder: Padder = getRandomPadder();\n\n<span>if</span> (padder <span>instanceof</span> SpaceRepeatingPadder) {\n    padder; <span>// 类型细化为'SpaceRepeatingPadder'</span>\n}\n<span>if</span> (padder <span>instanceof</span> StringPadder) {\n    padder; <span>// 类型细化为'StringPadder'</span>\n}\n</code></pre><p><code>instanceof</code>的右侧要求是一个构造函数，TypeScript将细化为：</p><ol><li>此构造函数的<code>prototype</code>属性的类型，如果它的类型不为<code>any</code>的话</li><li>构造签名所返回的类型的联合</li></ol><p>以此顺序。</p><h1>类型别名</h1><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p><pre><code><span>type</span> Name = <span>string</span>;\n<span>type</span> NameResolver = () =&gt; <span>string</span>;\n<span>type</span> NameOrResolver = Name | NameResolver;\n<span><span>function</span> <span>getName</span>(<span>n: NameOrResolver</span>): <span>Name</span> </span>{\n    <span>if</span> (<span>typeof</span> n === <span>'string'</span>) {\n        <span>return</span> n;\n    }\n    <span>else</span> {\n        <span>return</span> n();\n    }\n}\n</code></pre><p>起别名不会新建一个类型 - 它创建了一个新<em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p><p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p><pre><code><span>type</span> Container&lt;T&gt; = { value: T };\n</code></pre><p>我们也可以使用类型别名来在属性里引用自己：</p><pre><code><span>type</span> Tree&lt;T&gt; = {\n    value: T;\n    left: Tree&lt;T&gt;;\n    right: Tree&lt;T&gt;;\n}\n</code></pre><p>然而，类型别名不能够出现在声名语句的右侧：</p><pre><code><span>type</span> LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };\n\n<span>interface</span> Person {\n    name: <span>string</span>;\n}\n\n<span>var</span> people: LinkedList&lt;Person&gt;;\n<span>var</span> s = people.name;\n<span>var</span> s = people.next.name;\n<span>var</span> s = people.next.next.name;\n<span>var</span> s = people.next.next.next.name;\n</code></pre><p>然而，类型别名不能出现在声明右侧的任何地方。</p><pre><code><span>type</span> Yikes = <span>Array</span>&lt;Yikes&gt;; <span>// error</span>\n</code></pre><h2>接口 vs. 类型别名</h2><p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p><p>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 <code>interfaced</code>上，显示它返回的是<code>Interface</code>，但悬停在<code>aliased</code>上时，显示的却是对象字面量类型。</p><pre><code><span>type</span> Alias = { num: <span>number</span> }\n<span>interface</span> Interface {\n    num: <span>number</span>;\n}\n<span>declare</span> <span><span>function</span> <span>aliased</span>(<span>arg: Alias</span>): <span>Alias</span></span>;\n<span>declare</span> <span><span>function</span> <span>interfaced</span>(<span>arg: Interface</span>): <span>Interface</span></span>;\n</code></pre><p>另一个重要区别是类型别名不能被<code>extends</code>和<code>implements</code>（自己也不能<code>extends</code>和<code>implements</code>其它类型）。 因为 <a href=\"https://en.wikipedia.org/wiki/Open/closed_principle\" rel=\"external nofollow\" target=\"_blank\">软件中的对象应该对于扩展是开放的，但是对于修改是封闭的</a>，你应该尽量去使用接口代替类型别名。</p><p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p><h1>字符串字面量类型</h1><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p><pre><code><span>type</span> Easing = <span>\"ease-in\"</span> | <span>\"ease-out\"</span> | <span>\"ease-in-out\"</span>;\n<span>class</span> UIElement {\n    animate(dx: <span>number</span>, dy: <span>number</span>, easing: Easing) {\n        <span>if</span> (easing === <span>\"ease-in\"</span>) {\n            <span>// ...</span>\n        }\n        <span>else</span> <span>if</span> (easing === <span>\"ease-out\"</span>) {\n        }\n        <span>else</span> <span>if</span> (easing === <span>\"ease-in-out\"</span>) {\n        }\n        <span>else</span> {\n            <span>// error! should not pass null or undefined.</span>\n        }\n    }\n}\n\n<span>let</span> button = <span>new</span> UIElement();\nbutton.animate(<span>0</span>, <span>0</span>, <span>\"ease-in\"</span>);\nbutton.animate(<span>0</span>, <span>0</span>, <span>\"uneasy\"</span>); <span>// error: \"uneasy\" is not allowed here</span>\n</code></pre><p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p><pre><code>Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n</code></pre><p>字符串字面量类型还可以用于区分函数重载：</p><pre><code><span><span>function</span> <span>createElement</span>(<span>tagName: \"img\"</span>): <span>HTMLImageElement</span></span>;\n<span><span>function</span> <span>createElement</span>(<span>tagName: \"input\"</span>): <span>HTMLInputElement</span></span>;\n<span>// ... more overloads ...</span>\n<span><span>function</span> <span>createElement</span>(<span>tagName: <span>string</span></span>): <span>Element</span> </span>{\n    <span>// ... code goes here ...</span>\n}\n</code></pre><h1>可辨识联合（Discriminated Unions）</h1><p>你可以合并字符串字面量类型，联合类型，类型保护和类型别名来创建一个叫做<em>可辨识联合</em>的高级模式，它也称做<em>标签联合</em>或<em>代数数据类型</em>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有4个要素：</p><ol><li>具有普通的字符串字面量属性—<em>可辨识的特征</em>。</li><li>一个类型别名包含了那些类型的联合—<em>联合</em>。</li><li>此属性上的类型保护。</li></ol><pre><code><span>interface</span> Square {\n    kind: <span>\"square\"</span>;\n    size: <span>number</span>;\n}\n<span>interface</span> Rectangle {\n    kind: <span>\"rectangle\"</span>;\n    width: <span>number</span>;\n    height: <span>number</span>;\n}\n<span>interface</span> Circle {\n    kind: <span>\"circle\"</span>;\n    radius: <span>number</span>;\n}\n</code></pre><p>首先我们声明了将要联合的接口。 每个接口都有 <code>kind</code>属性但有不同的字符器字面量类型。 <code>kind</code>属性称做<em>可辨识的特征</em>或<em>标签</em>。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p><pre><code><span>type</span> Shape = Square | Rectangle | Circle;\n</code></pre><p>现在我们使用可辨识联合:</p><pre><code><span><span>function</span> <span>area</span>(<span>s: Shape</span>) </span>{\n    <span>switch</span> (s.kind) {\n        <span>case</span> <span>\"square\"</span>: <span>return</span> s.size * s.size;\n        <span>case</span> <span>\"rectangle\"</span>: <span>return</span> s.height * s.width;\n        <span>case</span> <span>\"circle\"</span>: <span>return</span> <span>Math</span>.PI * s.radius ** <span>2</span>;\n    }\n}\n</code></pre><h2>完整性检查</h2><p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 <code>Triangle</code>到<code>Shape</code>，我们同时还需要更新<code>area</code>:</p><pre><code><span>type</span> Shape = Square | Rectangle | Circle | Triangle;\n<span><span>function</span> <span>area</span>(<span>s: Shape</span>) </span>{\n    <span>switch</span> (s.kind) {\n        <span>case</span> <span>\"square\"</span>: <span>return</span> s.size * s.size;\n        <span>case</span> <span>\"rectangle\"</span>: <span>return</span> s.height * s.width;\n        <span>case</span> <span>\"circle\"</span>: <span>return</span> <span>Math</span>.PI * s.radius ** <span>2</span>;\n    }\n    <span>// should error here - we didn't handle case \"triangle\"</span>\n}\n</code></pre><p>有两种方式可以实现。 首先是启用 <code>--strictNullChecks</code>并且指定一个返回值类型：</p><pre><code><span><span>function</span> <span>area</span>(<span>s: Shape</span>): <span>number</span> </span>{ <span>// error: returns number | undefined</span>\n    <span>switch</span> (s.kind) {\n        <span>case</span> <span>\"square\"</span>: <span>return</span> s.size * s.size;\n        <span>case</span> <span>\"rectangle\"</span>: <span>return</span> s.height * s.width;\n        <span>case</span> <span>\"circle\"</span>: <span>return</span> <span>Math</span>.PI * s.radius ** <span>2</span>;\n    }\n}\n</code></pre><p>因为<code>switch</code>没有包涵所有情况，所以TypeScript认为这个函数有时候会返回<code>undefined</code>。 如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值的类型为<code>number | undefined</code>。 然而，这种方法存在些微妙之处且 <code>--strictNullChecks</code>对旧代码支持不好。</p><p>第二种方法使用<code>never</code>类型，编译器用它来进行完整性检查：</p><pre><code><span><span>function</span> <span>assertNever</span>(<span>x: never</span>): <span>never</span> </span>{\n    <span>throw</span> <span>new</span> <span>Error</span>(<span>\"Unexpected object: \"</span> + x);\n}\n<span><span>function</span> <span>area</span>(<span>s: Shape</span>) </span>{\n    <span>switch</span> (s.kind) {\n        <span>case</span> <span>\"square\"</span>: <span>return</span> s.size * s.size;\n        <span>case</span> <span>\"rectangle\"</span>: <span>return</span> s.height * s.width;\n        <span>case</span> <span>\"circle\"</span>: <span>return</span> <span>Math</span>.PI * s.radius ** <span>2</span>;\n        <span>default</span>: <span>return</span> assertNever(s); <span>// error here if there are missing cases</span>\n    }\n}\n</code></pre><p>这里，<code>assertNever</code>检查<code>s</code>是否为<code>never</code>类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么 <code>s</code>将具有一个赶写的类型，因此你会得到一个错误。 这种方式需要你定义一个额外的函数。</p><h1>多态的<code>this</code>类型</h1><p>多态的<code>this</code>类型表示的是某个包含类或接口的<em>子类型</em>。 这被称做 <em>F</em>-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 <code>this</code>类型：</p><pre><code><span>class</span> BasicCalculator {\n    <span>public</span> <span>constructor</span>(protected value: number = 0) { }\n    <span>public</span> currentValue(): <span>number</span> {\n        <span>return</span> <span>this</span>.value;\n    }\n    <span>public</span> add(operand: <span>number</span>): <span>this</span> {\n        <span>this</span>.value += operand;\n        <span>return</span> <span>this</span>;\n    }\n    <span>public</span> multiply(operand: <span>number</span>): <span>this</span> {\n        <span>this</span>.value *= operand;\n        <span>return</span> <span>this</span>;\n    }\n    <span>// ... other operations go here ...</span>\n}\n\n<span>let</span> v = <span>new</span> BasicCalculator(<span>2</span>)\n            .multiply(<span>5</span>)\n            .add(<span>1</span>)\n            .currentValue();\n</code></pre><p>由于这个类使用了<code>this</code>类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。</p><pre><code><span>class</span> ScientificCalculator extends BasicCalculator {\n    <span>public</span> <span>constructor</span>(value = 0) {\n        <span>super</span>(value);\n    }\n    <span>public</span> sin() {\n        <span>this</span>.value = <span>Math</span>.sin(<span>this</span>.value);\n        <span>return</span> <span>this</span>;\n    }\n    <span>// ... other operations go here ...</span>\n}\n\n<span>let</span> v = <span>new</span> ScientificCalculator(<span>2</span>)\n        .multiply(<span>5</span>)\n        .sin()\n        .add(<span>1</span>)\n        .currentValue();\n</code></pre><p>如果没有<code>this</code>类型，<code>ScientificCalculator</code>就不能够在继承<code>BasicCalculator</code>的同时还保持接口的连贯性。 <code>multiply</code>将会返回<code>BasicCalculator</code>，它并没有<code>sin</code>方法。 然而，使用 <code>this</code>类型，<code>multiply</code>会返回<code>this</code>，在这里就是<code>ScientificCalculator</code>。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 9,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "40b2664ec6467a0c78069831fb96d50e",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 类型兼容性",
      "chapter_level_two_url": "/typescript/typescript-type-compatibility.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>TypeScript类型兼容性<span style=\"line-height: 1.7;\">介绍</span></h2><p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 看下面的例子：</p><pre><code><span>interface</span> Named {\n    name: <span>string</span>;\n}\n\n<span>class</span> Person {\n    name: <span>string</span>;\n}\n\n<span>let</span> p: Named;\n<span>// OK, because of structural typing</span>\np = <span>new</span> Person();\n</code></pre><p>在使用基于名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。</p><p>TypeScript的结构性子类型是根据JavaScript代码的典型写法来设计的。 因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p><h2>关于可靠性的注意事项</h2><p>TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p><h1>开始</h1><p>TypeScript结构化类型系统的基本规则是，如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性。比如：</p><pre><code><span>interface</span> Named {\n    name: <span>string</span>;\n}\n\n<span>let</span> x: Named;\n<span>// y's inferred type is { name: string; location: string; }</span>\n<span>let</span> y = { name: <span>'Alice'</span>, location: <span>'Seattle'</span> };\nx = y;\n</code></pre><p>这里要检查<code>y</code>是否能赋值给<code>x</code>，编译器检查<code>x</code>中的每个属性，看是否能在<code>y</code>中也找到对应属性。 在这个例子中，<code>y</code>必须包含名字是<code>name</code>的<code>string</code>类型成员。<code>y</code>满足条件，因此赋值正确。</p><p>检查函数参数时使用相同的规则：</p><pre><code><span><span>function</span> <span>greet</span>(<span>n: Named</span>) </span>{\n    alert(<span>'Hello, '</span> + n.name);\n}\ngreet(y); <span>// OK</span>\n</code></pre><p>注意，<code>y</code>有个额外的<code>location</code>属性，但这不会引发错误。 只有目标类型（这里是 <code>Named</code>）的成员会被一一检查是否兼容。</p><p>这个比较过程是递归进行的，检查每个成员及子成员。</p><h1>比较两个函数</h1><p>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</p><pre><code><span>let</span> x = (a: <span>number</span>) =&gt; <span>0</span>;\n<span>let</span> y = (b: <span>number</span>, s: <span>string</span>) =&gt; <span>0</span>;\n\ny = x; <span>// OK</span>\nx = y; <span>// Error</span>\n</code></pre><p>要查看<code>x</code>是否能赋值给<code>y</code>，首先看它们的参数列表。 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里， <code>x</code>的每个参数在<code>y</code>中都能找到对应的参数，所以允许赋值。</p><p>第二个赋值错误，因为<code>y</code>有个必需的第二个参数，但是<code>x</code>并没有，所以不允许赋值。</p><p>你可能会疑惑为什么允许<code>忽略</code>参数，像例子<code>y = x</code>中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如， <code>Array#forEach</code>给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p><pre><code><span>let</span> items = [<span>1</span>, <span>2</span>, <span>3</span>];\n\n<span>// Don't force these extra arguments</span>\nitems.forEach((item, index, array) =&gt; <span>console</span>.log(item));\n\n<span>// Should be OK!</span>\nitems.forEach((item) =&gt; <span>console</span>.log(item));\n</code></pre><p>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数：</p><pre><code><span>let</span> x = () =&gt; ({name: <span>'Alice'</span>});\n<span>let</span> y = () =&gt; ({name: <span>'Alice'</span>, location: <span>'Seattle'</span>});\n\nx = y; <span>// OK</span>\ny = x; <span>// Error because x() lacks a location property</span>\n</code></pre><p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p><h2>函数参数双向协变</h2><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：</p><pre><code><span>enum</span> EventType { Mouse, Keyboard }\n\n<span>interface</span> Event { timestamp: <span>number</span>; }\n<span>interface</span> MouseEvent <span>extends</span> Event { x: <span>number</span>; y: <span>number</span> }\n<span>interface</span> KeyEvent <span>extends</span> Event { keyCode: <span>number</span> }\n\n<span><span>function</span> <span>listenEvent</span>(<span>eventType: EventType, handler: (n: Event</span>) =&gt; <span>void</span>) </span>{\n    <span>/* ... */</span>\n}\n\n<span>// Unsound, but useful and common</span>\nlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; <span>console</span>.log(e.x + <span>','</span> + e.y));\n\n<span>// Undesirable alternatives in presence of soundness</span>\nlistenEvent(EventType.Mouse, (e: Event) =&gt; <span>console</span>.log((&lt;MouseEvent&gt;e).x + <span>','</span> + (&lt;MouseEvent&gt;e).y));\nlistenEvent(EventType.Mouse, &lt;(e: Event) =&gt; <span>void</span>&gt;((e: MouseEvent) =&gt; <span>console</span>.log(e.x + <span>','</span> + e.y)));\n\n<span>// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span>\nlistenEvent(EventType.Mouse, (e: <span>number</span>) =&gt; <span>console</span>.log(e));\n</code></pre><h2>可选参数及剩余参数</h2><p>比较函数兼容性的时候，可选参数与必须参数是可交换的。 原类型上额外的可选参数并不会造成错误，目标类型的可选参数没有对应的参数也不是错误。</p><p>当一个函数有剩余参数时，它被当做无限个可选参数。</p><p>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些<code>undefinded</code>。</p><p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p><pre><code><span><span>function</span> <span>invokeLater</span>(<span>args: <span>any</span>[], callback: (...args: <span>any</span>[]</span>) =&gt; <span>void</span>) </span>{\n    <span>/* ... Invoke callback with 'args' ... */</span>\n}\n\n<span>// Unsound - invokeLater \"might\" provide any number of arguments</span>\ninvokeLater([<span>1</span>, <span>2</span>], (x, y) =&gt; <span>console</span>.log(x + <span>', '</span> + y));\n\n<span>// Confusing (x and y are actually required) and undiscoverable</span>\ninvokeLater([<span>1</span>, <span>2</span>], (x?, y?) =&gt; <span>console</span>.log(x + <span>', '</span> + y));\n</code></pre><h2>函数重载</h2><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p><h1>枚举</h1><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。比如，</p><pre><code><span>enum</span> Status { Ready, Waiting };\n<span>enum</span> Color { Red, Blue, Green };\n\n<span>let</span> status = Status.Ready;\nstatus = Color.Green;  <span>//error</span>\n</code></pre><h1>类</h1><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p><pre><code><span>class</span> Animal {\n    feet: <span>number</span>;\n    <span>constructor</span>(name: string, numFeet: number) { }\n}\n\n<span>class</span> Size {\n    feet: <span>number</span>;\n    <span>constructor</span>(numFeet: number) { }\n}\n\n<span>let</span> a: Animal;\n<span>let</span> s: Size;\n\na = s;  <span>//OK</span>\ns = a;  <span>//OK</span>\n</code></pre><h2>类的私有成员</h2><p>私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果它包含一个私有成员，那么目标类型必须包含来自同一个类的这个私有成员。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p><h1>泛型</h1><p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如，</p><pre><code><span>interface</span> Empty&lt;T&gt; {\n}\n<span>let</span> x: Empty&lt;<span>number</span>&gt;;\n<span>let</span> y: Empty&lt;<span>string</span>&gt;;\n\nx = y;  <span>// okay, y matches structure of x</span>\n</code></pre><p>上面代码里，<code>x</code>和<code>y</code>是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p><pre><code><span>interface</span> NotEmpty&lt;T&gt; {\n    data: T;\n}\n<span>let</span> x: NotEmpty&lt;<span>number</span>&gt;;\n<span>let</span> y: NotEmpty&lt;<span>string</span>&gt;;\n\nx = y;  <span>// error, x and y are not compatible</span>\n</code></pre><p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p><p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成<code>any</code>比较。 然后用结果类型进行比较，就像上面第一个例子。</p><p>比如，</p><pre><code><span>let</span> identity = <span><span>function</span>&lt;<span>T</span>&gt;(<span>x: T</span>): <span>T</span> </span>{\n    <span>// ...</span>\n}\n\n<span>let</span> reverse = <span><span>function</span>&lt;<span>U</span>&gt;(<span>y: U</span>): <span>U</span> </span>{\n    <span>// ...</span>\n}\n\nidentity = reverse;  <span>// Okay because (x: any)=&gt;any matches (y: any)=&gt;any</span>\n</code></pre><h1>高级主题</h1><h2>子类型与赋值</h2><p>目前为止，我们使用了<code>兼容性</code>，它在语言规范里没有定义。 在TypeScript里，有两种类型的兼容性：子类型与赋值。 它们的不同点在于，赋值扩展了子类型兼容，允许给 <code>any</code>赋值或从<code>any</code>取值和允许数字赋值给枚举类型或枚举类型赋值给数字。</p><p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的甚至在<code>implements</code>和<code>extends</code>语句里。 更多信息，请参阅 <a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md\" rel=\"external nofollow\" target=\"_blank\">TypeScript语言规范</a>.</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 8,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "442ecbcb96f8e2209984371f7c7acfc3",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 类型推论",
      "chapter_level_two_url": "/typescript/typescript-type-inference.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>类型推论<span style=\"line-height: 1.7;\">介绍</span></h1><p>这节介绍TypeScript里的类型推论。即，类型是在哪里如何被推断的。</p><h1>基础</h1><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子</p><pre><code><span>let</span> x = <span>3</span>;\n</code></pre><p>变量<code>x</code>的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p><p>大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。</p><h1>最佳通用类型</h1><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p><pre><code><span>let</span> x = [<span>0</span>, <span>1</span>, <span>null</span>];\n</code></pre><p>为了推断<code>x</code>的类型，我们必须考虑所有元素的类型。 这里有两种选择： <code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p><p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：</p><pre><code><span>let</span> zoo = [<span>new</span> Rhino(), <span>new</span> Elephant(), <span>new</span> Snake()];\n</code></pre><p>这里，我们想让zoo被推断为<code>Animal[]</code>类型，但是这个数组里没有对象是<code>Animal</code>类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p><pre><code><span>let</span> zoo: Animal[] = [<span>new</span> Rhino(), <span>new</span> Elephant(), <span>new</span> Snake()];\n</code></pre><p>如果没有找到最佳通用类型的话，类型推论的结果是空对象类型，<code>{}</code>。 因为这个类型没有任何成员，所以访问其成员的时候会报错。</p><h1>上下文类型</h1><p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p><pre><code><span>window</span>.onmousedown = <span><span>function</span>(<span>mouseEvent</span>) </span>{\n    <span>console</span>.log(mouseEvent.buton);  <span>//&lt;- Error</span>\n};\n</code></pre><p>这个例子会得到一个类型错误，TypeScript类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code>参数的类型了。 如果函数表达式不是在上下文类型的位置，<code>mouseEvent</code>参数的类型需要指定为<code>any</code>，这样也不会报错了。</p><p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：</p><pre><code><span>window</span>.onmousedown = <span><span>function</span>(<span>mouseEvent: <span>any</span></span>) </span>{\n    <span>console</span>.log(mouseEvent.buton);  <span>//&lt;- Now, no error is given</span>\n};\n</code></pre><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。</p><p>上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：</p><pre><code><span><span>function</span> <span>createZoo</span>(<span></span>): <span>Animal</span>[] </span>{\n    <span>return</span> [<span>new</span> Rhino(), <span>new</span> Elephant(), <span>new</span> Snake()];\n}\n</code></pre><p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhino</code>，<code>Elephant</code>和<code>Snake</code>。 当然， <code>Animal</code>会被做为最佳通用类型。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 7,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "64a2f345a91a9102a22ce31355dddc2c",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 枚举",
      "chapter_level_two_url": "/typescript/typescript-enums.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript 枚举</h1><p>使用枚举我们可以定义一些有名字的数字常量。 枚举通过 <code>enum</code>关键字来定义。</p><pre><code><span>enum</span> Direction {\n    Up = <span>1</span>,\n    Down,\n    Left,\n    Right\n}\n</code></pre><p>一个枚举类型可以包含零个或多个枚举成员。 枚举成员具有一个数字值，它可以是 <em>常数</em>或是<em>计算得出的值</em> 当满足如下条件时，枚举成员被当作是常数：</p><ul><li>不具有初始化函数并且之前的枚举成员是常数。 在这种情况下，当前枚举成员的值为上一个枚举成员的值加1。 但第一个枚举元素是个例外。 如果它没有初始化方法，那么它的初始值为 <code>0</code>。</li><li>枚举成员使用<em>常数枚举表达式</em>初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：<ul><li>数字字面量</li><li>引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的） 如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用。</li><li>带括号的常数枚举表达式</li><li><code>+</code>, <code>-</code>, <code>~</code> 一元运算符应用于常数枚举表达式</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> 二元运算符，常数枚举表达式做为其一个操作对象 若常数枚举表达式求值后为 <code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错。</li></ul></li></ul><p>所有其它情况的枚举成员被当作是需要计算得出的值。</p><pre><code><span>enum</span> FileAccess {\n    <span>// constant members</span>\n    None,\n    Read    = <span>1</span> &lt;&lt; <span>1</span>,\n    Write   = <span>1</span> &lt;&lt; <span>2</span>,\n    ReadWrite  = Read | Write\n    <span>// computed member</span>\n    G = <span>\"123\"</span>.length\n}\n</code></pre><p>枚举是在运行时真正存在的一个对象。 其中一个原因是因为这样可以从枚举值到枚举名进行反向映射。</p><pre><code><span>enum</span> Enum {\n    A\n}\n<span>let</span> a = Enum.A;\n<span>let</span> nameOfA = Enum[Enum.A]; <span>// \"A\"</span>\n</code></pre><p>编译成：</p><pre><code><span>var</span> Enum;\n(<span><span>function</span> (<span>Enum</span>) </span>{\n    Enum[Enum[<span>\"A\"</span>] = <span>0</span>] = <span>\"A\"</span>;\n})(Enum || (Enum = {}));\n<span>var</span> a = Enum.A;\n<span>var</span> nameOfA = Enum[Enum.A]; <span>// \"A\"</span>\n</code></pre><p>生成的代码中，枚举类型被编译成一个对象，它包含双向映射（<code>name</code> -&gt; <code>value</code>）和（<code>value</code> -&gt; <code>name</code>）。 引用枚举成员总会生成一次属性访问并且永远不会内联。 在大多数情况下这是很好的并且正确的解决方案。 然而有时候需求却比较严格。 当访问枚举值时，为了避免生成多余的代码和间接引用，可以使用常数枚举。 常数枚举是在<code>enum</code>关键字前使用<code>const</code>修饰符。</p><pre><code><span>const</span> <span>enum</span> Enum {\n    A = <span>1</span>,\n    B = A * <span>2</span>\n}\n</code></pre><p>常数枚举只能使用常数枚举表达式并且不同于常规的枚举的是它们在编译阶段会被删除。 常数枚举成员在使用的地方被内联进来。 这是因为常数枚举不可能有计算成员。</p><pre><code><span>const</span> <span>enum</span> Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\n<span>let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]\n</code></pre><p>生成后的代码为：</p><pre><code><span>var</span> directions = [<span>0</span> <span>/* Up */</span>, <span>1</span> <span>/* Down */</span>, <span>2</span> <span>/* Left */</span>, <span>3</span> <span>/* Right */</span>];\n</code></pre><h1>外部枚举</h1><p>外部枚举用来描述已经存在的枚举类型的形状。</p><pre><code><span>declare</span> <span>enum</span> Enum {\n    A = <span>1</span>,\n    B,\n    C = <span>2</span>\n}\n</code></pre><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 6,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "2a2bd04225da5bd90153aec7faa65a32",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 泛型",
      "chapter_level_two_url": "/typescript/typescript-generics.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript泛型<span style=\"line-height: 1.7;\">介绍</span></h1>\n<p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像C#和Java这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h1>泛型之Hello World</h1>\n<p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是<code>echo</code>命令。</p>\n<p>不用泛型的话，这个函数可能是下面这样：</p><pre><code><span><span>function</span> <span>identity</span>(<span>arg: <span>number</span></span>): <span>number</span> </span>{\n    <span>return</span> arg;\n}\n</code></pre>\n<p>或者，我们使用<code>any</code>类型来定义函数：</p><pre><code><span><span>function</span> <span>identity</span>(<span>arg: <span>any</span></span>): <span>any</span> </span>{\n    <span>return</span> arg;\n}\n</code></pre>\n<p>虽然使用<code>any</code>类型后这个函数已经能接收任何类型的arg参数，但是却丢失了一些信息：传入的类型与返回的类型应该是相同的。 如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 <em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p><pre><code><span><span>function</span> <span>identity</span>&lt;<span>T</span>&gt;(<span>arg: T</span>): <span>T</span> </span>{\n    <span>return</span> arg;\n}\n</code></pre>\n<p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>\n<p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>\n<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p><pre><code><span>let</span> output = identity&lt;<span>string</span>&gt;(<span>\"myString\"</span>);  <span>// type of output will be 'string'</span>\n</code></pre>\n<p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p>\n<p>第二种方法更普遍。利用了<em>类型推论</em> -- 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p><pre><code><span>let</span> output = identity(<span>\"myString\"</span>);  <span>// type of output will be 'string'</span>\n</code></pre>\n<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。</p>\n<h1>使用泛型变量</h1>\n<p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>\n<p>看下之前<code>identity</code>例子：</p><pre><code><span><span>function</span> <span>identity</span>&lt;<span>T</span>&gt;(<span>arg: T</span>): <span>T</span> </span>{\n    <span>return</span> arg;\n}\n</code></pre>\n<p>如果我们想同时打印出<code>arg</code>的长度。 我们很可能会这样做：</p><pre><code><span><span>function</span> <span>loggingIdentity</span>&lt;<span>T</span>&gt;(<span>arg: T</span>): <span>T</span> </span>{\n    <span>console</span>.log(arg.length);  <span>// Error: T doesn't have .length</span>\n    <span>return</span> arg;\n}\n</code></pre>\n<p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p>\n<p>现在假设我们想操作<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><pre><code><span><span>function</span> <span>loggingIdentity</span>&lt;<span>T</span>&gt;(<span>arg: T[]</span>): <span>T</span>[] </span>{\n    <span>console</span>.log(arg.length);  <span>// Array has a .length, so no more error</span>\n    <span>return</span> arg;\n}\n</code></pre>\n<p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>，和函数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时<code>T</code>的的类型为<code>number</code>。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>\n<p>我们也可以这样实现上面的例子：</p><pre><code><span><span>function</span> <span>loggingIdentity</span>&lt;<span>T</span>&gt;(<span>arg: <span>Array</span>&lt;T&gt;</span>): <span>Array</span>&lt;<span>T</span>&gt; </span>{\n    <span>console</span>.log(arg.length);  <span>// Array has a .length, so no more error</span>\n    <span>return</span> arg;\n}\n</code></pre>\n<p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 <code>Array&lt;T&gt;</code>一样。</p>\n<h1>泛型接口</h1>\n<p>我们来到了泛型接口；让我们创建一个泛型接口来与 <code>identities()</code> 一起使用：</p><pre><code>interface Identities&lt;V, W&gt; {\n   id1: V,\n   id2: W\n}\n</code></pre><ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n<p>我在这里使用 V 和 W 作为类型变量来表示任何字母(或有效的字母和数字名称的组合)都是可以的——除了用于常规目的之外，它们的名称没有任何意义。</p>\n<p>现在，我们可以将这个接口应用为 <code>identities()</code>的返回类型，并稍稍修改返回类型去迎合它。我们还可以 <code>console.log</code> 这些参数和它们的类型，以便进一步说明:</p><pre><code>function identities&lt;T, U&gt; (arg1: T, arg2: U): Identities&lt;T, U&gt; {\n   console.log(arg1 + \": \" + typeof (arg1));\n   console.log(arg2 + \": \" + typeof (arg2));\n   let identities: Identities&lt;T, U&gt; = {\n    id1: arg1,\n    id2: arg2\n  };\n  return identities;\n}\n</code></pre><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul>\n<p>我们现在 <code>identities()</code> 所做的是将类型 T 和 U 传递到函数和 <code>Identities</code> 接口中，使我们能够定义与参数类型相关的返回类型。</p>\n<p>注意:如果编译 TS 项目并查找泛型，则不会找到任何泛型。由于在 Javascript 中不支持泛型，所以在编译器生成的构建中不会看到泛型。泛型纯粹是用于编译时的开发安全网，它将确保代码的类型安全抽象。</p>\n<h1>泛型类</h1>\n<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p><pre><code><span>class</span> GenericNumber&lt;T&gt; {\n    zeroValue: T;\n    add: (x: T, y: T) =&gt; T;\n}\n\n<span>let</span> myGenericNumber = <span>new</span> GenericNumber&lt;<span>number</span>&gt;();\nmyGenericNumber.zeroValue = <span>0</span>;\nmyGenericNumber.add = <span><span>function</span>(<span>x, y</span>) </span>{ <span>return</span> x + y; };\n</code></pre>\n<p><code>GenericNumber</code>类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用<code>number</code>类型。 也可以使用字符串或其它更复杂的类型。</p><pre><code><span>let</span> stringNumeric = <span>new</span> GenericNumber&lt;<span>string</span>&gt;();\nstringNumeric.zeroValue = <span>\"\"</span>;\nstringNumeric.add = <span><span>function</span>(<span>x, y</span>) </span>{ <span>return</span> x + y; };\n\nalert(stringNumeric.add(stringNumeric.zeroValue, <span>\"test\"</span>));\n</code></pre>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n<p>我们在<a href=\"http://www.tslang.cn/docs/handbook/Classes.md\" rel=\"external nofollow\" target=\"_blank\">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n<h1>泛型约束</h1>\n<p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在<code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p><pre><code><span><span>function</span> <span>loggingIdentity</span>&lt;<span>T</span>&gt;(<span>arg: T</span>): <span>T</span> </span>{\n    <span>console</span>.log(arg.length);  <span>// Error: T doesn't have .length</span>\n    <span>return</span> arg;\n}\n</code></pre>\n<p>相比于操作<code>any</code>所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>\n<p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字还实现约束：</p><pre><code><span>interface</span> Lengthwise {\n    length: <span>number</span>;\n}\n\n<span><span>function</span> <span>loggingIdentity</span>&lt;<span>T</span> <span>extends</span> <span>Lengthwise</span>&gt;(<span>arg: T</span>): <span>T</span> </span>{\n    <span>console</span>.log(arg.length);  <span>// Now we know it has a .length property, so no more error</span>\n    <span>return</span> arg;\n}\n</code></pre>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><pre><code>loggingIdentity(<span>3</span>);  <span>// Error, number doesn't have a .length property</span>\n</code></pre>\n<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p><pre><code>loggingIdentity({length: <span>10</span>, value: <span>3</span>});\n</code></pre>\n<h2>在泛型约束中使用类型参数</h2>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。比如，</p><pre><code><span><span>function</span> <span>find</span>&lt;<span>T</span>, <span>U</span> <span>extends</span> <span>Findable</span>&lt;<span>T</span>&gt;&gt;(<span>n: T, s: U</span>) </span>{\n  <span>// ...</span>\n}\nfind (giraffe, myAnimals);\n</code></pre>\n<h2>在泛型里使用类类型</h2>\n<p>在 TypeScript 使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p><pre><code><span><span>function</span> <span>create</span>&lt;<span>T</span>&gt;(<span>c: {<span>new</span>(</span>): <span>T</span></span>; }): T {\n    <span>return</span> <span>new</span> c();\n}\n</code></pre>\n<p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p><pre><code><span>class</span> BeeKeeper {\n    hasMask: <span>boolean</span>;\n}\n\n<span>class</span> ZooKeeper {\n    nametag: <span>string</span>;\n}\n\n<span>class</span> Animal {\n    numLegs: <span>number</span>;\n}\n\n<span>class</span> Bee extends Animal {\n    keeper: BeeKeeper;\n}\n\n<span>class</span> Lion extends Animal {\n    keeper: ZooKeeper;\n}\n\n<span><span>function</span> <span>findKeeper</span>&lt;<span>A</span> <span>extends</span> <span>Animal</span>, <span>K</span>&gt; (<span>a: {<span>new</span>(</span>): <span>A</span></span>;\n    prototype: {keeper: K}}): K {\n\n    <span>return</span> a.prototype.keeper;\n}\n\nfindKeeper(Lion).nametag;  <span>// typechecks!</span></code></pre>\n<p>\n    <br>\n</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 5,
      "parent_sort_index": 7,
      "chapter_level_one_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 项目配置",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "509d4b7166b73c73ef47cfe4ab7f22b7",
      "chapter_level_two_parent_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_two_name": "TypeScript 每日构建",
      "chapter_level_two_url": "/typescript/typescript-nightly-builds.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">TypeScript每日构建</font></font></h1><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">在太平洋标准时间每天午夜会自动构建</font></font><a href=\"https://github.com/Microsoft/TypeScript/tree/master\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">TypeScript的</font></font><code>master</code></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">分支代码并发布到NPM和NuGet上。下面将介绍如何获得并在工具里使用它们。</font></font></p><h2><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">使用npm</font></font></h2><pre><code>npm install -g typescript@next\n</code></pre><h2><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">使用NuGet和MSBuild</font></font></h2><blockquote><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">注意：你需要配置工程来使用NuGet包。详细信息参考  </font></font><a href=\"https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">配置MSBuild工程来使用NuGet</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。</font></font></p></blockquote><p><a href=\"https://www.myget.org/gallery/typescript-preview\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">www.myget.org</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">有两个包：</font></font></p><ul><li><code>Microsoft.TypeScript.Compiler</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">：仅包含工具（</font></font><code>tsc.exe</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">，</font></font><code>lib.d.ts</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">，等。）。</font></font></li><li><code>Microsoft.TypeScript.MSBuild</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">：和上面一样的工具，还有的MSBuild的任务和目标（</font></font><code>Microsoft.TypeScript.targets</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">， </font></font><code>Microsoft.TypeScript.Default.props</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。，</font><font style=\"vertical-align: inherit;\">等）</font></font></li></ul><h2><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">更新IDE来使用每日构建</font></font></h2><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">你还可以配置IDE来使用每日构建。首先你要通过npm安装包。你可以进行全局安装或者安装到本地的</font></font><code>node_modules</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">目录下。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">下面的步骤里我们假设你已经安装好了</font></font><code>typescript@next</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。</font></font></p><h3><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Visual Studio代码</font></font></h3><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">更新</font></font><code>.vscode/settings.json</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">如下：</font></font></p><pre><code><span>\"typescript.tsdk\"</span>: <span>\"&lt;path to your folder&gt;/node_modules/typescript/lib\"</span>\n</code></pre><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">详细信息参见</font></font><a href=\"https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">VSCode文档</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。</font></font></p><h3><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">崇高文本</font></font></h3><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">更新</font></font><code>Settings - User</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">如下：</font></font></p><pre><code><span>\"typescript_tsdk\"</span>: <span>\"&lt;path to your folder&gt;/node_modules/typescript/lib\"</span>\n</code></pre><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">详细信息参见</font></font><a href=\"https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">如何在Sublime Text里安装TypeScript插件</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。</font></font></p><h3><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Visual Studio 2013和2015</font></font></h3><blockquote><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">注意：大多数的改变不需要你安装新版本的VS TypeScript插件。</font></font></p></blockquote><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">当前的每日构建不包含完整的插件安装包，但是我们正在试着提供每日构建的安装包。</font></font></p><ol><li><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">下载</font></font><a href=\"https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1\" rel=\"external nofollow\" target=\"_blank\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">VSDevMode.ps1</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">脚本。</font></font></p><blockquote><p>参考wiki文档：<a href=\"https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file\" rel=\"external nofollow\" target=\"_blank\">使用自定义语言服务文件</a>。</p></blockquote></li><li><p>在PowerShell命令行窗口里执行：</p></li></ol><p>VS 2015：</p><pre><code>VSDevMode.ps1 14 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib\n</code></pre><p>VS 2013：</p><pre><code>VSDevMode.ps1 12 -tsScript &lt;path to your folder&gt;/node_modules/typescript/lib\n</code></pre><h3>IntelliJ IDEA (Mac)</h3><p>前往<code>Preferences</code> &gt; <code>Languages &amp; Frameworks</code> &gt; <code>TypeScript</code>：</p><blockquote><p>TypeScript Version: 如果通过NPM安装：<code>/usr/local/lib/node_modules/typescript/lib</code></p></blockquote></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 4,
      "parent_sort_index": 7,
      "chapter_level_one_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 项目配置",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "be0ce65a7d6ed018380d51a12741cec1",
      "chapter_level_two_parent_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_two_name": "TypeScript 构建工具整合",
      "chapter_level_two_url": "/typescript/typescript-integrating-with-build-tools.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>与其它构建工具整合</h1><h1>Browserify</h1><h3>安装</h3><pre><code>npm install tsify\n</code></pre><h3>使用命令行交互</h3><pre><code>browserify main.ts -p [ tsify --noImplicitAny ] &gt; bundle.js\n</code></pre><h3>使用API</h3><pre><code><span>var</span> browserify = <span>require</span>(<span>\"browserify\"</span>);\n<span>var</span> tsify = <span>require</span>(<span>\"tsify\"</span>);\n\nbrowserify()\n    .add(<span>'main.ts'</span>)\n    .plugin(<span>'tsify'</span>, { noImplicitAny: <span>true</span> })\n    .bundle()\n    .pipe(process.stdout);\n</code></pre><p>更多详细信息：<a href=\"https://github.com/smrq/tsify\" rel=\"external nofollow\" target=\"_blank\">smrq/tsify</a></p><h1>Duo</h1><h3>安装</h3><pre><code>npm install duo-typescript\n</code></pre><h3>使用命令行交互</h3><pre><code>duo --use duo-typescript entry.ts\n</code></pre><h3>使用API</h3><pre><code><span>var</span> Duo = <span>require</span>(<span>'duo'</span>);\n<span>var</span> fs = <span>require</span>(<span>'fs'</span>)\n<span>var</span> path = <span>require</span>(<span>'path'</span>)\n<span>var</span> typescript = <span>require</span>(<span>'duo-typescript'</span>);\n\n<span>var</span> out = path.join(__dirname, <span>\"output.js\"</span>)\n\nDuo(__dirname)\n    .entry(<span>'entry.ts'</span>)\n    .use(typescript())\n    .run(<span><span>function</span> (<span>err, results</span>) </span>{\n        <span>if</span> (err) <span>throw</span> err;\n        <span>// Write compiled result to output file</span>\n        fs.writeFileSync(out, results.code);\n    });\n</code></pre><p>更多详细信息：<a href=\"https://github.com/frankwallis/duo-typescript\" rel=\"external nofollow\" target=\"_blank\">frankwallis/duo-typescript</a></p><h1>Grunt</h1><h3>安装</h3><pre><code>npm install grunt-ts\n</code></pre><h3>基本Gruntfile.js</h3><pre><code><span>module</span>.exports = <span><span>function</span>(<span>grunt</span>) </span>{\n    grunt.initConfig({\n        ts: {\n            <span>default</span> : {\n                src: [<span>\"**/*.ts\"</span>, <span>\"!node_modules/**/*.ts\"</span>]\n            }\n        }\n    });\n    grunt.loadNpmTasks(<span>\"grunt-ts\"</span>);\n    grunt.registerTask(<span>\"default\"</span>, [<span>\"ts\"</span>]);\n};\n</code></pre><p>更多详细信息：<a href=\"https://github.com/TypeStrong/grunt-ts\" rel=\"external nofollow\" target=\"_blank\">TypeStrong/grunt-ts</a></p><h1>gulp</h1><h3>安装</h3><pre><code>npm install gulp-typescript\n</code></pre><h3>基本gulpfile.js</h3><pre><code><span>var</span> gulp = <span>require</span>(<span>\"gulp\"</span>);\n<span>var</span> ts = <span>require</span>(<span>\"gulp-typescript\"</span>);\n\ngulp.task(<span>\"default\"</span>, <span><span>function</span> (<span></span>) </span>{\n    <span>var</span> tsResult = gulp.src(<span>\"src/*.ts\"</span>)\n        .pipe(ts({\n              noImplicitAny: <span>true</span>,\n              out: <span>\"output.js\"</span>\n        }));\n    <span>return</span> tsResult.js.pipe(gulp.dest(<span>'built/local'</span>));\n});\n</code></pre><p>更多详细信息：<a href=\"https://github.com/ivogabe/gulp-typescript\" rel=\"external nofollow\" target=\"_blank\">ivogabe/gulp-typescript</a></p><h1>jspm</h1><h3>安装</h3><pre><code>npm install -g jspm@beta\n</code></pre><p><em>注意：目前jspm的0.16beta版本支持TypeScript</em></p><p>更多详细信息：<a href=\"https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm\" rel=\"external nofollow\" target=\"_blank\">TypeScriptSamples/jspm</a></p><h1>webpack</h1><h3>安装</h3><pre><code>npm install ts-loader --save-dev\n</code></pre><h3>基本webpack.config.js</h3><pre><code><span>module</span>.exports = {\n    entry: <span>\"./src/index.tsx\"</span>,\n    output: {\n        filename: <span>\"bundle.js\"</span>\n    },\n    resolve: {\n        <span>// Add '.ts' and '.tsx' as a resolvable extension.</span>\n        extensions: [<span>\"\"</span>, <span>\".webpack.js\"</span>, <span>\".web.js\"</span>, <span>\".ts\"</span>, <span>\".tsx\"</span>, <span>\".js\"</span>]\n    },\n    <span>module</span>: {\n        loaders: [\n            <span>// all files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'</span>\n            { test: <span>/\\.tsx?$/</span>, loader: <span>\"ts-loader\"</span> }\n        ]\n    }\n};\n</code></pre><p>查看<a href=\"https://www.npmjs.com/package/ts-loader\" rel=\"external nofollow\" target=\"_blank\">更多关于ts-loader的详细信息</a></p><p>或者</p><ul><li><a href=\"https://www.npmjs.com/package/awesome-typescript-loader\" rel=\"external nofollow\" target=\"_blank\">awesome-typescript-loader</a></li></ul><h1>MSBuild</h1><p>更新工程文件，包含本地安装的<code>Microsoft.TypeScript.Default.props</code>（在顶端）和<code>Microsoft.TypeScript.targets</code>（在底部）文件：</p><pre><code><span><span>&lt;?</span>xml version=<span>\"1.0\"</span> encoding=<span>\"utf-8\"</span><span>?&gt;</span></span>\n<span>&lt;<span>Project</span> <span>ToolsVersion</span>=<span>\"4.0\"</span> <span>DefaultTargets</span>=<span>\"Build\"</span> <span>xmlns</span>=<span>\"http://schemas.microsoft.com/developer/msbuild/2003\"</span>&gt;</span>\n  <span>&lt;!-- Include default props at the bottom --&gt;</span>\n  <span>&lt;<span>Import</span>\n      <span>Project</span>=<span>\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"</span>\n      <span>Condition</span>=<span>\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\"</span> /&gt;</span>\n\n  <span>&lt;!-- TypeScript configurations go here --&gt;</span>\n  <span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>\"'$(Configuration)' == 'Debug'\"</span>&gt;</span>\n    <span>&lt;<span>TypeScriptRemoveComments</span>&gt;</span>false<span>&lt;/<span>TypeScriptRemoveComments</span>&gt;</span>\n    <span>&lt;<span>TypeScriptSourceMap</span>&gt;</span>true<span>&lt;/<span>TypeScriptSourceMap</span>&gt;</span>\n  <span>&lt;/<span>PropertyGroup</span>&gt;</span>\n  <span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>\"'$(Configuration)' == 'Release'\"</span>&gt;</span>\n    <span>&lt;<span>TypeScriptRemoveComments</span>&gt;</span>true<span>&lt;/<span>TypeScriptRemoveComments</span>&gt;</span>\n    <span>&lt;<span>TypeScriptSourceMap</span>&gt;</span>false<span>&lt;/<span>TypeScriptSourceMap</span>&gt;</span>\n  <span>&lt;/<span>PropertyGroup</span>&gt;</span>\n\n  <span>&lt;!-- Include default targets at the bottom --&gt;</span>\n  <span>&lt;<span>Import</span>\n      <span>Project</span>=<span>\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"</span>\n      <span>Condition</span>=<span>\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"</span> /&gt;</span>\n<span>&lt;/<span>Project</span>&gt;</span>\n</code></pre><p>关于配置MSBuild编译器选项的更多详细信息，请参考：[在MSBuild里使用编译选项](./Compiler Options in MSBuild.md)</p><h1>NuGet</h1><ul><li>右键点击 -&gt; Manage NuGet Packages</li><li>查找<code>Microsoft.TypeScript.MSBuild</code></li><li>点击<code>Install</code></li><li>安装完成后，Rebuild。</li></ul><p>更多详细信息请参考<a href=\"http://docs.nuget.org/Consume/Package-Manager-Dialog\" rel=\"external nofollow\" target=\"_blank\">Package Manager Dialog</a>和<a href=\"https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild\" rel=\"external nofollow\" target=\"_blank\">using nightly builds with NuGet</a></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 3,
      "parent_sort_index": 7,
      "chapter_level_one_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 项目配置",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b26124955272ffe59cb5228c61858c50",
      "chapter_level_two_parent_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_two_name": "TypeScript MSBuild编译选项",
      "chapter_level_two_url": "/typescript/typescript-msbuild.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>在MSBuild里使用编译选项</h1><h2>概述</h2><p>编译选项可以在使用MSBuild的项目里通过MSBuild属性指定。</p><h2>例子</h2><pre><code><span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>\"'$(Configuration)' == 'Debug'\"</span>&gt;</span>\n  <span>&lt;<span>TypeScriptRemoveComments</span>&gt;</span>false<span>&lt;/<span>TypeScriptRemoveComments</span>&gt;</span>\n  <span>&lt;<span>TypeScriptSourceMap</span>&gt;</span>true<span>&lt;/<span>TypeScriptSourceMap</span>&gt;</span>\n<span>&lt;/<span>PropertyGroup</span>&gt;</span>\n<span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>\"'$(Configuration)' == 'Release'\"</span>&gt;</span>\n  <span>&lt;<span>TypeScriptRemoveComments</span>&gt;</span>true<span>&lt;/<span>TypeScriptRemoveComments</span>&gt;</span>\n  <span>&lt;<span>TypeScriptSourceMap</span>&gt;</span>false<span>&lt;/<span>TypeScriptSourceMap</span>&gt;</span>\n<span>&lt;/<span>PropertyGroup</span>&gt;</span>\n<span>&lt;<span>Import</span> <span>Project</span>=<span>\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"</span>\n        <span>Condition</span>=<span>\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\"</span> /&gt;</span>\n</code></pre><h2>映射</h2><table><thead><tr><th>编译选项</th><th>MSBuild属性名称</th><th>可用值</th></tr></thead><tbody><tr><td><code>--declaration</code></td><td>TypeScriptGeneratesDeclarations</td><td>布尔值</td></tr><tr><td><code>--module</code></td><td>TypeScriptModuleKind</td><td><code>AMD</code>, <code>CommonJs</code>, <code>UMD</code> 或 <code>System</code></td></tr><tr><td><code>--target</code></td><td>TypeScriptTarget</td><td><code>ES3</code>, <code>ES5</code>, or <code>ES6</code></td></tr><tr><td><code>--charset</code></td><td>TypeScriptCharset</td><td> </td></tr><tr><td><code>--emitBOM</code></td><td>TypeScriptEmitBOM</td><td>布尔值</td></tr><tr><td><code>--emitDecoratorMetadata</code></td><td>TypeScriptEmitDecoratorMetadata</td><td>布尔值</td></tr><tr><td><code>--experimentalDecorators</code></td><td>TypeScriptExperimentalDecorators</td><td>布尔值</td></tr><tr><td><code>--inlineSourceMap</code></td><td>TypeScriptInlineSourceMap</td><td>布尔值</td></tr><tr><td><code>--inlineSources</code></td><td>TypeScriptInlineSources</td><td>布尔值</td></tr><tr><td><code>--locale</code></td><td><em>自动的</em></td><td>自动设置成PreferredUILang的值</td></tr><tr><td><code>--mapRoot</code></td><td>TypeScriptMapRoot</td><td>文件路径</td></tr><tr><td><code>--newLine</code></td><td>TypeScriptNewLine</td><td><code>CRLF</code> 或 <code>LF</code></td></tr><tr><td><code>--noEmitOnError</code></td><td>TypeScriptNoEmitOnError</td><td>布尔值</td></tr><tr><td><code>--noEmitHelpers</code></td><td>TypeScriptNoEmitHelpers</td><td>布尔值</td></tr><tr><td><code>--noImplicitAny</code></td><td>TypeScriptNoImplicitAny</td><td>布尔值</td></tr><tr><td><code>--noUnusedLocals</code></td><td>TypeScriptNoUnusedLocals</td><td>布尔值</td></tr><tr><td><code>--noUnusedParameters</code></td><td>TypeScriptNoUnusedParameters</td><td>布尔值</td></tr><tr><td><code>--noLib</code></td><td>TypeScriptNoLib</td><td>布尔值</td></tr><tr><td><code>--noResolve</code></td><td>TypeScriptNoResolve</td><td>布尔值</td></tr><tr><td><code>--out</code></td><td>TypeScriptOutFile</td><td>文件路径</td></tr><tr><td><code>--outDir</code></td><td>TypeScriptOutDir</td><td>文件路径</td></tr><tr><td><code>--preserveConstEnums</code></td><td>TypeScriptPreserveConstEnums</td><td>布尔值</td></tr><tr><td><code>--removeComments</code></td><td>TypeScriptRemoveComments</td><td>布尔值</td></tr><tr><td><code>--rootDir</code></td><td>TypeScriptRootDir</td><td>文件路径</td></tr><tr><td><code>--isolatedModules</code></td><td>TypeScriptIsolatedModules</td><td>布尔值</td></tr><tr><td><code>--sourceMap</code></td><td>TypeScriptSourceMap</td><td>文件路径</td></tr><tr><td><code>--sourceRoot</code></td><td>TypeScriptSourceRoot</td><td>文件路径</td></tr><tr><td><code>--strictNullChecks</code></td><td>TypeScriptStrictNullChecks</td><td>布尔值</td></tr><tr><td><code>--suppressImplicitAnyIndexErrors</code></td><td>TypeScriptSuppressImplicitAnyIndexErrors</td><td>布尔值</td></tr><tr><td><code>--suppressExcessPropertyErrors</code></td><td>TypeScriptSuppressExcessPropertyErrors</td><td>布尔值</td></tr><tr><td><code>--moduleResolution</code></td><td>TypeScriptModuleResolution</td><td><code>Classic</code> or <code>Node</code></td></tr><tr><td><code>--experimentalAsyncFunctions</code></td><td>TypeScriptExperimentalAsyncFunctions</td><td>布尔值</td></tr><tr><td><code>--jsx</code></td><td>TypeScriptJSXEmit</td><td><code>React</code> or <code>Preserve</code></td></tr><tr><td><code>--reactNamespace</code></td><td>TypeScriptReactNamespace</td><td>string</td></tr><tr><td><code>--skipDefaultLibCheck</code></td><td>TypeScriptSkipDefaultLibCheck</td><td>布尔值</td></tr><tr><td><code>--allowUnusedLabels</code></td><td>TypeScriptAllowUnusedLabels</td><td>布尔值</td></tr><tr><td><code>--noImplicitReturns</code></td><td>TypeScriptNoImplicitReturns</td><td>布尔值</td></tr><tr><td><code>--noFallthroughCasesInSwitch</code></td><td>TypeScriptNoFallthroughCasesInSwitch</td><td>布尔值</td></tr><tr><td><code>--allowUnreachableCode</code></td><td>TypeScriptAllowUnreachableCode</td><td>布尔值</td></tr><tr><td><code>--forceConsistentCasingInFileNames</code></td><td>TypeScriptForceConsistentCasingInFileNames</td><td>布尔值</td></tr><tr><td><code>--allowSyntheticDefaultImports</code></td><td>TypeScriptAllowSyntheticDefaultImports</td><td>布尔值</td></tr><tr><td><code>--noImplicitUseStrict</code></td><td>TypeScriptNoImplicitUseStrict</td><td>布尔值</td></tr><tr><td><code>--project</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><code>--watch</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><code>--diagnostics</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><code>--listFiles</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><code>--noEmit</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><code>--allowJs</code></td><td><em>VS不支持</em></td><td> </td></tr><tr><td><em>VS特有选项</em></td><td>TypeScriptAdditionalFlags</td><td><em>任意编译选项</em></td></tr></tbody></table><h2>我使用的Visual Studio版本里支持哪些选项?</h2><p>查找 <code>C:\\Program Files (x86)\\MSBuild\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets</code>文件。 可用的MSBuild XML标签与相应的<code>tsc</code>编译选项的映射都在那里。</p><h2>ToolsVersion</h2><p>工程文件里的<code>&lt;TypeScriptToolsVersion&gt;1.7&lt;/TypeScriptToolsVersion&gt;</code>属性值表明了构建时使用的编译器的版本号（这个例子里是1.7） 这样就允许一个工程在不同的机器上使用固定的版本去编译。</p><p>如果没有指定<code>TypeScriptToolsVersion</code>，则会使用机器上安装的最新版本的编译器去构建。</p><p>如果用户使用的是更新版本的TypeScript，则会在首次加载工程的时候看到一个提示升级工程的对话框。</p><h2>TypeScriptCompileBlocked</h2><p>如果你使用其它的构建工具（比如，gulp， grunt等等）并且使用VS做为开发和调试工具，那么在工程里设置<code>&lt;TypeScriptCompileBlocked&gt;true&lt;/TypeScriptCompileBlocked&gt;</code>。 这样VS只会提供给你编辑的功能，而不会在你按F5的时候去构建。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 2,
      "parent_sort_index": 7,
      "chapter_level_one_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 项目配置",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "2fd88fa183c267f08f61ded5b3ad8178",
      "chapter_level_two_parent_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_two_name": "TypeScript 编译选项",
      "chapter_level_two_url": "/typescript/typescript-compiler-options.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript编译选项</h1><h2>编译选项</h2><table><thead><tr><th>选项</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>--allowJs</code></td><td><code>boolean</code></td><td><code>true</code></td><td>允许编译javascript文件。</td></tr><tr><td><code>--allowSyntheticDefaultImports</code></td><td><code>boolean</code></td><td><code>module === \"system\"</code></td><td>允许从没有设置默认导出的模块中默认导入。这并不影响代码的显示，仅为了类型检查。</td></tr><tr><td><code>--allowUnreachableCode</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不报告执行不到的代码错误。</td></tr><tr><td><code>--allowUnusedLabels</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不报告未使用的标签错误。</td></tr><tr><td><code>--baseUrl</code></td><td><code>string</code></td><td> </td><td>解析非相对模块名的基准目录。查看<a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html#base-url\" rel=\"external nofollow\" target=\"_blank\">模块解析文档</a>了解详情。</td></tr><tr><td><code>--charset</code></td><td><code>string</code></td><td><code>\"utf8\"</code></td><td>输入文件的字符集。</td></tr><tr><td><code>--declaration</code><br><code>-d</code></td><td><code>boolean</code></td><td><code>false</code></td><td>生成相应的'.d.ts'文件。</td></tr><tr><td><code>--declarationDir</code></td><td><code>string</code></td><td> </td><td>生成声明文件的输出路径。</td></tr><tr><td><code>--diagnostics</code></td><td><code>boolean</code></td><td><code>false</code></td><td>显示诊断信息。</td></tr><tr><td><code>--disableSizeLimit</code></td><td><code>boolean</code></td><td><code>false</code></td><td>禁用JavaScript工程体积大小的限制</td></tr><tr><td><code>--emitBOM</code></td><td><code>boolean</code></td><td><code>false</code></td><td>在输出文件的开头加入BOM头（UTF-8 Byte Order Mark）。</td></tr><tr><td><code>--emitDecoratorMetadata</code><span>[1]</span></td><td><code>boolean</code></td><td><code>false</code></td><td>给源码里的装饰器声明加上设计类型元数据。查看<a href=\"https://github.com/Microsoft/TypeScript/issues/2577\" rel=\"external nofollow\" target=\"_blank\">issue #2577</a>了解更多信息。</td></tr><tr><td><code>--experimentalDecorators</code><span>[1]</span></td><td><code>boolean</code></td><td><code>false</code></td><td>实验性启用ES7装饰器支持。</td></tr><tr><td><code>--forceConsistentCasingInFileNames</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不允许不一致包装引用相同的文件。</td></tr><tr><td><code>--help</code><br><code>-h</code></td><td> </td><td> </td><td>打印帮助信息。</td></tr><tr><td><code>--inlineSourceMap</code></td><td><code>boolean</code></td><td><code>false</code></td><td>生成单个sourcemaps文件，而不是将每sourcemaps生成不同的文件。</td></tr><tr><td><code>--inlineSources</code></td><td><code>boolean</code></td><td><code>false</code></td><td>将代码与sourcemaps生成到一个文件中，要求同时设置了<code>--inlineSourceMap</code>或<code>--sourceMap</code>属性。</td></tr><tr><td><code>--init</code></td><td> </td><td> </td><td>初始化TypeScript项目并创建一个<code>tsconfig.json</code>文件。</td></tr><tr><td><code>--isolatedModules</code></td><td><code>boolean</code></td><td><code>false</code></td><td>无条件地给没有解析的文件生成imports。</td></tr><tr><td><code>--jsx</code></td><td><code>string</code></td><td><code>\"Preserve\"</code></td><td>在'.tsx'文件里支持JSX：'React' 或 'Preserve'。查看<a href=\"http://www.tslang.cn/docs/handbook/jsx.html\" rel=\"external nofollow\" target=\"_blank\">JSX</a>。</td></tr><tr><td><code>--lib</code></td><td><code>string[]</code></td><td> </td><td>编译过程中需要引入的库文件的列表。<br>可能的值为： <br>► <code>es5</code> <br>► <code>es6</code> <br>► <code>es2015</code> <br>► <code>es7</code> <br>► <code>es2016</code> <br>► <code>es2017</code> <code>dom</code> <code>webworker</code> <code>scripthost</code> <br>► <code>es2015.core</code> <br>► <code>es2015.collection</code> <br>► <code>es2015.generator</code> <br>► <code>es2015.iterable</code> <br>► <code>es2015.promise</code> <br>► <code>es2015.proxy</code> <br>► <code>es2015.reflect</code> <br>► <code>es2015.symbol</code> <br>► <code>es2015.symbol.wellknown</code> <br>► <code>es2016.array.include</code> <br>► <code>es2017.object</code> <br>► <code>es2017.sharedmemory</code> <br>注意：如果<code>--lib</code>没有指定默认库。默认库是<br>► For <code>--target ES5: dom,es5,scripthost</code><br>► For <code>--target ES6: dom,es6,dom.iterable,scripthost</code></td></tr><tr><td><code>--listEmittedFiles</code></td><td><code>boolean</code></td><td><code>false</code></td><td>打印出编译后生成文件的名字。</td></tr><tr><td><code>--listFiles</code></td><td><code>boolean</code></td><td><code>false</code></td><td>编译过程中打印文件名。</td></tr><tr><td><code>--locale</code></td><td><code>string</code></td><td><em>(platform specific)</em></td><td>显示错误信息时使用的语言，比如：en-us。</td></tr><tr><td><code>--mapRoot</code></td><td><code>string</code></td><td> </td><td>为调试器指定指定sourcemap文件的路径，而不是使用生成时的路径。当<code>.map</code>文件是在运行时指定的，并不同于<code>js</code>文件的地址时使用这个标记。指定的路径会嵌入到<code>sourceMap</code>里告诉调试器到哪里去找它们。</td></tr><tr><td><code>--maxNodeModuleJsDepth</code></td><td><code>number</code></td><td><code>0</code></td><td>node_modules下的最大依赖深度搜索并加载JavaScript文件。仅适用于使用<code>--allowJs</code>。</td></tr><tr><td><code>--module</code><br><code>-m</code></td><td><code>string</code></td><td><code>target === 'ES6' ? 'ES6' : 'commonjs'</code></td><td>指定生成哪个模块系统代码：'commonjs'，'amd'，'system'，或 'umd'或'es2015'。只有'amd'和'system'能和<code>--outFile</code>一起使用。当目标是ES5或以下的时候不能使用'es2015'。</td></tr><tr><td><code>--moduleResolution</code></td><td><code>string</code></td><td><code>module === 'amd' | 'system' | 'ES6' ? 'classic' : 'node'</code></td><td>决定如何处理模块。或者是'node'对于Node.js/io.js，或者是'classic'（默认）。查看<a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html\" rel=\"external nofollow\" target=\"_blank\">模块解析文档</a>了解详情。</td></tr><tr><td><code>--newLine</code></td><td><code>string</code></td><td><em>(platform specific)</em></td><td>当生成文件时指定行结束符：'CRLF'（dos）或 'LF' （unix）。</td></tr><tr><td><code>--noEmit</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不生成输出文件。</td></tr><tr><td><code>--noEmitHelpers</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不在输出文件中生成用户自定义的帮助函数代码，如<code>__extends</code>。</td></tr><tr><td><code>--noEmitOnError</code></td><td><code>boolean</code></td><td><code>false</code></td><td>报错时不生成输出文件。</td></tr><tr><td><code>--noFallthroughCasesInSwitch</code></td><td><code>boolean</code></td><td><code>false</code></td><td>报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿）</td></tr><tr><td><code>--noImplicitAny</code></td><td><code>boolean</code></td><td><code>false</code></td><td>在表达式和声明上有隐含的'any'类型时报错。</td></tr><tr><td><code>--noImplicitReturns</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不是函数的所有返回路径都有返回值时报错。</td></tr><tr><td><code>--noImplicitThis</code></td><td><code>boolean</code></td><td><code>false</code></td><td>当<code>this</code>表达式的值为<code>any</code>类型的时候，生成一个错误。</td></tr><tr><td><code>--noImplicitUseStrict</code></td><td><code>boolean</code></td><td><code>false</code></td><td>模块输出中不包含'use strict'指令。</td></tr><tr><td><code>--noLib</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不包含默认的库文件（lib.d.ts）。</td></tr><tr><td><code>--noResolve</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不把<code>/// &lt;reference``&gt;</code>或模块导入的文件加到编译文件列表。</td></tr><tr><td><code>--noUnusedLocals</code></td><td><code>boolean</code></td><td><code>false</code></td><td>若有未使用的局部变量则抛错。</td></tr><tr><td><code>--noUnusedParameters</code></td><td><code>boolean</code></td><td><code>false</code></td><td>若有未使用的参数则抛错。</td></tr><tr><td><del><code>--out</code></del></td><td><code>string</code></td><td> </td><td>弃用。使用 <code>--outFile</code> 代替。</td></tr><tr><td><code>--outDir</code></td><td><code>string</code></td><td> </td><td>重定向输出目录。</td></tr><tr><td><code>--outFile</code></td><td><code>string</code></td><td> </td><td>将输出文件合并为一个文件。合并的顺序是根据传入编译器的文件顺序和<code>///&lt;reference``&gt;</code>和<code>import</code>的文件顺序决定的。查看输出文件顺序文件了解详情。</td></tr><tr><td><code>paths</code><span>[2]</span></td><td><code>Object</code></td><td> </td><td>模块名到基于<code>baseUrl</code>的路径映射的列表。查看<a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html#path-mapping\" rel=\"external nofollow\" target=\"_blank\">模块解析文档</a>了解详情。</td></tr><tr><td><code>--preserveConstEnums</code></td><td><code>boolean</code></td><td><code>false</code></td><td>保留<code>const</code>和<code>enum</code>声明。查看<a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#94-constant-enum-declarations\" rel=\"external nofollow\" target=\"_blank\">const enums documentation</a>了解详情。</td></tr><tr><td><code>--pretty</code><span>[1]</span></td><td><code>boolean</code></td><td><code>false</code></td><td>给错误和消息设置样式，使用颜色和上下文。</td></tr><tr><td><code>--project</code><br><code>-p</code></td><td><code>string</code></td><td> </td><td>编译指定目录下的项目。这个目录应该包含一个<code>tsconfig.json</code>文件来管理编译。查看<a href=\"http://www.tslang.cn/docs/handbook/tsconfig-json.html\" rel=\"external nofollow\" target=\"_blank\">tsconfig.json</a>文档了解更多信息。</td></tr><tr><td><code>--reactNamespace</code></td><td><code>string</code></td><td><code>\"React\"</code></td><td>当目标为生成'react' JSX时，指定<code>createElement</code>和<code>__spread</code>的调用对象</td></tr><tr><td><code>--removeComments</code></td><td><code>boolean</code></td><td><code>false</code></td><td>删除所有注释，除了以<code>/!*</code>开头的版权信息。</td></tr><tr><td><code>--rootDir</code></td><td><code>string</code></td><td><em>(common root directory is computed from the list of input files)</em></td><td>仅用来控制输出的目录结构<code>--outDir</code>。</td></tr><tr><td><code>rootDirs</code><span>[2]</span></td><td><code>string[]</code></td><td> </td><td><em>根（root）</em>文件夹列表，联给了代表运行时表示工程结构的内容。查看<a href=\"http://www.tslang.cn/docs/handbook/module-resolution.html#virtual-directories-with-rootdirs\" rel=\"external nofollow\" target=\"_blank\">模块解析文档</a>了解详情。</td></tr><tr><td><code>--skipLibCheck</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不检查默认库文件（<code>lib.d.ts</code>）的正确性。</td></tr><tr><td><code>--skipDefaultLibCheck</code></td><td><code>boolean</code></td><td><code>false</code></td><td>不检查用户定义的库文件（<code>*.d.ts</code>）的正确性。</td></tr><tr><td><code>--sourceMap</code></td><td><code>boolean</code></td><td><code>false</code></td><td>生成相应的'.map'文件。</td></tr><tr><td><code>--sourceRoot</code></td><td><code>string</code></td><td> </td><td>指定TypeScript源文件的路径，以便调试器定位。当TypeScript文件的位置是在运行时指定时使用此标记。路径信息会被加到<code>sourceMap</code>里。</td></tr><tr><td><code>--strictNullChecks</code></td><td><code>boolean</code></td><td><code>false</code></td><td>在严格的<code>null</code>检查模式下，<code>null</code>和<code>undefined</code>值不包含在任何类型里，只允许用它们自己和<code>any</code>来赋值（有个例外，<code>undefined</code>可以赋值到<code>void</code>）。</td></tr><tr><td><code>--stripInternal</code><span>[1]</span></td><td><code>boolean</code></td><td><code>false</code></td><td>不对具有<code>/** @internal */</code> JSDoc注解的代码生成代码。</td></tr><tr><td><code>--suppressExcessPropertyErrors</code><span>[1]</span></td><td><code>boolean</code></td><td><code>false</code></td><td>阻止对对象字面量的额外属性检查。</td></tr><tr><td><code>--suppressImplicitAnyIndexErrors</code></td><td><code>boolean</code></td><td><code>false</code></td><td>阻止<code>--noImplicitAny</code>对缺少索引签名的索引对象报错。查看<a href=\"https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362\" rel=\"external nofollow\" target=\"_blank\">issue #1232</a>了解详情。</td></tr><tr><td><code>--target</code><br><code>-t</code></td><td><code>string</code></td><td><code>\"ES5\"</code></td><td>指定ECMAScript目标版本'ES3' (默认)，'ES5'，或'ES6'<span>[1]</span></td></tr><tr><td><code>--traceResolution</code></td><td><code>boolean</code></td><td><code>false</code></td><td>生成模块解析日志信息</td></tr><tr><td><code>--types</code></td><td><code>string[]</code></td><td> </td><td>要包含的类型声明文件名列表。</td></tr><tr><td><code>--typeRoots</code></td><td><code>string[]</code></td><td> </td><td>要包含的类型声明文件路径列表。</td></tr><tr><td><code>--version</code><br><code>-v</code></td><td> </td><td> </td><td>打印编译器版本号。</td></tr><tr><td><code>--watch</code><br><code>-w</code></td><td> </td><td> </td><td>在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。</td></tr></tbody></table><ul><li><span>[1]</span> 这些选项是试验性的。</li><li><span>[2]</span> 这些选项只能在<code>tsconfig.json</code>里使用，不能在命令行使用。</li></ul><h2>相关信息</h2><ul><li>在<a href=\"/typescript/typescript-tsconfig-json.html\" target=\"_blank\">tsconfig.json</a>文件里设置编译器选项。</li><li>在<a href=\"/typescript/typescript-msbuild.html\" target=\"_blank\">MSBuild工程</a>里设置编译器选项。</li></ul></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 1,
      "parent_sort_index": 7,
      "chapter_level_one_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 项目配置",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "f4edecd318204657594a4920b85421c5",
      "chapter_level_two_parent_id": "bcc4d025382149d891556ee1e73eac06",
      "chapter_level_two_name": "TypeScript tsconfig.json",
      "chapter_level_two_url": "/typescript/typescript-tsconfig-json.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>tsconfig.json</h1><h2>概述</h2><p>如果一个目录下存在一个<code>tsconfig.json</code>文件，那么它意味着这个目录是TypeScript项目的根目录。<code>tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：</p><h2>使用tsconfig.json</h2><ul><li>不带任何输入文件的情况下调用<code>tsc</code>，编译器会从当前目录开始去查找<code>tsconfig.json</code>文件，逐级向上搜索父目录。</li><li>不带任何输入文件的情况下调用<code>tsc</code>，且使用命令行参数<code>--project</code>（或<code>-p</code>）指定一个包含<code>tsconfig.json</code>文件的目录。</li></ul><p>当命令行上指定了输入文件时，<code>tsconfig.json</code>文件会被忽略。</p><h2>示例</h2><p><code>tsconfig.json</code>示例文件:</p><ul><li>使用<code>\"files\"</code>属性</li></ul><pre><code>{\n    <span>\"compilerOptions\"</span>: {\n        <span>\"module\"</span>: <span>\"commonjs\"</span>,\n        <span>\"noImplicitAny\"</span>: <span>true</span>,\n        <span>\"removeComments\"</span>: <span>true</span>,\n        <span>\"preserveConstEnums\"</span>: <span>true</span>,\n        <span>\"outFile\"</span>: <span>\"../../built/local/tsc.js\"</span>,\n        <span>\"sourceMap\"</span>: <span>true</span>\n    },\n    <span>\"files\"</span>: [\n        <span>\"core.ts\"</span>,\n        <span>\"sys.ts\"</span>,\n        <span>\"types.ts\"</span>,\n        <span>\"scanner.ts\"</span>,\n        <span>\"parser.ts\"</span>,\n        <span>\"utilities.ts\"</span>,\n        <span>\"binder.ts\"</span>,\n        <span>\"checker.ts\"</span>,\n        <span>\"emitter.ts\"</span>,\n        <span>\"program.ts\"</span>,\n        <span>\"commandLineParser.ts\"</span>,\n        <span>\"tsc.ts\"</span>,\n        <span>\"diagnosticInformationMap.generated.ts\"</span>\n    ]\n}\n</code></pre><ul><li><p>使用<code>\"include\"</code>和<code>\"exclude\"</code>属性</p><pre><code>{\n    <span>\"compilerOptions\"</span>: {\n        <span>\"module\"</span>: <span>\"commonjs\"</span>,\n        <span>\"noImplicitAny\"</span>: <span>true</span>,\n        <span>\"removeComments\"</span>: <span>true</span>,\n        <span>\"preserveConstEnums\"</span>: <span>true</span>,\n        <span>\"outFile\"</span>: <span>\"../../built/local/tsc.js\"</span>,\n        <span>\"sourceMap\"</span>: <span>true</span>\n    },\n    <span>\"include\"</span>: [\n        <span>\"src/**/*\"</span>\n    ],\n    <span>\"exclude\"</span>: [\n        <span>\"node_modules\"</span>,\n        <span>\"**/*.spec.ts\"</span>\n    ]\n}\n</code></pre></li></ul><h2>细节</h2><p><code>\"compilerOptions\"</code>可以被忽略，这时编译器会使用默认值。在这里查看完整的[编译器选项](./Compiler Options.md)列表。</p><p><code>\"files\"</code>指定一个包含相对或绝对文件路径的列表。 <code>\"include\"</code>和<code>\"exclude\"</code>属性指定一个文件glob匹配模式列表。 支持的glob通配符有：</p><ul><li><code>*</code> 匹配0或多个字符（不包括目录分隔符）</li><li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li><li><code>**/</code> 递归匹配任意子目录</li></ul><p>如果一个glob模式里的某部分只包含<code>*</code>或<code>.*</code>，那么仅有支持的文件扩展名类型被包含在内（比如默认<code>.ts</code>，<code>.tsx</code>，和<code>.d.ts</code>， 如果<code>allowJs</code>设置能<code>true</code>还包含<code>.js</code>和<code>.jsx</code>）。</p><p>如果<code>\"files\"</code>和<code>\"include\"</code>都没有被指定，编译器默认包含当前目录和子目录下所有的TypeScript文件（<code>.ts</code>,<code>.d.ts</code> 和 <code>.tsx</code>），排除在<code>\"exclude\"</code>里指定的文件。JS文件（<code>.js</code>和<code>.jsx</code>）也被包含进来如果<code>allowJs</code>被设置成<code>true</code>。 如果指定了 <code>\"files\"</code>或<code>\"include\"</code>，编译器会将它们结合一并包含进来。 使用 <code>\"outDir\"</code>指定的目录下的文件永远会被编译器排除，除非你明确地使用<code>\"files\"</code>将其包含进来（这时就算用<code>exclude</code>指定也没用）。</p><p>使用<code>\"include\"</code>引入的文件可以使用<code>\"exclude\"</code>属性过滤。 然而，通过 <code>\"files\"</code>属性明确指定的文件却总是会被包含在内，不管<code>\"exclude\"</code>如何设置。 如果没有特殊指定， <code>\"exclude\"</code>默认情况下会排除<code>node_modules</code>，<code>bower_components</code>，和<code>jspm_packages</code>目录。</p><p>任何被<code>\"files\"或</code>\"include\"<code>指定的文件所引用的文件也会被包含进来。</code>A.ts<code>引用了</code>B.ts<code>，因此</code>B.ts<code>不能被排除，除非引用它的</code>A.ts<code>在</code>\"exclude\"`列表中。</p><p><code>tsconfig.json</code>文件可以是个空文件，那么所有默认的文件（如上面所述）都会以默认配置选项编译。</p><p>在命令行上指定的编译选项会覆盖在<code>tsconfig.json</code>文件里的相应选项。</p><h2><code>compileOnSave</code></h2><p>在最顶层设置<code>compileOnSave</code>标记，可以让IDE在保存文件的时候根据<code>tsconfig.json</code>重新生成文件。</p><pre><code>{\n    <span>\"compileOnSave\"</span>: <span>true</span>,\n    <span>\"compilerOptions\"</span>: {\n        <span>\"noImplicitAny\"</span> : <span>true</span>\n    }\n}\n</code></pre><p>要想支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装<a href=\"https://github.com/TypeStrong/atom-typescript/blob/master/docs/tsconfig.md#compileonsave\" rel=\"external nofollow\" target=\"_blank\">atom-typescript</a>插件。</p><h2>模式</h2><p>到这里查看模式: <a href=\"http://json.schemastore.org/tsconfig\" rel=\"external nofollow\" target=\"_blank\">http://json.schemastore.org/tsconfig</a>.</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 8,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "1e2bc250683278d4b142502cadc2dd3e",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件使用",
      "chapter_level_two_url": "/typescript/typescript-df-consumption.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript声明文件使用</h1><p>在TypeScript 2.0，获取、使用和查找声明文件变得十分容易。 这篇文章将详细说明怎么做这三件事。</p><h1>下载</h1><p>在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。</p><p>比如，获取lodash库的声明文件，只需使用下面的命令：</p><pre><code>npm install --save @types/lodash\n</code></pre><h1>使用</h1><p>下载完后，就可以直接在TypeScript里使用lodash了。 不论是在模块里还是全局代码里使用。</p><p>比如，你已经<code>npm install</code>安装了类型声明，你可以使用导入：</p><pre><code><span>import</span> * as _ from <span>\"lodash\"</span>;\n_.padStart(<span>\"Hello TypeScript!\"</span>, <span>20</span>, <span>\" \"</span>);\n</code></pre><p>或者如果你没有使用模块，那么你只需使用全局的变量<code>_</code>。</p><pre><code>_.padStart(<span>\"Hello TypeScript!\"</span>, <span>20</span>, <span>\" \"</span>);\n</code></pre><h1>查找</h1><p>大多数情况下，类型声明包的名字总是与它们在<code>npm</code>上的包的名字相同，但是有<code>@types/</code>前缀， 但如果你需要的话，你可以在 <a href=\"https://aka.ms/types\" rel=\"external nofollow\" target=\"_blank\">https://aka.ms/types</a>这里查找你喜欢的库。</p><blockquote><p>注意：如果你要找的声明文件不存在，你可以贡献一份，这样就方便了下一位要使用它的人。 查看DefinitelyTyped <a href=\"http://definitelytyped.org/guides/contributing.html\" rel=\"external nofollow\" target=\"_blank\">贡献指南页</a>了解详情。</p></blockquote></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 7,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "6c8eb1f69987f88ef18924915eb5093c",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件发布",
      "chapter_level_two_url": "/typescript/typescript-df-publishing.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript声明文件发布</h1><p>现在我们已经按照指南里的步骤写好一个声明文件，是时候把它发布到npm了。 有两种主要方式用来发布声明文件到npm：</p><ol><li>与你的npm包捆绑在一起，或</li><li>发布到npm上的<a href=\"https://www.npmjs.com/~types\" rel=\"external nofollow\" target=\"_blank\">@types organization</a>。</li></ol><p>如果你能控制要使用你发布的声明文件的那个npm包的话，推荐第一种方式。 这样的话，你的声明文件与JavaScript总是在一起传递。</p><h1>包含声明文件到你的npm包</h1><p>如果你的包有一个主<code>.js</code>文件，你还是需要在<code>package.json</code>里指定主声明文件。 设置 <code>types</code>属性指向捆绑在一起的声明文件。 比如：</p><pre><code>{\n    <span>\"name\"</span>: <span>\"awesome\"</span>,\n    <span>\"author\"</span>: <span>\"Vandelay Industries\"</span>,\n    <span>\"version\"</span>: <span>\"1.0.0\"</span>,\n    <span>\"main\"</span>: <span>\"./lib/main.js\"</span>,\n    <span>\"types\"</span>: <span>\"./lib/main.d.ts\"</span>\n}\n</code></pre><p>注意<code>\"typings\"</code>与<code>\"types\"</code>具有相同的意义，也可以使用它。</p><p>同样要注意的是如果主声明文件名是<code>index.d.ts</code>并且位置在包的根目录里（与<code>index.js</code>并列），你就不需要使用<code>\"types\"</code>属性指定了。</p><h2>依赖</h2><p>所有的依赖是由npm管理的。 确保所依赖的声明包都在 <code>package.json</code>的<code>\"dependencies\"</code>里指明了 比如，假设我们写了一个包它依赖于Browserify和TypeScript。</p><pre><code>{\n    <span>\"name\"</span>: <span>\"browserify-typescript-extension\"</span>,\n    <span>\"author\"</span>: <span>\"Vandelay Industries\"</span>,\n    <span>\"version\"</span>: <span>\"1.0.0\"</span>,\n    <span>\"main\"</span>: <span>\"./lib/main.js\"</span>,\n    <span>\"types\"</span>: <span>\"./lib/main.d.ts\"</span>,\n    <span>\"dependencies\"</span>: [\n        <span>\"browserify@latest\"</span>,\n        <span>\"@types/browserify@latest\"</span>,\n        <span>\"typescript@next\"</span>\n    ]\n}\n</code></pre><p>这里，我们的包依赖于<code>browserify</code>和<code>typescript</code>包。 <code>browserify</code>没有把它的声明文件捆绑在它的npm包里，所以我们需要依赖于<code>@types/browserify</code>得到它的声明文件。 <code>typescript</code>相反，它把声明文件放在了npm包里，因此我们不需要依赖额外的包。</p><p>我们的包要从这两个包里暴露出声明文件，因此<code>browserify-typescript-extension</code>的用户也需要这些依赖。 正因此，我们使用 <code>\"dependencies\"</code>而不是<code>\"devDependencies\"</code>，否则用户将需要手动安装那些包。 如果我们只是在写一个命令行应用，并且我们的包不会被当做一个库使用的话，那么我就可以使用<code>devDependencies</code>。</p><h2>危险信号</h2><h3><code>/// &lt;reference path=\"...\" /&gt;</code></h3><p><em>不要</em>在声明文件里使用<code>/// &lt;reference path=\"...\" /&gt;</code>。</p><pre><code><span>/// &lt;reference path=\"../typescript/lib/typescriptServices.d.ts\" /&gt;</span>\n....\n</code></pre><p><em>应该</em>使用<code>/// &lt;reference types=\"...\" /&gt;</code>代替</p><pre><code><span>/// &lt;reference types=\"typescript\" /&gt;</span>\n....\n</code></pre><p>务必阅读[使用依赖](./Library Structures.md#consuming-dependencies)一节了解详情。</p><h3>打包所依赖的声明</h3><p>如果你的类型声明依赖于另一个包：</p><ul><li><em>不要</em>把依赖的包放进你的包里，保持它们在各自的文件里。</li><li><em>不要</em>将声明拷贝到你的包里。</li><li><em>应该</em>依赖于npm类型声明包，如果依赖包没包含它自己的声明的话。</li></ul><h2>公布你的声明文件</h2><p>在发布声明文件包之后，确保在<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types-2.0/notNeededPackages.json\" rel=\"external nofollow\" target=\"_blank\">DefinitelyTyped外部包列表</a>里面添加一条引用。 这可以让查找工具知道你的包提供了自己的声明文件。</p><h1>发布到<a href=\"https://www.npmjs.com/~types\" rel=\"external nofollow\" target=\"_blank\">@types</a></h1><p><a href=\"https://www.npmjs.com/~types\" rel=\"external nofollow\" target=\"_blank\">@types</a>下面的包是从<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\" rel=\"external nofollow\" target=\"_blank\">DefinitelyTyped</a>里自动发布的，通过 <a href=\"https://github.com/Microsoft/types-publisher\" rel=\"external nofollow\" target=\"_blank\">types-publisher工具</a>。 如果想让你的包发布为@types包，提交一个pull request到<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\" rel=\"external nofollow\" target=\"_blank\">https://github.com/DefinitelyTyped/DefinitelyTyped</a>。 在这里查看详细信息<a href=\"http://definitelytyped.org/guides/contributing.html\" rel=\"external nofollow\" target=\"_blank\">contribution guidelines page</a>。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 6,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "dc43cb756e521051eeb0cfdb70120a71",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件模板",
      "chapter_level_two_url": "/typescript/typescript-df-templates.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2>TypeScript 声明文件模板</h2><p></p><ul><li><span style=\"line-height: 1.7;\">global-modifying-module.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">global-plugin.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">global.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">module-class.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">module-function.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">module-plugin.d.ts</span><br></li><li><span style=\"line-height: 1.7;\">module.d.ts</span><br></li></ul><p></p><div><div><div><h1>global-modifying-module.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */</span>\n\n<span>/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */</span>\n<span>declare</span> global {\n    <span>/*~ Here, declare things that go in the global namespace, or augment\n     *~ existing declarations in the global namespace\n     */</span>\n    <span>interface</span> String {\n        fancyFormat(opts: StringFormatOptions): <span>string</span>;\n    }\n}\n\n<span>/*~ If your module exports types or values, write them as usual */</span>\n<span>export</span> <span>interface</span> StringFormatOptions {\n    fancinessLevel: <span>number</span>;\n}\n\n<span>/*~ For example, declaring a method on the module (in addition to its global side effects) */</span>\n<span>export</span> <span><span>function</span> <span>doSomething</span>(<span></span>): <span>void</span></span>;\n\n<span>/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */</span>\n<span>export</span> { };\n</code></pre></div></div></div><div><div><div><div></div></div></div></div><h1>global-plugin.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This template shows how to write a global plugin. */</span>\n\n<span>/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with to overloads to\n *~ the built-in number type.\n */</span>\n<span>interface</span> Number {\n    toBinaryString(opts?: MyLibrary.BinaryFormatOptions): <span>string</span>;\n    toBinaryString(callback: MyLibrary.BinaryFormatCallback, opts?: MyLibrary.BinaryFormatOptions): <span>string</span>;\n}\n\n<span>/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */</span>\n<span>declare</span> <span>namespace</span> MyLibrary {\n    <span>type</span> BinaryFormatCallback = (n: <span>number</span>) =&gt; <span>string</span>;\n    <span>interface</span> BinaryFormatOptions {\n        prefix?: <span>string</span>;\n        padding: <span>number</span>;\n    }\n}</code></pre><h1>global.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */</span>\n<span>declare</span> <span><span>function</span> <span>myLib</span>(<span>a: <span>string</span></span>): <span>string</span></span>;\n<span>declare</span> <span><span>function</span> <span>myLib</span>(<span>a: <span>number</span></span>): <span>number</span></span>;\n\n<span>/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */</span>\n<span>interface</span> myLib {\n    name: <span>string</span>;\n    length: <span>number</span>;\n    extras?: <span>string</span>[];\n}\n\n<span>/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */</span>\n<span>declare</span> <span>namespace</span> myLib {\n    <span>//~ We can write 'myLib.timeout = 50;'</span>\n    <span>let</span> timeout: <span>number</span>;\n\n    <span>//~ We can access 'myLib.version', but not change it</span>\n    <span>const</span> version: <span>string</span>;\n\n    <span>//~ There's some class we can create via 'let c = new myLib.Cat(42)'</span>\n    <span>//~ Or reference e.g. 'function f(c: myLib.Cat) { ... }</span>\n    <span>class</span> Cat {\n        <span>constructor</span>(n: number);\n\n        //~ We can read 'c.age' from a 'Cat' instance\n        readonly age: number;\n\n        //~ We can invoke 'c.purr()' from a 'Cat' instance\n        purr(): void;\n    }\n\n    //~ We can declare a variable as\n    //~   'var s: myLib.CatSettings = { weight: <span>5</span>, name: <span>\"Maru\"</span> };<span>'\n    interface CatSettings {\n        weight: number;\n        name: string;\n        tailLength?: number;\n    }\n\n    //~ We can write '</span><span>const</span> v: myLib.VetID = <span>42</span>;<span>'\n    //~  or '</span><span>const</span> v: myLib.VetID = <span>\"bob\"</span>;<span>'\n    type VetID = string | number;\n\n    //~ We can invoke '</span>myLib.checkCat(c)<span>' or '</span>myLib.checkCat(c, v);<span>'\n    function checkCat(c: Cat, s?: VetID);\n}</span></code></pre><h1>module-class.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */</span>\n\n<span>/*~ Note that ES6 modules cannot directly export class objects.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */</span>\n\n<span>/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */</span>\n<span>export</span> as <span>namespace</span> myClassLib;\n\n<span>/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */</span>\n<span>export</span> = MyClass;\n\n<span>/*~ Write your module's methods and properties in this class */</span>\n<span>declare</span> <span>class</span> MyClass {\n    <span>constructor</span>(someParam?: string);\n\n    someProperty: string[];\n\n    myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n */\ndeclare namespace MyClass {\n    <span>export</span> <span>interface</span> MyClassMethodOptions {\n        width?: <span>number</span>;\n        height?: <span>number</span>;\n    }\n}</code></pre><h1>module-function.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */</span>\n\n<span>/*~ Note that ES6 modules cannot directly export callable functions.\n *~ This file should be imported using the CommonJS-style:\n *~   import x = require('someLibrary');\n *~\n *~ Refer to the documentation to understand common\n *~ workarounds for this limitation of ES6 modules.\n */</span>\n\n<span>/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */</span>\n<span>export</span> as <span>namespace</span> myFuncLib;\n\n<span>/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */</span>\n<span>export</span> = MyFunction;\n\n<span>/*~ This example shows how to have multiple overloads for your function */</span>\n<span>declare</span> <span><span>function</span> <span>MyFunction</span>(<span>name: <span>string</span></span>): <span>MyFunction</span>.<span>NamedReturnType</span></span>;\n<span>declare</span> <span><span>function</span> <span>MyFunction</span>(<span>length: <span>number</span></span>): <span>MyFunction</span>.<span>LengthReturnType</span></span>;\n\n<span>/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n */</span>\n<span>declare</span> <span>namespace</span> MyFunction {\n    <span>export</span> <span>interface</span> LengthReturnType {\n        width: <span>number</span>;\n        height: <span>number</span>;\n    }\n    <span>export</span> <span>interface</span> NamedReturnType {\n        firstName: <span>string</span>;\n        lastName: <span>string</span>;\n    }\n\n    <span>/*~ If the module also has properties, declare them here. For example,\n     *~ this declaration says that this code is legal:\n     *~   import f = require('myFuncLibrary');\n     *~   console.log(f.defaultName);\n     */</span>\n    <span>export</span> <span>const</span> defaultName: <span>string</span>;\n    <span>export</span> <span>let</span> defaultLength: <span>number</span>;\n}</code></pre><h1>module-plugin.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This is the module plugin template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */</span>\n\n<span>/*~ On this line, import the module which this module adds to */</span>\n<span>import</span> * as m from <span>'someModule'</span>;\n\n<span>/*~ You can also import other modules if needed */</span>\n<span>import</span> * as other from <span>'anotherModule'</span>;\n\n<span>/*~ Here, declare the same module as the one you imported above */</span>\n<span>declare</span> <span>module</span> 'someModule' {\n    <span>/*~ Inside, add new function, classes, or variables. You can use\n     *~ unexported types from the original module if needed. */</span>\n    <span>export</span> <span><span>function</span> <span>theNewMethod</span>(<span>x: m.foo</span>): <span>other</span>.<span>bar</span></span>;\n\n    <span>/*~ You can also add new properties to existing interfaces from\n     *~ the original module by writing interface augmentations */</span>\n    <span>export</span> <span>interface</span> SomeModuleOptions {\n        someModuleSetting?: <span>string</span>;\n    }\n\n    <span>/*~ New types can also be declared and will appear as if they\n     *~ are in the original module */</span>\n    <span>export</span> <span>interface</span> MyModulePluginOptions {\n        size: <span>number</span>;\n    }\n}</code></pre><h1>module.d.ts</h1><p></p><pre><code><span>// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]</span>\n<span>// Project: [~THE PROJECT NAME~]</span>\n<span>// Definitions by: [~YOUR NAME~] &lt;[~A URL FOR YOU~]&gt;</span>\n\n<span>/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */</span>\n\n<span>/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */</span>\n<span>export</span> as <span>namespace</span> myLib;\n\n<span>/*~ If this module has methods, declare them as functions like so.\n */</span>\n<span>export</span> <span><span>function</span> <span>myMethod</span>(<span>a: <span>string</span></span>): <span>string</span></span>;\n<span>export</span> <span><span>function</span> <span>myOtherMethod</span>(<span>a: <span>number</span></span>): <span>number</span></span>;\n\n<span>/*~ You can declare types that are available via importing the module */</span>\n<span>export</span> <span>interface</span> someType {\n    name: <span>string</span>;\n    length: <span>number</span>;\n    extras?: <span>string</span>[];\n}\n\n<span>/*~ You can declare properties of the module using const, let, or var */</span>\n<span>export</span> <span>const</span> myField: <span>number</span>;\n\n<span>/*~ If there are types, properties, or methods inside dotted names\n *~ of the module, declare them inside a 'namespace'.\n */</span>\n<span>export</span> <span>namespace</span> subProp {\n    <span>/*~ For example, given this definition, someone could write:\n     *~   import { subProp } from 'yourModule';\n     *~   subProp.foo();\n     *~ or\n     *~   import * as yourMod from 'yourModule';\n     *~   yourMod.subProp.foo();\n     */</span>\n    <span>export</span> <span><span>function</span> <span>foo</span>(<span></span>): <span>void</span></span>;\n}</code></pre><br></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 5,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "b0e6f6e9fa7080073b2b872cf9bc08fe",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件原理",
      "chapter_level_two_url": "/typescript/typescript-df-deepdive.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript声明文件原理</h1><h1>声明文件原理：深入探究</h1><p>组织模块以提供你想要的API形式保持一致是比较难的。 比如，你可能想要这样一个模块，可以用或不用 <code>new</code>来创建不同的类型， 在不同层级上暴露出不同的命名类型， 且模块对象上还带有一些属性。</p><p>阅读这篇指定后，你就会了解如果书写复杂的暴露出友好API的声明文件。 这篇指定针对于模块（UMD）库，因为它们的选择具有更高的可变性。</p><h2>核心概念</h2><p>如果你理解了一些关于TypeScript是如何工作的核心概念， 那么你就能够为任何结构书写声明文件。</p><h3>类型</h3><p>如果你正在阅读这篇指南，你可能已经大概了解TypeScript里的类型指是什么。 明确一下， <em>类型</em>通过以下方式引入：</p><ul><li>类型别名声明（<code>type sn = number | string;</code>）</li><li>接口声明（<code>interface I { x: number[]; }</code>）</li><li>类声明（<code>class C { }</code>）</li><li>枚举声明（<code>enum E { A, B, C }</code>）</li><li>指向某个类型的<code>import</code>声明</li></ul><p>以上每种声明形式都会创建一个新的类型名称。</p><h3>值</h3><p>与类型相比，你可能已经理解了什么是值。 值是运行时名字，可以在表达式里引用。 比如 <code>let x = 5;</code>创建一个名为<code>x</code>的值。</p><p>同样，以下方式能够创建值：</p><ul><li><code>let</code>，<code>const</code>，和<code>var</code>声明</li><li>包含值的<code>namespace</code>或<code>module</code>声明</li><li><code>enum</code>声明</li><li><code>class</code>声明</li><li>指向值的<code>import</code>声明</li><li><code>function</code>声明</li></ul><h3>命名空间</h3><p>类型可以存在于<em>命名空间</em>里。 比如，有这样的声明 <code>let x: A.B.C</code>， 我们就认为 <code>C</code>类型来自<code>A.B</code>命名空间。</p><p>这个区别虽细微但很重要 -- 这里，<code>A.B</code>不是必需的类型或值。</p><h2>简单的组合：一个名字，多种意义</h2><p>一个给定的名字<code>A</code>，我们可以找出三种不同的意义：一个类型，一个值或一个命名空间。 要如何去解析这个名字要看它所在的上下文是怎样的。 比如，在声明 <code>let m: A.A = A;</code>， <code>A</code>首先被当做命名空间，然后做为类型名，最后是值。 这些意义最终可能会指向完全不同的声明！</p><p>这看上去另人迷惑，但是只要我们不过度的重载这还是很方便的。 下面让我们来看看一些有用的组合行为。</p><h3>内置组合</h3><p>眼尖的读者可能会注意到，比如，<code>class</code>同时出现在<em>类型</em>和<em>值</em>列表里。 <code>class C { }</code>声明创建了两个东西： <em>类型</em><code>C</code>指向类的实例结构， <em>值</em><code>C</code>指向类构造函数。 枚举声明拥有相似的行为。</p><h3>用户组合</h3><p>假设我们写了模块文件<code>foo.d.ts</code>:</p><pre><code><span>export</span> <span>var</span> SomeVar: { a: SomeType };\n<span>export</span> <span>interface</span> SomeType {\n  count: <span>number</span>;\n}\n</code></pre><p>这样使用它：</p><pre><code><span>import</span> * as foo from <span>'./foo'</span>;\n<span>let</span> x: foo.SomeType = foo.SomeVar.a;\n<span>console</span>.log(x.count);\n</code></pre><p>这可以很好地工作，但是我们知道<code>SomeType</code>和<code>SomeVar</code>很相关 因此我们想让他们有相同的名字。 我们可以使用组合通过相同的名字 <code>Bar</code>表示这两种不同的对象（值和对象）：</p><pre><code><span>export</span> <span>var</span> Bar: { a: Bar };\n<span>export</span> <span>interface</span> Bar {\n  count: <span>number</span>;\n}\n</code></pre><p>这提供了解构使用的机会：</p><pre><code><span>import</span> { Bar } from <span>'./foo'</span>;\n<span>let</span> x: Bar = Bar.a;\n<span>console</span>.log(x.count);\n</code></pre><p>再次地，这里我们使用<code>Bar</code>做为类型和值。 注意我们没有声明 <code>Bar</code>值为<code>Bar</code>类型 -- 它们是独立的。</p><h2>高级组合</h2><p>有一些声明能够通过多个声明组合。 比如， <code>class C { }</code>和<code>interface C { }</code>可以同时存在并且都可以做为<code>C</code>类型的属性。</p><p>只要不产生冲突就是合法的。 一个普通的规则是值总是会和同名的其它值产生冲突除非它们在不同命名空间里， 类型冲突则发生在使用类型别名声明的情况下（ <code>type s = string</code>）， 命名空间永远不会发生冲突。</p><p>让我们看看如何使用。</p><h3>利用<code>interface</code>添加</h3><p>我们可以使用一个<code>interface</code>往别一个<code>interface</code>声明里添加额外成员：</p><pre><code><span>interface</span> Foo {\n  x: <span>number</span>;\n}\n<span>// ... elsewhere ...</span>\n<span>interface</span> Foo {\n  y: <span>number</span>;\n}\n<span>let</span> a: Foo = ...;\n<span>console</span>.log(a.x + a.y); <span>// OK</span>\n</code></pre><p>这同样作用于类：</p><pre><code><span>class</span> Foo {\n  x: <span>number</span>;\n}\n<span>// ... elsewhere ...</span>\n<span>interface</span> Foo {\n  y: <span>number</span>;\n}\n<span>let</span> a: Foo = ...;\n<span>console</span>.log(a.x + a.y); <span>// OK</span>\n</code></pre><p>注意我们不能使用接口往类型别名里添加成员（<code>type s = string;</code>）</p><h3>使用<code>namespace</code>添加</h3><p><code>namespace</code>声明可以用来添加新类型，值和命名空间，只要不出现冲突。</p><p>比如，我们可能添加静态成员到一个类：</p><pre><code><span>class</span> C {\n}\n<span>// ... elsewhere ...</span>\n<span>namespace</span> C {\n  <span>export</span> <span>let</span> x: <span>number</span>;\n}\n<span>let</span> y = C.x; <span>// OK</span>\n</code></pre><p>注意在这个例子里，我们添加一个值到<code>C</code>的<em>静态</em>部分（它的构造函数）。 这里因为我们添加了一个 <em>值</em>，且其它值的容器是另一个值 （类型包含于命名空间，命名空间包含于另外的命名空间）。</p><p>我们还可以给类添加一个命名空间类型：</p><pre><code><span>class</span> C {\n}\n<span>// ... elsewhere ...</span>\n<span>namespace</span> C {\n  <span>export</span> <span>interface</span> D { }\n}\n<span>let</span> y: C.D; <span>// OK</span>\n</code></pre><p>在这个例子里，直到我们写了<code>namespace</code>声明才有了命名空间<code>C</code>。 做为命名空间的 <code>C</code>不会与类创建的值<code>C</code>或类型<code>C</code>相互冲突。</p><p>最后，我们可以进行不同的合并通过<code>namespace</code>声明。 Finally, we could perform many different merges using<code>namespace</code> declarations. This isn't a particularly realistic example, but shows all sorts of interesting behavior:</p><pre><code><span>namespace</span> X {\n  <span>export</span> <span>interface</span> Y { }\n  <span>export</span> <span>class</span> Z { }\n}\n\n<span>// ... elsewhere ...</span>\n<span>namespace</span> X {\n  <span>export</span> <span>var</span> Y: <span>number</span>;\n  <span>export</span> <span>namespace</span> Z {\n    <span>export</span> <span>class</span> C { }\n  }\n}\n<span>type</span> X = <span>string</span>;\n</code></pre><p>在这个例子里，第一个代码块创建了以下名字与含义：</p><ul><li>一个值<code>X</code>（因为<code>namespace</code>声明包含一个值，<code>Z</code>）</li><li>一个命名空间<code>X</code>（因为<code>namespace</code>声明包含一个值，<code>Z</code>）</li><li>在命名空间<code>X</code>里的类型<code>Y</code></li><li>在命名空间<code>X</code>里的类型<code>Z</code>（类的实例结构）</li><li>值<code>X</code>的一个属性值<code>Z</code>（类的构造函数）</li></ul><p>第二个代码块创建了以下名字与含义：</p><ul><li>值<code>Y</code>（<code>number</code>类型），它是值<code>X</code>的一个属性</li><li>一个命名空间<code>Z</code></li><li>值<code>Z</code>，它是值<code>X</code>的一个属性</li><li>在<code>X.Z</code>命名空间下的类型<code>C</code></li><li>值<code>X.Z</code>的一个属性值<code>C</code></li><li>类型<code>X</code></li></ul><h2>使用<code>export =</code>或<code>import</code></h2><p>一个重要的原则是<code>export</code>和<code>import</code>声明会导出或导入目标的<em>所有含义</em>。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 4,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "92f443b0e9ed9dcb1e75e72b02e7bf7b",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件规范",
      "chapter_level_two_url": "/typescript/typescript-df-standard.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript声明文件规范</h1><h1>普通类型</h1><h2><code>Number</code>，<code>String</code>，<code>Boolean</code>和<code>Object</code></h2><p><em>不要</em>使用如下类型<code>Number</code>，<code>String</code>，<code>Boolean</code>或<code>Object</code>。 这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。</p><pre><code><span>/* 错误 */</span>\n<span><span>function</span> <span>reverse</span>(<span>s: <span>String</span></span>): <span>String</span></span>;\n</code></pre><p><em>应该</em>使用类型<code>number</code>，<code>string</code>，and <code>boolean</code>。</p><pre><code><span>/* OK */</span>\n<span><span>function</span> <span>reverse</span>(<span>s: <span>string</span></span>): <span>string</span></span>;\n</code></pre><p>如果你就要使用<code>Object</code>类型，考虑使用<code>any</code>代替。 目前在TypeScript里无法指定一个对象“不是一个原始值”。</p><h2>泛型</h2><p><em>不要</em>定义一个从来没使用过其类型参数的泛型类型。 了解详情 <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---\" rel=\"external nofollow\" target=\"_blank\">TypeScript FAQ page</a>。</p><h1>回调函数类型</h1><h2>回调函数返回值类型</h2><p><em>不要</em>为返回值被忽略的回调函数设置一个<code>any</code>类型的返回值类型：</p><pre><code><span>/* 错误 */</span>\n<span><span>function</span> <span>fn</span>(<span>x: (</span>) =&gt; <span>any</span>) </span>{\n    x();\n}\n</code></pre><p><em>应该</em>给返回值被忽略的回调函数设置<code>void</code>类型的返回值类型：</p><pre><code><span>/* OK */</span>\n<span><span>function</span> <span>fn</span>(<span>x: (</span>) =&gt; <span>void</span>) </span>{\n    x();\n}\n</code></pre><p><em>为什么</em>：使用<code>void</code>相对安全，因为它防止了你不小心使用<code>x</code>的返回值：</p><pre><code><span><span>function</span> <span>fn</span>(<span>x: (</span>) =&gt; <span>void</span>) </span>{\n    <span>var</span> k = x(); <span>// oops! meant to do something else</span>\n    k.doSomething(); <span>// error, but would be OK if the return type had been 'any'</span>\n}\n</code></pre><h2>回调函数里的可选参数</h2><p><em>不要</em>在回调函数里使用可选参数除非你真的要这么做：</p><pre><code><span>/* 错误 */</span>\n<span>interface</span> Fetcher {\n    getObject(done: (data: <span>any</span>, elapsedTime?: <span>number</span>) =&gt; <span>void</span>): <span>void</span>;\n}\n</code></pre><p>这里有一种特殊的意义：<code>done</code>回调函数可能以1个参数或2个参数调用。 代码大概的意思是说这个回调函数不在乎是否有 <code>elapsedTime</code>参数， 但是不需要把这个参数当成可选参数来达到此目的 -- 因为总是允许提供一个接收较少参数的回调函数。</p><p><em>应该</em>写出回调函数的非可选参数：</p><pre><code><span>/* OK */</span>\n<span>interface</span> Fetcher {\n    getObject(done: (data: <span>any</span>, elapsedTime: <span>number</span>) =&gt; <span>void</span>): <span>void</span>;\n}\n</code></pre><h2>重载与回调函数</h2><p><em>不要</em>因为回调函数参数个数不同而写不同的重载：</p><pre><code><span>/* 错误 */</span>\n<span>declare</span> <span><span>function</span> <span>beforeAll</span>(<span>action: (</span>) =&gt; <span>void</span>, <span>timeout</span>?: <span>number</span>): <span>void</span></span>;\n<span>declare</span> <span><span>function</span> <span>beforeAll</span>(<span>action: (done: DoneFn</span>) =&gt; <span>void</span>, <span>timeout</span>?: <span>number</span>): <span>void</span></span>;\n</code></pre><p><em>应该</em>只使用最大参数个数写一个重载：</p><pre><code><span>/* OK */</span>\n<span>declare</span> <span><span>function</span> <span>beforeAll</span>(<span>action: (done: DoneFn</span>) =&gt; <span>void</span>, <span>timeout</span>?: <span>number</span>): <span>void</span></span>;\n</code></pre><p><em>为什么</em>：回调函数总是可以忽略某个参数的，因此没必要为参数少的情况写重载。 参数少的回调函数首先允许错误类型的函数被传入，因为它们匹配第一个重载。</p><h1>函数重载</h1><h2>顺序</h2><p><em>不要</em>把一般的重载放在精确的重载前面：</p><pre><code><span>/* 错误 */</span>\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: <span>any</span></span>): <span>any</span></span>;\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: HTMLElement</span>): <span>number</span></span>;\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: HTMLDivElement</span>): <span>string</span></span>;\n\n<span>var</span> myElem: HTMLDivElement;\n<span>var</span> x = fn(myElem); <span>// x: any, wat?</span>\n</code></pre><p><em>应该</em>排序重载令精确的排在一般的之前：</p><pre><code><span>/* OK */</span>\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: HTMLDivElement</span>): <span>string</span></span>;\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: HTMLElement</span>): <span>number</span></span>;\n<span>declare</span> <span><span>function</span> <span>fn</span>(<span>x: <span>any</span></span>): <span>any</span></span>;\n\n<span>var</span> myElem: HTMLDivElement;\n<span>var</span> x = fn(myElem); <span>// x: string, :)</span>\n</code></pre><p><em>为什么</em>：TypeScript会选择<em>第一个匹配到的重载</em>当解析函数调用的时候。 当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。</p><h2>使用可选参数</h2><p><em>不要</em>为仅在末尾参数不同时写不同的重载：</p><pre><code><span>/* 错误 */</span>\n<span>interface</span> Example {\n    diff(one: <span>string</span>): <span>number</span>;\n    diff(one: <span>string</span>, two: <span>string</span>): <span>number</span>;\n    diff(one: <span>string</span>, two: <span>string</span>, three: <span>boolean</span>): <span>number</span>;\n}\n</code></pre><p><em>应该</em>尽可能使用可选参数：</p><pre><code><span>/* OK */</span>\n<span>interface</span> Example {\n    diff(one: <span>string</span>, two?: <span>string</span>, three?: <span>boolean</span>): <span>number</span>;\n}\n</code></pre><p>注意这在所有重载都有相同类型的返回值时会不好用。</p><p><em>为什么</em>：有两种生要的原因。</p><p>TypeScript解析签名兼容性时会查看是否某个目标签名能够使用源的参数调用， <em>且允许外来参数</em>。 下面的代码暴露出一个bug，当签名被正确的使用可选参数书写时：</p><pre><code><span><span>function</span> <span>fn</span>(<span>x: (a: <span>string</span>, b: <span>number</span>, c: <span>number</span></span>) =&gt; <span>void</span>) </span>{ }\n<span>var</span> x: Example;\n<span>// When written with overloads, OK -- used first overload</span>\n<span>// When written with optionals, correctly an error</span>\nfn(x.diff);\n</code></pre><p>第二个原因是当使用了TypeScript“严格检查null”特性时。 因为没有指定的参数在JavaScript里表示为<code>undefined</code>，通常显示地为可选参数传入一个<code>undefined</code>。 这段代码在严格null模式下可以工作：</p><pre><code><span>var</span> x: Example;\n<span>// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'</span>\n<span>// When written with optionals, correctly OK</span>\nx.diff(<span>\"something\"</span>, <span>true</span> ? <span>undefined</span> : <span>\"hour\"</span>);\n</code></pre><h2>使用联合类型</h2><p><em>不要</em>为仅在某个位置上的参数类型不同的情况下定义重载：</p><pre><code><span>/* WRONG */</span>\n<span>interface</span> Moment {\n    utcOffset(): <span>number</span>;\n    utcOffset(b: <span>number</span>): Moment;\n    utcOffset(b: <span>string</span>): Moment;\n}\n</code></pre><p><em>应该</em>尽可能使用类型类型：</p><pre><code><span>/* OK */</span>\n<span>interface</span> Moment {\n    utcOffset(): <span>number</span>;\n    utcOffset(b: <span>number</span>|<span>string</span>): Moment;\n}\n</code></pre><p>注意我们没有让<code>b</code>成为可选的，因为签名的返回值类型不同。</p><p><em>为什么</em>：This is important for people who are \"passing through\" a value to your function:</p><pre><code><span><span>function</span> <span>fn</span>(<span>x: <span>string</span></span>): <span>void</span></span>;\n<span><span>function</span> <span>fn</span>(<span>x: <span>number</span></span>): <span>void</span></span>;\n<span><span>function</span> <span>fn</span>(<span>x: <span>number</span>|<span>string</span></span>) </span>{\n    <span>// When written with separate overloads, incorrectly an error</span>\n    <span>// When written with union types, correctly OK</span>\n    <span>return</span> moment().utcOffset(x);\n}</code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 3,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "d67d9dc495c3d484be4b2f1f66de8caf",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件举例",
      "chapter_level_two_url": "/typescript/typescript-df-examples.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript声明文件举例</h1><h1>简介</h1><p>这篇指南的目的是教你如何书写高质量的TypeScript声明文件。 我们在这里会展示一些API的文档，还有它们的使用示例， 并且阐述了如何为它们书写声明文件。</p><p>这些例子是按复杂度递增的顺序组织的。</p><ul>    <li>        <a href=\"#global-variables\">全局变量</a>    </li>    <li>        <a href=\"#global-functions\">全局函数</a>    </li>    <li>        <a href=\"#objects-with-properties\">带属性的对象</a>    </li>    <li>        <a href=\"#overloaded-functions\">函数重载</a>    </li>    <li>        <a href=\"#reusable-types-interfaces\">可重用类型（接口）</a>    </li>    <li>        <a href=\"#reusable-types-type-aliases\">可重用类型（类型别名）</a>    </li>    <li>        <a href=\"#organizing-types\">组织类型</a>    </li>    <li>        <a href=\"#classes\">类</a>    </li></ul><h1>例子</h1><h2><a name=\"global-variables\"></a>全局变量</h2><p><em>文档</em></p><blockquote><p>全局变量<code>foo</code>包含了存在组件总数。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\"><span><span class=\"hljs-built_in\">console</span></span>.log(<span><span class=\"hljs-string\">\"Half the number of widgets is \"</span></span> + (foo / <span><span class=\"hljs-number\">2</span></span>));\n</code></pre><p><em>声明</em></p><p>使用<code>declare var</code>声明变量。 如果变量是只读的，那么可以使用 <code>declare const</code>。 你还可以使用 <code>declare let</code>如果变量拥有块级作用域。</p><pre><code class=\"hljs sql\"><span><span class=\"hljs-comment\">/** 组件总数 */</span></span>\n<span><span class=\"hljs-keyword\">declare</span></span> <span><span class=\"hljs-keyword\">var</span></span> foo: <span><span class=\"hljs-built_in\">number</span></span>;\n</code></pre><h2><a name=\"global-functions\"></a>全局函数</h2><p><em>文档</em></p><blockquote><p>用一个字符串参数调用<code>greet</code>函数向用户显示一条欢迎信息。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\">greet(<span><span class=\"hljs-string\">\"hello, world\"</span></span>);\n</code></pre><p><em>声明</em></p><p>使用<code>declare function</code>声明函数。</p><pre><code class=\"hljs sql\"><span><span class=\"hljs-keyword\">declare</span></span> <span><span><span class=\"hljs-keyword\">function</span></span> <span>greet</span>(<span>greeting: <span><span class=\"hljs-keyword\">string</span></span></span>): <span><span class=\"hljs-built_in\">void</span></span></span>;\n</code></pre><h2><a name=\"objects-with-properties\"></a>带属性的对象</h2><p><em>文档</em></p><blockquote><p>全局变量<code>myLib</code>包含一个<code>makeGreeting</code>函数， 还有一个属性 <code>numberOfGreetings</code>指示目前为止欢迎数量。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\"><span><span class=\"hljs-keyword\">let</span></span> result = myLib.makeGreeting(<span><span class=\"hljs-string\">\"hello, world\"</span></span>);\n<span><span class=\"hljs-built_in\">console</span></span>.log(<span><span class=\"hljs-string\">\"The computed greeting is:\"</span></span> + result);\n\n<span><span class=\"hljs-keyword\">let</span></span> count = myLib.numberOfGreetings;\n</code></pre><p><em>声明</em></p><p>使用<code>declare namespace</code>描述用点表示法访问的类型或值。</p><pre><code class=\"hljs cs\"><span>declare</span> <span><span class=\"hljs-keyword\">namespace</span></span> <span class=\"hljs-title\">myLib</span> {\n    <span><span><span class=\"hljs-function\">function</span></span><span class=\"hljs-function\"> </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">makeGreeting</span></span></span><span class=\"hljs-function\">(</span><span><span class=\"hljs-function\"><span class=\"hljs-params\">s: </span></span><span><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-keyword\">string</span></span></span></span></span><span class=\"hljs-function\">): </span><span><span class=\"hljs-function\"><span class=\"hljs-keyword\">string</span></span></span></span>;\n    <span><span class=\"hljs-keyword\">let</span></span> numberOfGreetings: <span>number</span>;\n}\n</code></pre><h2><a name=\"overloaded-functions\"></a>函数重载</h2><p><em>文档</em></p><blockquote><p><code>getWidget</code>函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\"><span><span class=\"hljs-keyword\">let</span></span> x: Widget = getWidget(<span><span class=\"hljs-number\">43</span></span>);\n\n<span><span class=\"hljs-keyword\">let</span></span> arr: Widget[] = getWidget(<span><span class=\"hljs-string\">\"all of them\"</span></span>);\n</code></pre><p><em>声明</em></p><pre><code class=\"hljs sql\"><span><span class=\"hljs-keyword\">declare</span></span> <span><span><span class=\"hljs-keyword\">function</span></span> <span>getWidget</span>(<span>n: <span><span class=\"hljs-built_in\">number</span></span></span>): <span>Widget</span></span>;\n<span><span class=\"hljs-keyword\">declare</span></span> <span><span><span class=\"hljs-keyword\">function</span></span> <span>getWidget</span>(<span>s: <span><span class=\"hljs-keyword\">string</span></span></span>): <span>Widget</span>[]</span>;\n</code></pre><h2><a name=\"reusable-types-interfaces\"></a>可重用类型（接口）</h2><p><em>文档</em></p><blockquote><p>当指定一个欢迎词时，你必须传入一个<code>GreetingSettings</code>对象。 这个对象具有以下几个属性：</p><ul><li>greeting：必需的字符串</li><li>duration: 可靠的时长（毫秒表示）</li><li>color: 可选字符串，比如‘#ff00ff’</li></ul></blockquote><p><em>代码</em></p><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">greet</span>({\n  <span class=\"hljs-attribute\">greeting</span>: <span><span class=\"hljs-string\">\"hello world\"</span></span>,\n  duration: <span><span class=\"hljs-number\">4000</span></span>\n});\n</code></pre><p><em>声明</em></p><p>使用<code>interface</code>定义一个带有属性的类型。</p><pre><code class=\"hljs php\"><span><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span></span></span><span class=\"hljs-class\"> <span class=\"hljs-title\">GreetingSettings</span> </span>{\n  greeting: <span>string</span>;\n  duration?: <span>number</span>;\n  color?: <span>string</span>;\n}\n\n<span><span class=\"hljs-keyword\">declare</span></span> <span><span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">greet</span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">(</span></span><span><span class=\"hljs-function\"><span class=\"hljs-params\">setting: GreetingSettings</span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">)</span>: </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">void</span></span></span></span>;\n</code></pre><h2><a name=\"reusable-types-type-aliases\"></a>可重用类型（类型别名）</h2><p><em>文档</em></p><blockquote><p>在任何需要欢迎词的地方，你可以提供一个<code>string</code>，一个返回<code>string</code>的函数或一个<code>Greeter</code>实例。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\"><span><span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">getGreeting</span></span></span><span class=\"hljs-function\">(</span><span></span><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span></span>{\n    <span><span class=\"hljs-keyword\">return</span></span> <span><span class=\"hljs-string\">\"howdy\"</span></span>;\n}\n<span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> <span class=\"hljs-title\">MyGreeter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Greeter</span> </span>{ }\n\ngreet(<span><span class=\"hljs-string\">\"hello\"</span></span>);\ngreet(getGreeting);\ngreet(<span><span class=\"hljs-keyword\">new</span></span> MyGreeter());\n</code></pre><p><em>声明</em></p><p>你可以使用类型别名来定义类型的短名：</p><pre><code class=\"hljs php\"><span>type</span> GreetingLike = <span>string</span> | (() =&gt; <span>string</span>) | Greeting;\n\n<span><span class=\"hljs-keyword\">declare</span></span> <span><span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span></span><span class=\"hljs-function\"> </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">greet</span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">(</span></span><span><span class=\"hljs-function\"><span class=\"hljs-params\">g: GreetingLike</span></span></span><span class=\"hljs-function\"><span class=\"hljs-params\">)</span>: </span><span><span class=\"hljs-function\"><span class=\"hljs-title\">void</span></span></span></span>;\n</code></pre><h2><a name=\"organizing-types\"></a>组织类型</h2><p><em>文档</em></p><blockquote><p><code>greeter</code>对象能够记录到文件或显示一个警告。 你可以为 <code>.log(...)</code>提供LogOptions和为<code>.alert(...)</code>提供选项。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs cpp\"><span><span class=\"hljs-keyword\">const</span></span> g = <span><span class=\"hljs-keyword\">new</span></span> Greeter(<span><span class=\"hljs-string\">\"Hello\"</span></span>);\ng.<span class=\"hljs-built_in\">log</span>({ verbose: <span><span class=\"hljs-literal\">true</span></span> });\ng.alert({ modal: <span><span class=\"hljs-literal\">false</span></span>, title: <span><span class=\"hljs-string\">\"Current Greeting\"</span></span> });\n</code></pre><p><em>声明</em></p><p>使用命名空间组织类型。</p><pre><code class=\"hljs cs\"><span>declare</span> <span><span class=\"hljs-keyword\">namespace</span></span> <span class=\"hljs-title\">GreetingLib</span> {\n    <span><span class=\"hljs-keyword\">interface</span></span> <span class=\"hljs-title\">LogOptions</span> {\n        verbose?: <span>boolean</span>;\n    }\n    <span><span class=\"hljs-keyword\">interface</span></span> <span class=\"hljs-title\">AlertOptions</span> {\n        modal: <span>boolean</span>;\n        title?: <span><span class=\"hljs-keyword\">string</span></span>;\n        color?: <span><span class=\"hljs-keyword\">string</span></span>;\n    }\n}\n</code></pre><p>你也可以在一个声明中创建嵌套的命名空间：</p><pre><code class=\"hljs cs\"><span>declare</span> <span><span class=\"hljs-keyword\">namespace</span></span> <span class=\"hljs-title\">GreetingLib.Options</span> {\n    <span><span class=\"hljs-comment\">// Refer to via GreetingLib.Options.Log</span></span>\n    <span><span class=\"hljs-keyword\">interface</span></span> <span class=\"hljs-title\">Log</span> {\n        verbose?: <span>boolean</span>;\n    }\n    <span><span class=\"hljs-keyword\">interface</span></span> <span class=\"hljs-title\">Alert</span> {\n        modal: <span>boolean</span>;\n        title?: <span><span class=\"hljs-keyword\">string</span></span>;\n        color?: <span><span class=\"hljs-keyword\">string</span></span>;\n    }\n}\n</code></pre><h2><a name=\"classes\"></a>类</h2><p><em>文档</em></p><blockquote><p>你可以通过实例化<code>Greeter</code>对象来创建欢迎词，或者继承<code>Greeter</code>对象来自定义欢迎词。</p></blockquote><p><em>代码</em></p><pre><code class=\"hljs javascript\"><span><span class=\"hljs-keyword\">const</span></span> myGreeter = <span><span class=\"hljs-keyword\">new</span></span> Greeter(<span><span class=\"hljs-string\">\"hello, world\"</span></span>);\nmyGreeter.greeting = <span><span class=\"hljs-string\">\"howdy\"</span></span>;\nmyGreeter.showGreeting();\n\n<span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span></span><span class=\"hljs-class\"> <span class=\"hljs-title\">SpecialGreeter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Greeter</span> </span>{\n    <span><span class=\"hljs-keyword\">constructor</span></span>() {\n        <span><span class=\"hljs-keyword\">super</span></span>(<span><span class=\"hljs-string\">\"Very special greetings\"</span></span>);\n    }\n}\n</code></pre><p><em>声明</em></p><p>使用<code>declare class</code>描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。</p><pre><code class=\"hljs cs\"><span>declare</span> <span><span class=\"hljs-keyword\">class</span></span> <span class=\"hljs-title\">Greeter</span> {\n    <span>constructor</span>(greeting: <span class=\"hljs-keyword\">string</span>);\n\n    greeting: <span class=\"hljs-keyword\">string</span>;\n    showGreeting(): <span class=\"hljs-keyword\">void</span>;\n}</code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 2,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "68a41aff718888f130f0b45d0ab8de7d",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件结构",
      "chapter_level_two_url": "/typescript/typescript-df-library-structures.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript 声明文件结构</h1><h1>概述</h1><p>一般来讲，你<em>组织</em>声明文件的方式取决于库是如何被使用的。 在JavaScript里提供了很多库的使用方法，这就需要你书写声明文件去匹配它们。 这篇指南涵盖了如何识别常见库的模式，与怎么样书写符合相应模式的声明文件。</p><p>针对每种主要的库的组织模式，在<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates.html\" rel=\"external nofollow\" target=\"_blank\">模版</a>一节都有对应的文件。 你可以利用它们帮助你快速上手。</p><h1>识别库的类型</h1><p>首先，我们先看一下TypeScript声明文件能够表示的库的类型。 这里会简单展示每种类型的库的使用方式，如何去书写，还有一些真实案例。</p><p>识别库的类型是书写声明文件的第一步。 我们将会给出一些提示，关于怎样通过库的 <em>使用方法</em>及其<em>源码</em>来识别库的类型。 根据库的文档及组织结构不同，这两种方式可能一个会比另外的那个简单一些。 我们推荐你使用任意你喜欢的方式。</p><h2>全局库</h2><p><em>全局</em>库是指能在全局命名空间下访问的（例如：不需要使用任何形式的<code>import</code>）。 许多库都是简单的暴露出一个或多个全局变量。 比如，如果你使用过 <a href=\"https://jquery.com/\" rel=\"external nofollow\" target=\"_blank\">jQuery</a>，<code>$</code>变量可以被够简单的引用：</p><pre><code>$(() =&gt; { <span>console</span>.log(<span>'hello!'</span>); } );\n</code></pre><p>你经常会在全局库的指南文档上看到如何在HTML里用脚本标签引用库：</p><pre><code><span>&lt;<span>script</span> <span>src</span>=<span>\"http://a.great.cdn.for/someLib.js\"</span>&gt;</span><span></span><span>&lt;/<span>script</span>&gt;</span>\n</code></pre><p>目前，大多数流行的全局访问型库实际上都以UMD库的形式进行书写（见后文）。 UMD库的文档很难与全局库文档两者之间难以区分。 在书写全局声明文件前，一定要确认一下库是否真的不是UMD。</p><h3>从代码上识别全局库</h3><p>全局库的代码通常都十分简单。 一个全局的“Hello, world”库可能是这样的：</p><pre><code><span><span>function</span> <span>createGreeting</span>(<span>s</span>) </span>{\n    <span>return</span> <span>\"Hello, \"</span> + s;\n}\n</code></pre><p>或这样：</p><pre><code><span>window</span>.createGreeting = <span><span>function</span>(<span>s</span>) </span>{\n    <span>return</span> <span>\"Hello, \"</span> + s;\n}\n</code></pre><p>当你查看全局库的源代码时，你通常会看到：</p><ul><li>顶级的<code>var</code>语句或<code>function</code>声明</li><li>一个或多个赋值语句到<code>window.someName</code></li><li>假设DOM原始值像<code>document</code>或<code>window</code>是存在的</li></ul><p>你<em>不会</em>看到：</p><ul><li>检查是否使用或如何使用模块加载器，比如<code>require</code>或<code>define</code></li><li>CommonJS/Node.js风格的导入如<code>var fs = require(\"fs\");</code></li><li><code>define(...)</code>调用</li><li>文档里说明了如果<code>require</code>或导入这个库</li></ul><h3>全局库的例子</h3><p>由于把一个全局库转变成UMD库是非常容易的，所以很少流行的库还再使用全局的风格。 然而，小型的且需要DOM（或 <em>没有</em>依赖）的库可能还是全局类型的。</p><h3>全局库模版</h3><p>模版文件<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/global-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>global.d.ts</code></a>定义了<code>myLib</code>库作为例子。 一定要阅读 <a href=\"http://www.tslang.cn/docs/handbook/declaration-files/library-structures.html#preventing-name-conflicts\" rel=\"external nofollow\" target=\"_blank\">\"防止命名冲突\"补充说明</a>。</p><h2>模块化库</h2><p>一些库只能工作在模块加载器的环境下。 比如，像 <code>express</code>只能在Node.js里工作所以必须使用CommonJS的<code>require</code>函数加载。</p><p>ECMAScript 2015（也就是ES2015，ECMAScript 6或ES6），CommonJS和RequireJS具有相似的<em>导入</em>一个<em>模块</em>的表示方法。 例如，对于JavaScript CommonJS （Node.js），有下面的代码</p><pre><code><span>var</span> fs = <span>require</span>(<span>\"fs\"</span>);\n</code></pre><p>对于TypeScript或ES6，<code>import</code>关键字也具有相同的作用：</p><pre><code><span>import</span> fs = <span>require</span>(<span>\"fs\"</span>);\n</code></pre><p>你通常会在模块化库的文档里看到如下说明：</p><pre><code><span>var</span> someLib = <span>require</span>(<span>'someLib'</span>);\n</code></pre><p>或</p><pre><code>define(..., [<span>'someLib'</span>], <span><span>function</span>(<span>someLib</span>) </span>{\n\n});\n</code></pre><p>与全局模块一样，你也可能会在UMD模块的文档里看到这些例子，因此要仔细查看源码和文档。</p><h3>从代码上识别模块化库</h3><p>模块库至少会包含下列具有代表性的条目之一：</p><ul><li>无条件的调用<code>require</code>或<code>define</code></li><li>像<code>import * as a from 'b';</code> or <code>export c;</code>这样的声明</li><li>赋值给<code>exports</code>或<code>module.exports</code></li></ul><p>它们极少包含：</p><ul><li>对<code>window</code>或<code>global</code>的赋值</li></ul><h3>模块化库的例子</h3><p>许多流行的Node.js库都是这种模块化的，例如<a href=\"http://expressjs.com/\" rel=\"external nofollow\" target=\"_blank\"><code>express</code></a>，<a href=\"http://gulpjs.com/\" rel=\"external nofollow\" target=\"_blank\"><code>gulp</code></a>和 <a href=\"https://github.com/request/request\" rel=\"external nofollow\" target=\"_blank\"><code>request</code></a>。</p><h2><em>UMD</em></h2><p><em>UMD</em>模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 许多流行的库，比如 <a href=\"http://momentjs.com/\" rel=\"external nofollow\" target=\"_blank\">Moment.js</a>，就是这样的形式。 比如，在Node.js或RequireJS里，你可以这样写：</p><pre><code><span>import</span> moment = <span>require</span>(<span>\"moment\"</span>);\n<span>console</span>.log(moment.format());\n</code></pre><p>然而在纯净的浏览器环境里你也可以这样写：</p><pre><code><span>console</span>.log(moment.format());\n</code></pre><h3>识别UMD库</h3><p><a href=\"https://github.com/umdjs/umd\" rel=\"external nofollow\" target=\"_blank\">UMD模块</a>会检查是否存在模块加载器环境。 这是非常形容观察到的模块，它们会像下面这样：</p><pre><code>(<span><span>function</span> (<span>root, factory</span>) </span>{\n    <span>if</span> (<span>typeof</span> define === <span>\"function\"</span> &amp;&amp; define.amd) {\n        define([<span>\"libName\"</span>], factory);\n    } <span>else</span> <span>if</span> (<span>typeof</span> <span>module</span> === <span>\"object\"</span> &amp;&amp; <span>module</span>.exports) {\n        <span>module</span>.exports = factory(<span>require</span>(<span>\"libName\"</span>));\n    } <span>else</span> {\n        root.returnExports = factory(root.libName);\n    }\n}(<span>this</span>, <span><span>function</span> (<span>b</span>) </span>{\n</code></pre><p>如果你在库的源码里看到了<code>typeof define</code>，<code>typeof window</code>，或<code>typeof module</code>这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。</p><p>UMD库的文档里经常会包含通过<code>require</code>“在Node.js里使用”例子， 和“在浏览器里使用”的例子，展示如何使用<code>&lt;script&gt;</code>标签去加载脚本。</p><h3>UMD库的例子</h3><p>大多数流行的库现在都能够被当成UMD包。 比如 <a href=\"https://jquery.com/\" rel=\"external nofollow\" target=\"_blank\">jQuery</a>,<a href=\"http://momentjs.com/\" rel=\"external nofollow\" target=\"_blank\">Moment.js</a>,<a href=\"https://lodash.com/\" rel=\"external nofollow\" target=\"_blank\">lodash</a>和许多其它的。</p><h3>模版</h3><p>针对模块有三种可用的模块， <a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module.d.ts</code></a>, <a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-class-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module-class.d.ts</code></a> and <a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-function-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module-function.d.ts</code></a>.</p><p>使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-function-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module-function.d.ts</code></a>，如果模块能够作为函数<em>调用</em>。</p><pre><code><span>var</span> x = <span>require</span>(<span>\"foo\"</span>);\n<span>// Note: calling 'x' as a function</span>\n<span>var</span> y = x(<span>42</span>);\n</code></pre><p>一定要阅读<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/library-structures.html#the-impact-of-es6-on-module-call-signatures\" rel=\"external nofollow\" target=\"_blank\">补充说明： “ES6模块调用签名的影响”</a></p><p>使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-class-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module-class.d.ts</code></a>如果模块能够使用<code>new</code>来<em>构造</em>：</p><pre><code><span>var</span> x = <span>require</span>(<span>\"bar\"</span>);\n<span>// Note: using 'new' operator on the imported variable</span>\n<span>var</span> y = <span>new</span> x(<span>\"hello\"</span>);\n</code></pre><p>相同的<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/library-structures.html#the-impact-of-es6-on-module-plugins\" rel=\"external nofollow\" target=\"_blank\">补充说明</a>作用于这些模块。</p><p>如果模块不能被调用或构造，使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module.d.ts</code></a>文件。</p><h2><em>模块插件</em>或<em>UMD插件</em></h2><p>一个<em>模块插件</em>可以改变一个模块的结构（UMD或模块）。 例如，在Moment.js里， <code>moment-range</code>添加了新的<code>range</code>方法到<code>monent</code>对象。</p><p>对于声明文件的目标，我们会写相同的代码不论被改变的模块是一个纯粹的模块还是UMD模块。</p><h3>模版</h3><p>使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/module-plugin-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>module-plugin.d.ts</code></a>模版。</p><h2><em>全局插件</em></h2><p>一个<em>全局插件</em>是全局代码，它们会改变全局对象的结构。 对于 <em>全局修改的模块</em>，在运行时存在冲突的可能。</p><p>比如，一些库往<code>Array.prototype</code>或<code>String.prototype</code>里添加新的方法。</p><h3>识别全局插件</h3><p>全局通常很容易地从它们的文档识别出来。</p><p>你会看到像下面这样的例子：</p><pre><code><span>var</span> x = <span>\"hello, world\"</span>;\n<span>// Creates new methods on built-in types</span>\n<span>console</span>.log(x.startsWithHello());\n\n<span>var</span> y = [<span>1</span>, <span>2</span>, <span>3</span>];\n<span>// Creates new methods on built-in types</span>\n<span>console</span>.log(y.reverseAndSort());\n</code></pre><h3>模版</h3><p>使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/global-plugin-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>global-plugin.d.ts</code></a>模版。</p><h2><em>全局修改的模块</em></h2><p>当一个<em>全局修改的模块</em>被导入的时候，它们会改变全局作用域里的值。 比如，存在一些库它们添加新的成员到<code>String.prototype</code>当导入它们的时候。 这种模式很危险，因为可能造成运行时的冲突， 但是我们仍然可以为它们书写声明文件。</p><h3>识别全局修改的模块</h3><p>全局修改的模块通常可以很容易地从它们的文档识别出来。 通常来讲，它们与全局插件相似，但是需要 <code>require</code>调用来激活它们的效果。</p><p>你可能会看到像下面这样的文档:</p><pre><code><span>// 'require' call that doesn't use its return value</span>\n<span>var</span> unused = <span>require</span>(<span>\"magic-string-time\"</span>);\n<span>/* or */</span>\n<span>require</span>(<span>\"magic-string-time\"</span>);\n\n<span>var</span> x = <span>\"hello, world\"</span>;\n<span>// Creates new methods on built-in types</span>\n<span>console</span>.log(x.startsWithHello());\n\n<span>var</span> y = [<span>1</span>, <span>2</span>, <span>3</span>];\n<span>// Creates new methods on built-in types</span>\n<span>console</span>.log(y.reverseAndSort());\n</code></pre><h3>模版</h3><p>使用<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html\" rel=\"external nofollow\" target=\"_blank\"><code>global-modifying-module.d.ts</code></a>模版。</p><h1><a name=\"consuming-dependencies\"></a>使用依赖</h1><p>可能会有以下几种依赖。</p><h2>依赖全局库</h2><p>如果你的库依赖于某个全局库，使用<code>/// &lt;reference types=\"...\" /&gt;</code>指令：</p><pre><code><span>/// &lt;reference types=\"someLib\" /&gt;</span>\n\n<span><span>function</span> <span>getThing</span>(<span></span>): <span>someLib</span>.<span>thing</span></span>;\n</code></pre><h2>依赖模块</h2><p>如果你的库依赖于模块，使用<code>import</code>语句：</p><pre><code><span>import</span> * as moment from <span>\"moment\"</span>;\n\n<span><span>function</span> <span>getThing</span>(<span></span>): <span>moment</span></span>;\n</code></pre><h2>依赖UMD库</h2><h3>从全局库</h3><p>如果你的全局库依赖于某个UMD模块，使用<code>/// &lt;reference types</code>指令：</p><pre><code><span>/// &lt;reference types=\"moment\" /&gt;</span>\n\n<span><span>function</span> <span>getThing</span>(<span></span>): <span>moment</span></span>;\n</code></pre><h3>从一个模块或UMD库</h3><p>如果你的模块或UMD库依赖于一个UMD库，使用<code>import</code>语句：</p><pre><code><span>import</span> * as someLib from <span>'someLib'</span>;\n</code></pre><p><em>不要</em>使用<code>/// &lt;reference</code>指令去声明UMD库的依赖！</p><h1>补充说明</h1><h2><a name=\"preventing-name-conflicts\"></a>防止命名冲突</h2><p>注意，在书写全局声明文件时，允许在全局作用域里定义很多类型。 我们十分不建义这样做，当一个工程里有许多声明文件时，它会导致无法处理的命名冲突。</p><p>一个简单的规则是使用库定义的全局变量名来声明命名空间类型。 比如，库定义了一个全局的值 <code>cats</code>，你可以这样写</p><pre><code><span>declare</span> <span>namespace</span> cats {\n    <span>interface</span> KittySettings { }\n}\n</code></pre><p><em>不要</em></p><pre><code><span>// at top-level</span>\n<span>interface</span> CatsKittySettings { }\n</code></pre><p>这样也保证了库在转换成UMD的时候没有任何的破坏式改变，对于声明文件用户来说。</p><h2><a name=\"the-impact-of-es6-on-module-plugins\"></a>ES6模块插件的影响</h2><p>一些插件添加或修改已存在的顶层模块的导出部分。 当然这在CommonJS和其它加载器里是允许的，ES模块被当作是不可改变的因此这种模式就不可行了。 因为TypeScript是能不预知加载器类型的，所以没没在编译时保证，但是开发者如果要转到ES6模块加载器上应该注意这一点。</p><h2><a name=\"the-impact-of-es6-on-module-call-signatures\"></a>ES6模块调用签名的影响</h2><p>很多流行库，比如Express，暴露出自己作为可以调用的函数。 比如，典型的Express使用方法如下：</p><pre><code><span>import</span> exp = <span>require</span>(<span>\"express\"</span>);\n<span>var</span> app = exp();\n</code></pre><p>在ES6模块加载器里，顶层的对象（这里以<code>exp</code>导入）只能具有属性； 顶层的模块对象 <em>永远不能</em>被调用。 十分常见的解决方法是定义一个 <code>default</code>导出到一个可调用的/可构造的对象； 一会模块加载器助手工具能够自己探测到这种情况并且使用 <code>default</code>导出来替换顶层对象。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 1,
      "parent_sort_index": 6,
      "chapter_level_one_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 声明文件",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "1033e056b01171dbad57f9e5faa45878",
      "chapter_level_two_parent_id": "509bab9760c7566e408b14edf614bc37",
      "chapter_level_two_name": "TypeScript 声明文件介绍",
      "chapter_level_two_url": "/typescript/typescript-df-introduction.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1>TypeScript 声明文件介绍</h1><p>这篇指南的目的是教你如何书写高质量的TypeScript声明文件。</p><p>在这篇指南里，我们假设你对TypeScript已经有了基本的了解。 如果没有，请先阅读 <a href=\"http://www.tslang.cn/docs/handbook/basic-types.html\" rel=\"external nofollow\" target=\"_blank\">TypeScript手册</a> 来了解一些基本知识，尤其是类型和命名空间部分。</p><h1>章节</h1><p>这篇指南被分成了以下章节。</p><h2>结构</h2><p><a href=\"http://www.tslang.cn/docs/handbook/declaration-files/library-structures.html\" rel=\"external nofollow\" target=\"_blank\">结构</a>一节将帮助你了解常见库的格式以及如何为每种格式书写正确的声明文件。 如果你在编辑一个已经存在的文件，那么你可能不需要阅读此章节。 如果你在书写新的声明文件，那么你必须阅读此章节以理解库的不同格式是如何影响声明文件的书写的。</p><h2>规范</h2><p>声明文件里有很多常见的错误是很容易避免的。<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/do-s-and-don-ts.html\" rel=\"external nofollow\" target=\"_blank\">规范</a>一节指出了常见的错误， 描述了如何发现它们， 与怎样去修复。 每个人都要阅读这个章节以了解如何避免常见错误。</p><h2>举例</h2><p>很多时候，我们只能通过一些示例来了解第三方库是如何工作的，同时我们需要为这样的库书写声明文件。<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/by-example.html\" rel=\"external nofollow\" target=\"_blank\">举例</a>一节展示了很多常见的API模式以及如何为它们书写声明文件。 这篇指南是针对TypeScript初学者的，他们可能还不了解TypeScript里的所有语言结构。</p><h2>深入</h2><p>对于那些对声明文件底层工作机制感兴趣的老手们，<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/deep-dive.html\" rel=\"external nofollow\" target=\"_blank\">深入</a>一节解释了很多高级书写声明文件的高级概念， 以及展示了如何利用这些概念来创建整洁和直观的声明文件。</p><h2>模版</h2><p>在<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/templates.html\" rel=\"external nofollow\" target=\"_blank\">模版</a>一节里，你能找到一些声明文件，它们可以帮助你快速开始 当你在书写一个新声明文件的时候。 参考<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/library-structures.html\" rel=\"external nofollow\" target=\"_blank\">结构</a>这篇文档来找到应该使用哪个模版文件。</p><h2>发布到npm</h2><p><a href=\"http://www.tslang.cn/docs/handbook/declaration-files/publishing.html\" rel=\"external nofollow\" target=\"_blank\">发布</a>一节讲解了如何发布声明文件为npm包，及如何管理包的依赖。</p><h2>查找与安装声明文件</h2><p>对于JavaScript库的使用者来讲，<a href=\"http://www.tslang.cn/docs/handbook/declaration-files/consumption.html\" rel=\"external nofollow\" target=\"_blank\">使用</a>一节提供了一些简单步骤来定位与安装相应的声明文件。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 21,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "77ad4fc81a0fb1d8ecc304b7d77f38c7",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 三斜线指令",
      "chapter_level_two_url": "/typescript/typescript-triple-slash-directives.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>三斜线指令</h1><p>三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。</p><p>三斜线指令<em>仅</em>可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。</p><h2><code>/// &lt;reference path=\"...\" /&gt;</code></h2><p><code>/// &lt;reference path=\"...\" /&gt;</code>指令是三斜线指令中最常见的一种。 它用于声明文件间的 <em>依赖</em>。</p><p>三斜线引用告诉编译器在编译过程中要引入的额外的文件。</p><p>当使用<code>--out</code>或<code>--outFile</code>时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。</p><h3>预处理输入文件</h3><p>编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。</p><p>这个过程会以一些<em>根文件</em>开始； 它们是在命令行中指定的文件或是在 <code>tsconfig.json</code>中的<code>\"files\"</code>列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。</p><p>一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。</p><h3>错误</h3><p>引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。</p><h3>使用 <code>--noResolve</code></h3><p>如果指定了<code>--noResolve</code>编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p><h2><code>/// &lt;reference no-default-lib=\"true\"/&gt;</code></h2><p>这个指令把一个文件标记成<em>默认库</em>。 你会在 <code>lib.d.ts</code>文件和它不同的变体的顶端看到这个注释。</p><p>这个指令告诉编译器在编译过程中<em>不要</em>包含这个默认库（比如，<code>lib.d.ts</code>）。 这与在命令行上使用 <code>--noLib</code>相似。</p><p>还要注意，当传递了<code>--skipDefaultLibCheck</code>时，编译器只会忽略检查带有<code>/// &lt;reference no-default-lib=\"true\"/&gt;</code>的文件。</p><h2><code>/// &lt;amd-module /&gt;</code></h2><p>默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如 <code>r.js</code>。</p><p><code>amd-module</code>指令允许给编译器传入一个可选的模块名：</p><h5>amdModule.ts</h5><pre><code><span>///&lt;amd-module name='NamedModule'/&gt;</span>\n<span>export</span> <span>class</span> C {\n}\n</code></pre><p>这会将<code>NamedModule</code>传入到AMD <code>define</code>函数里：</p><h5>amdModule.js</h5><pre><code>define(<span>\"NamedModule\"</span>, [<span>\"require\"</span>, <span>\"exports\"</span>], <span><span>function</span> (<span>require, exports</span>) </span>{\n    <span>var</span> C = (<span><span>function</span> (<span></span>) </span>{\n        <span><span>function</span> <span>C</span>(<span></span>) </span>{\n        }\n        <span>return</span> C;\n    })();\n    exports.C = C;\n});\n</code></pre><h2><code>/// &lt;amd-dependency /&gt;</code></h2><blockquote><p><strong>注意</strong>：这个指令被废弃了。使用<code>import \"moduleName\";</code>语句代替。</p></blockquote><p><code>/// &lt;amd-dependency path=\"x\" /&gt;</code>告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块<code>require</code>调用的一部分。</p><p><code>amd-dependency</code>指令也可以带一个可选的<code>name</code>属性；它允许我们为amd-dependency传入一个可选名字：</p><pre><code><span>/// &lt;amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/&gt;</span>\n<span>declare</span> <span>var</span> moduleA:MyType\nmoduleA.callStuff()\n</code></pre><p>生成的JavaScript代码：</p><pre><code>define([<span>\"require\"</span>, <span>\"exports\"</span>, <span>\"legacy/moduleA\"</span>], <span><span>function</span> (<span>require, exports, moduleA</span>) </span>{\n    moduleA.callStuff()\n});</code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 5,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "a4d86360fa71236d1771bf7a55a81cb8",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 函数",
      "chapter_level_two_url": "/typescript/typescript-functions4ovw1wz8.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>函数<span style=\"line-height: 1.7;\">介绍</span></h1><p>函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 <em>行为</em>的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p><h1>函数</h1><p>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列API函数还是只使用一次的函数。</p><p>通过下面的例子可以迅速回想起这两种JavaScript中的函数：</p><pre><code><span>// Named function</span>\n<span><span>function</span> <span>add</span>(<span>x, y</span>) </span>{\n    <span>return</span> x + y;\n}\n\n<span>// Anonymous function</span>\n<span>let</span> myAdd = <span><span>function</span>(<span>x, y</span>) </span>{ <span>return</span> x + y; };\n</code></pre><p>在JavaScript里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习JavaScript和TypeScript会很有帮助。</p><pre><code><span>let</span> z = <span>100</span>;\n\n<span><span>function</span> <span>addToZ</span>(<span>x, y</span>) </span>{\n    <span>return</span> x + y + z;\n}\n</code></pre><h1>函数类型</h1><h2>为函数定义类型</h2><p>让我们为上面那个函数添加类型：</p><pre><code><span><span>function</span> <span>add</span>(<span>x: <span>number</span>, y: <span>number</span></span>): <span>number</span> </span>{\n    <span>return</span> x + y;\n}\n\n<span>let</span> myAdd = <span><span>function</span>(<span>x: <span>number</span>, y: <span>number</span></span>): <span>number</span> </span>{ <span>return</span> x+y; };\n</code></pre><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p><h2>书写完整函数类型</h2><p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p><pre><code><span>let</span> myAdd: (x:<span>number</span>, y:<span>number</span>)=&gt;<span>number</span> =\n    <span><span>function</span>(<span>x: <span>number</span>, y: <span>number</span></span>): <span>number</span> </span>{ <span>return</span> x+y; };\n</code></pre><p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：</p><pre><code><span>let</span> myAdd: (baseValue:<span>number</span>, increment:<span>number</span>) =&gt; <span>number</span> =\n    <span><span>function</span>(<span>x: <span>number</span>, y: <span>number</span></span>): <span>number</span> </span>{ <span>return</span> x + y; };\n</code></pre><p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p><p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( <code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code>而不能留空。</p><p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。</p><h2>推断类型</h2><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：</p><pre><code><span>// myAdd has the full function type</span>\n<span>let</span> myAdd = <span><span>function</span>(<span>x: <span>number</span>, y: <span>number</span></span>): <span>number</span> </span>{ <span>return</span> x + y; };\n\n<span>// The parameters `x` and `y` have the type number</span>\n<span>let</span> myAdd: (baseValue:<span>number</span>, increment:<span>number</span>) =&gt; <span>number</span> =\n    <span><span>function</span>(<span>x, y</span>) </span>{ <span>return</span> x + y; };\n</code></pre><p>这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。</p><h1>可选参数和默认参数</h1><p>TypeScript里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code>或<code>undefined</code>作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, lastName: <span>string</span></span>) </span>{\n    <span>return</span> firstName + <span>\" \"</span> + lastName;\n}\n\n<span>let</span> result1 = buildName(<span>\"Bob\"</span>);                  <span>// error, too few parameters</span>\n<span>let</span> result2 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>, <span>\"Sr.\"</span>);  <span>// error, too many parameters</span>\n<span>let</span> result3 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>);         <span>// ah, just right</span>\n</code></pre><p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用 <code>?</code>实现可选参数的功能。 比如，我们想让last name是可选的：</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, lastName?: <span>string</span></span>) </span>{\n    <span>if</span> (lastName)\n        <span>return</span> firstName + <span>\" \"</span> + lastName;\n    <span>else</span>\n        <span>return</span> firstName;\n}\n\n<span>let</span> result1 = buildName(<span>\"Bob\"</span>);  <span>// works correctly now</span>\n<span>let</span> result2 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>, <span>\"Sr.\"</span>);  <span>// error, too many parameters</span>\n<span>let</span> result3 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>);  <span>// ah, just right</span>\n</code></pre><p>可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。</p><p>在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是<code>undefined</code>时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为<code>\"Smith\"</code>。</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, lastName = \"Smith\"</span>) </span>{\n    <span>return</span> firstName + <span>\" \"</span> + lastName;\n}\n\n<span>let</span> result1 = buildName(<span>\"Bob\"</span>);                  <span>// works correctly now, returns \"Bob Smith\"</span>\n<span>let</span> result2 = buildName(<span>\"Bob\"</span>, <span>undefined</span>);       <span>// still works, also returns \"Bob Smith\"</span>\n<span>let</span> result3 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>, <span>\"Sr.\"</span>);  <span>// error, too many parameters</span>\n<span>let</span> result4 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>);         <span>// ah, just right</span>\n</code></pre><p>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, lastName?: <span>string</span></span>) </span>{\n    <span>// ...</span>\n}\n</code></pre><p>和</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, lastName = \"Smith\"</span>) </span>{\n    <span>// ...</span>\n}\n</code></pre><p>共享同样的类型<code>(firstName: string, lastName?: string) =&gt; string</code>。 默认参数的默认值消失了，只保留了它是一个可选参数的信息。</p><p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code>值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code>是带默认值的参数：</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName = \"Will\", lastName: <span>string</span></span>) </span>{\n    <span>return</span> firstName + <span>\" \"</span> + lastName;\n}\n\n<span>let</span> result1 = buildName(<span>\"Bob\"</span>);                  <span>// error, too few parameters</span>\n<span>let</span> result2 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>, <span>\"Sr.\"</span>);  <span>// error, too many parameters</span>\n<span>let</span> result3 = buildName(<span>\"Bob\"</span>, <span>\"Adams\"</span>);         <span>// okay and returns \"Bob Adams\"</span>\n<span>let</span> result4 = buildName(<span>undefined</span>, <span>\"Adams\"</span>);     <span>// okay and returns \"Will Adams\"</span>\n</code></pre><h1>剩余参数</h1><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 <code>arguments</code>来访问所有传入的参数。</p><p>在TypeScript里，你可以把所有参数收集到一个变量里：</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, ...restOfName: <span>string</span>[]</span>) </span>{\n  <span>return</span> firstName + <span>\" \"</span> + restOfName.join(<span>\" \"</span>);\n}\n\n<span>let</span> employeeName = buildName(<span>\"Joseph\"</span>, <span>\"Samuel\"</span>, <span>\"Lucas\"</span>, <span>\"MacKinzie\"</span>);\n</code></pre><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p><p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p><pre><code><span><span>function</span> <span>buildName</span>(<span>firstName: <span>string</span>, ...restOfName: <span>string</span>[]</span>) </span>{\n  <span>return</span> firstName + <span>\" \"</span> + restOfName.join(<span>\" \"</span>);\n}\n\n<span>let</span> buildNameFun: (fname: <span>string</span>, ...rest: <span>string</span>[]) =&gt; <span>string</span> = buildName;\n</code></pre><h1><code>this</code></h1><p>学习使用JavaScript里<code>this</code>就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清<code>this</code>工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 <code>this</code>的地方。 如果你想了解JavaScript里的 <code>this</code>是如何工作的，那么首先阅读Yehuda Katz写的<a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\" rel=\"external nofollow\" target=\"_blank\">Understanding JavaScript Function Invocation and \"this\"</a>。 Yehuda的文章详细的阐述了 <code>this</code>的内部工作原理，因此我们这里只做简单介绍。</p><h2><code>this</code>和箭头函数</h2><p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p><p>下面看一个例子：</p><pre><code><span>let</span> deck = {\n    suits: [<span>\"hearts\"</span>, <span>\"spades\"</span>, <span>\"clubs\"</span>, <span>\"diamonds\"</span>],\n    cards: <span>Array</span>(<span>52</span>),\n    createCardPicker: <span><span>function</span>(<span></span>) </span>{\n        <span>return</span> <span><span>function</span>(<span></span>) </span>{\n            <span>let</span> pickedCard = <span>Math</span>.floor(<span>Math</span>.random() * <span>52</span>);\n            <span>let</span> pickedSuit = <span>Math</span>.floor(pickedCard / <span>13</span>);\n\n            <span>return</span> {suit: <span>this</span>.suits[pickedSuit], card: pickedCard % <span>13</span>};\n        }\n    }\n}\n\n<span>let</span> cardPicker = deck.createCardPicker();\n<span>let</span> pickedCard = cardPicker();\n\nalert(<span>\"card: \"</span> + pickedCard.card + <span>\" of \"</span> + pickedCard.suit);\n</code></pre><p>可以看到<code>createCardPicker</code>是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 <code>createCardPicker</code>返回的函数里的<code>this</code>被设置成了<code>window</code>而不是<code>deck</code>对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code>视为<code>window</code>。 （注意：在严格模式下， <code>this</code>为<code>undefined</code>而不是<code>window</code>）。</p><p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 <code>this</code>值，而不是调用时的值：</p><p>我们把函数表达式变为使用lambda表达式（ () =&gt; {} ）。 这样就会在函数创建的时候就指定了‘this’值，而不是在函数调用的时候。</p><pre><code><span>let</span> deck = {\n    suits: [<span>\"hearts\"</span>, <span>\"spades\"</span>, <span>\"clubs\"</span>, <span>\"diamonds\"</span>],\n    cards: <span>Array</span>(<span>52</span>),\n    createCardPicker: <span><span>function</span>(<span></span>) </span>{\n        <span>// <span>NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span>\n        <span>return</span> () =&gt; {\n            <span>let</span> pickedCard = <span>Math</span>.floor(<span>Math</span>.random() * <span>52</span>);\n            <span>let</span> pickedSuit = <span>Math</span>.floor(pickedCard / <span>13</span>);\n\n            <span>return</span> {suit: <span>this</span>.suits[pickedSuit], card: pickedCard % <span>13</span>};\n        }\n    }\n}\n\n<span>let</span> cardPicker = deck.createCardPicker();\n<span>let</span> pickedCard = cardPicker();\n\nalert(<span>\"card: \"</span> + pickedCard.card + <span>\" of \"</span> + pickedCard.suit);\n</code></pre><p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。 它会指出<code>this.suits[pickedSuit]</code>里的<code>this</code>的类型为<code>any</code>。</p><h2><code>this</code>参数</h2><p>不幸的是，<code>this.suits[pickedSuit]</code>的类型依旧为<code>any</code>。 这是因为 <code>this</code>来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code>参数。 <code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p><pre><code><span><span>function</span> <span>f</span>(<span><span>this</span>: <span>void</span></span>) </span>{\n    <span>// make sure `this` is unusable in this standalone function</span>\n}\n</code></pre><p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p><pre><code><span>interface</span> Card {\n    suit: <span>string</span>;\n    card: <span>number</span>;\n}\n<span>interface</span> Deck {\n    suits: <span>string</span>[];\n    cards: <span>number</span>[];\n    createCardPicker(<span>this</span>: Deck): () =&gt; Card;\n}\n<span>let</span> deck: Deck = {\n    suits: [<span>\"hearts\"</span>, <span>\"spades\"</span>, <span>\"clubs\"</span>, <span>\"diamonds\"</span>],\n    cards: <span>Array</span>(<span>52</span>),\n    <span>// <span>NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span>\n    createCardPicker: <span><span>function</span>(<span><span>this</span>: Deck</span>) </span>{\n        <span>return</span> () =&gt; {\n            <span>let</span> pickedCard = <span>Math</span>.floor(<span>Math</span>.random() * <span>52</span>);\n            <span>let</span> pickedSuit = <span>Math</span>.floor(pickedCard / <span>13</span>);\n\n            <span>return</span> {suit: <span>this</span>.suits[pickedSuit], card: pickedCard % <span>13</span>};\n        }\n    }\n}\n\n<span>let</span> cardPicker = deck.createCardPicker();\n<span>let</span> pickedCard = cardPicker();\n\nalert(<span>\"card: \"</span> + pickedCard.card + <span>\" of \"</span> + pickedCard.suit);\n</code></pre><p>现在TypeScript知道<code>createCardPicker</code>期望在某个<code>Deck</code>对象上调用。 也就是说 <code>this</code>是<code>Deck</code>类型的，而非<code>any</code>，因此<code>--noImplicitThis</code>不会报错了。</p><h3><code>this</code>参数在回调函数里</h3><p>你可以也看到过在回调函数里的<code>this</code>报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， <code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过 <code>this</code>参数来避免错误。 首先，库函数的作者要指定 <code>this</code>的类型：</p><pre><code><span>interface</span> UIElement {\n    addClickListener(onclick: (<span>this</span>: <span>void</span>, e: Event) =&gt; <span>void</span>): <span>void</span>;\n}\n</code></pre><p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a<code>this</code> type. Second, annotate your calling code with <code>this</code>:</p><pre><code><span>class</span> Handler {\n    info: <span>string</span>;\n    onClickBad(<span>this</span>: Handler, e: Event) {\n        <span>// oops, used this here. using this callback would crash at runtime</span>\n        <span>this</span>.info = e.message;\n    };\n}\n<span>let</span> h = <span>new</span> Handler();\nuiElement.addClickListener(h.onClickBad); <span>// error!</span>\n</code></pre><p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后TypeScript会检测到<code>addClickListener</code>要求函数带有<code>this: void</code>。 改变 <code>this</code>类型来修复这个错误：</p><pre><code><span>class</span> Handler {\n    info: <span>string</span>;\n    onClickGood(<span>this</span>: <span>void</span>, e: Event) {\n        <span>// can't use this here because it's of type void!</span>\n        <span>console</span>.log(<span>'clicked!'</span>);\n    }\n}\n<span>let</span> h = <span>new</span> Handler();\nuiElement.addClickListener(h.onClickGood);\n</code></pre><p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用 <code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p><pre><code><span>class</span> Handler {\n    info: <span>string</span>;\n    onClickGood = (e: Event) =&gt; { <span>this</span>.info = e.message }\n}\n</code></pre><p>这是可行的因为箭头函数不会捕获<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个<code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 <code>Handler</code>的原型链上。 它们在不同 <code>Handler</code>对象间是共享的。</p><h1>重载</h1><p>JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</p><pre><code><span>let</span> suits = [<span>\"hearts\"</span>, <span>\"spades\"</span>, <span>\"clubs\"</span>, <span>\"diamonds\"</span>];\n\n<span><span>function</span> <span>pickCard</span>(<span>x</span>): <span>any</span> </span>{\n    <span>// Check to see if we're working with an object/array</span>\n    <span>// if so, they gave us the deck and we'll pick the card</span>\n    <span>if</span> (<span>typeof</span> x == <span>\"object\"</span>) {\n        <span>let</span> pickedCard = <span>Math</span>.floor(<span>Math</span>.random() * x.length);\n        <span>return</span> pickedCard;\n    }\n    <span>// Otherwise just let them pick the card</span>\n    <span>else</span> <span>if</span> (<span>typeof</span> x == <span>\"number\"</span>) {\n        <span>let</span> pickedSuit = <span>Math</span>.floor(x / <span>13</span>);\n        <span>return</span> { suit: suits[pickedSuit], card: x % <span>13</span> };\n    }\n}\n\n<span>let</span> myDeck = [{ suit: <span>\"diamonds\"</span>, card: <span>2</span> }, { suit: <span>\"spades\"</span>, card: <span>10</span> }, { suit: <span>\"hearts\"</span>, card: <span>4</span> }];\n<span>let</span> pickedCard1 = myDeck[pickCard(myDeck)];\nalert(<span>\"card: \"</span> + pickedCard1.card + <span>\" of \"</span> + pickedCard1.suit);\n\n<span>let</span> pickedCard2 = pickCard(<span>15</span>);\nalert(<span>\"card: \"</span> + pickedCard2.card + <span>\" of \"</span> + pickedCard2.suit);\n</code></pre><p><code>pickCard</code>方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p><p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code>函数。</p><pre><code><span>let</span> suits = [<span>\"hearts\"</span>, <span>\"spades\"</span>, <span>\"clubs\"</span>, <span>\"diamonds\"</span>];\n\n<span><span>function</span> <span>pickCard</span>(<span>x: {suit: <span>string</span>; card: <span>number</span>; }[]</span>): <span>number</span></span>;\n<span><span>function</span> <span>pickCard</span>(<span>x: <span>number</span></span>): </span>{suit: <span>string</span>; card: <span>number</span>; };\n<span><span>function</span> <span>pickCard</span>(<span>x</span>): <span>any</span> </span>{\n    <span>// Check to see if we're working with an object/array</span>\n    <span>// if so, they gave us the deck and we'll pick the card</span>\n    <span>if</span> (<span>typeof</span> x == <span>\"object\"</span>) {\n        <span>let</span> pickedCard = <span>Math</span>.floor(<span>Math</span>.random() * x.length);\n        <span>return</span> pickedCard;\n    }\n    <span>// Otherwise just let them pick the card</span>\n    <span>else</span> <span>if</span> (<span>typeof</span> x == <span>\"number\"</span>) {\n        <span>let</span> pickedSuit = <span>Math</span>.floor(x / <span>13</span>);\n        <span>return</span> { suit: suits[pickedSuit], card: x % <span>13</span> };\n    }\n}\n\n<span>let</span> myDeck = [{ suit: <span>\"diamonds\"</span>, card: <span>2</span> }, { suit: <span>\"spades\"</span>, card: <span>10</span> }, { suit: <span>\"hearts\"</span>, card: <span>4</span> }];\n<span>let</span> pickedCard1 = myDeck[pickCard(myDeck)];\nalert(<span>\"card: \"</span> + pickedCard1.card + <span>\" of \"</span> + pickedCard1.suit);\n\n<span>let</span> pickedCard2 = pickCard(<span>15</span>);\nalert(<span>\"card: \"</span> + pickedCard2.card + <span>\" of \"</span> + pickedCard2.suit);\n</code></pre><p>这样改变后，重载的<code>pickCard</code>函数在调用的时候会进行正确的类型检查。</p><p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p><p>注意，<code>function pickCard(x): any</code>并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 <code>pickCard</code>会产生错误。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 4,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "e94f5da64673edcb072349a74968101c",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 类",
      "chapter_level_two_url": "/typescript/typescript-class.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h2><span><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">打字稿</font></font></span><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类</font></font><span style=\"line-height: 1.7;\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">介绍</font></font></span></h2><h1></h1><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">传统的JavaScript的程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript的版本。</font></font></p><h1><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类</font></font></h1><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">下面看一个使用类的例子：</font></font></p><pre><code><span>class</span> Greeter {<font></font>\n    greeting: <span>string</span>;\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;<font></font>\n    }<font></font>\n    greet() {<font></font>\n        <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> greeter = <span>new</span> Greeter(<span>\"world\"</span>);\n</code></pre><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">如果你使用过C＃或Java，你会对这种语法非常熟悉。我们声明一个  </font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类。这个类有3个成员：一个叫做</font></font><code>greeting</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">的属性，一个构造函数和一个</font></font><code>greet</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">方法。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">你会注意到，我们在引用任何一个类成员的时候都用了</font></font><code>this</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">。它表示我们访问的是类的成员。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">最后一行，我们使用</font></font><code>new</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">构造了</font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类的一个实例。它会调用之前定义的构造函数，创建一个  </font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类型的新对象，并执行构造函数初始化它。</font></font></p><h1><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">继承</font></font></h1><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">在TypeScript里，我们可以使用常用的面向对象模式。当然，基于类的程序设计中最基本的模式是允许使用继承来扩展现有的类。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">看下面的例子：</font></font></p><pre><code><span>class</span> Animal {<font></font>\n    name:<span>string</span>;\n    <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }<font></font>\n    move(distanceInMeters: <span>number</span> = <span>0</span>) {\n        <span>console</span>.log(<span>`<span>${this.name}</span> moved <span>${distanceInMeters}</span>m.`</span>);<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>class</span> Snake extends Animal {\n    <span>constructor</span>(name: string) { <span>super</span>(name); }<font></font>\n    move(distanceInMeters = <span>5</span>) {\n        <span>console</span>.log(<span>\"Slithering...\"</span>);\n        <span>super</span>.move(distanceInMeters);<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>class</span> Horse extends Animal {\n    <span>constructor</span>(name: string) { <span>super</span>(name); }<font></font>\n    move(distanceInMeters = <span>45</span>) {\n        <span>console</span>.log(<span>\"Galloping...\"</span>);\n        <span>super</span>.move(distanceInMeters);<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> sam = <span>new</span> Snake(<span>\"Sammy the Python\"</span>);\n<span>let</span> tom: Animal = <span>new</span> Horse(<span>\"Tommy the Palomino\"</span>);<font></font>\n<font></font>\nsam.move();<font></font>\ntom.move(<span>34</span>);\n</code></pre><p>这个例子展示了TypeScript中继承的一些特征，它们与其它语言类似。 我们使用 <code>extends</code>关键字来创建子类。你可以看到<code>Horse</code>和<code>Snake</code>类是基类<code>Animal</code>的子类，并且可以访问其属性和方法。</p><p>包含构造函数的派生类必须调用<code>super()</code>，它会执行基类的构造方法。</p><p>这个例子演示了如何在子类里可以重写父类的方法。 <code>Snake</code>类和<code>Horse</code>类都创建了<code>move</code>方法，它们重写了从<code>Animal</code>继承来的<code>move</code>方法，使得<code>move</code>方法根据不同的类而具有不同的功能。 注意，即使 <code>tom</code>被声明为<code>Animal</code>类型，但因为它的值是<code>Horse</code>，<code>tom.move(34)</code>会调用<code>Horse</code>里的重写方法：</p><pre><code>Slithering...<font></font>\nSammy the Python moved 5m.<font></font>\nGalloping...<font></font>\nTommy the Palomino moved 34m.<font></font>\n</code></pre><h1>公共，私有与受保护的修饰符</h1><h2>默认为<code>public</code></h2><p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code>来做修饰；例如，C#要求必须明确地使用<code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为 <code>public</code>。</p><p>你也可以明确的将一个成员标记成<code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code>类：</p><pre><code><span>class</span> Animal {\n    <span>public</span> name: <span>string</span>;\n    <span>public</span> <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }\n    <span>public</span> move(distanceInMeters: <span>number</span>) {\n        <span>console</span>.log(<span>`<span>${this.name}</span> moved <span>${distanceInMeters}</span>m.`</span>);<font></font>\n    }<font></font>\n}<font></font>\n</code></pre><h2>理解<code>private</code></h2><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。比如：</p><pre><code><span>class</span> Animal {\n    <span>private</span> name: <span>string</span>;\n    <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }<font></font>\n}<font></font>\n<font></font>\n<span>new</span> Animal(<span>\"Cat\"</span>).name; <span>// Error: 'name' is private;</span>\n</code></pre><p>TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p><p>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code>成员也使用这个规则。</p><p>下面来看一个例子，更好地说明了这一点：</p><pre><code><span>class</span> Animal {\n    <span>private</span> name: <span>string</span>;\n    <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }<font></font>\n}<font></font>\n<font></font>\n<span>class</span> Rhino extends Animal {\n    <span>constructor</span>() { <span>super</span>(<span>\"Rhino\"</span>); }<font></font>\n}<font></font>\n<font></font>\n<span>class</span> Employee {\n    <span>private</span> name: <span>string</span>;\n    <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> animal = <span>new</span> Animal(<span>\"Goat\"</span>);\n<span>let</span> rhino = <span>new</span> Rhino();\n<span>let</span> employee = <span>new</span> Employee(<span>\"Bob\"</span>);<font></font>\n<font></font>\nanimal = rhino;<font></font>\nanimal = employee; <span>// Error: Animal and Employee are not compatible</span>\n</code></pre><p>这个例子中有<code>Animal</code>和<code>Rhino</code>两个类，<code>Rhino</code>是<code>Animal</code>类的子类。 还有一个 <code>Employee</code>类，其类型看上去与<code>Animal</code>是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code>和<code>Rhino</code>共享了来自<code>Animal</code>里的私有成员定义<code>private name: string</code>，因此它们是兼容的。 然而 <code>Employee</code>却不是这样。当把<code>Employee</code>赋值给<code>Animal</code>的时候，得到一个错误，说它们的类型不兼容。 尽管 <code>Employee</code>里也有一个私有成员<code>name</code>，但它明显不是<code>Animal</code>里面定义的那个。</p><h2>理解<code>protected</code></h2><p><code>protected</code>修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p><pre><code><span>class</span> Person {\n    <span>protected</span> name: <span>string</span>;\n    <span>constructor</span>(name: string) { <span>this</span>.name = name; }<font></font>\n}<font></font>\n<font></font>\n<span>class</span> Employee extends Person {\n    <span>private</span> department: <span>string</span>;<font></font>\n<font></font>\n    <span>constructor</span>(name: string, department: string) {\n        <span>super</span>(name)\n        <span>this</span>.department = department;<font></font>\n    }<font></font>\n<font></font>\n    <span>public</span> getElevatorPitch() {\n        <span>return</span> <span>`Hello, my name is <span>${this.name}</span> and I work in <span>${this.department}</span>.`</span>;<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> howard = <span>new</span> Employee(<span>\"Howard\"</span>, <span>\"Sales\"</span>);\n<span>console</span>.log(howard.getElevatorPitch());\n<span>console</span>.log(howard.name); <span>// error</span>\n</code></pre><p>注意，我们不能在<code>Person</code>类外使用<code>name</code>，但是我们仍然可以通过<code>Employee</code>类的实例方法访问，因为<code>Employee</code>是由<code>Person</code>派生而来的。</p><p>构造函数也可以被标记成<code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p><pre><code><span>class</span> Person {\n    <span>protected</span> name: <span>string</span>;\n    <span>protected</span> <span>constructor</span>(theName: string) { <span>this</span>.name = theName; }<font></font>\n}<font></font>\n<font></font>\n<span>// Employee can extend Person</span>\n<span>class</span> Employee extends Person {\n    <span>private</span> department: <span>string</span>;<font></font>\n<font></font>\n    <span>constructor</span>(name: string, department: string) {\n        <span>super</span>(name);\n        <span>this</span>.department = department;<font></font>\n    }<font></font>\n<font></font>\n    <span>public</span> getElevatorPitch() {\n        <span>return</span> <span>`Hello, my name is <span>${this.name}</span> and I work in <span>${this.department}</span>.`</span>;<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> howard = <span>new</span> Employee(<span>\"Howard\"</span>, <span>\"Sales\"</span>);\n<span>let</span> john = <span>new</span> Person(<span>\"John\"</span>); <span>// Error: The 'Person' constructor is protected</span>\n</code></pre><h1>readonly修饰符</h1><p>你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p><pre><code><span>class</span> Octopus {<font></font>\n    readonly name: <span>string</span>;<font></font>\n    readonly numberOfLegs: <span>number</span> = <span>8</span>;\n    <span>constructor</span> (theName: string) {\n        <span>this</span>.name = theName;<font></font>\n    }<font></font>\n}<font></font>\n<span>let</span> dad = <span>new</span> Octopus(<span>\"Man with the 8 strong legs\"</span>);<font></font>\ndad.name = <span>\"Man with the 3-piece suit\"</span>; <span>// error! name is readonly.</span>\n</code></pre><h2>参数属性</h2><p>在上面的例子中，我们不得不定义一个受保护的成员<code>name</code>和一个构造函数参数<code>theName</code>在<code>Person</code>类里，并且立刻给<code>name</code>和<code>theName</code>赋值。 这种情况经常会遇到。 <em>参数属性</em>可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Animal</code>类的修改版，使用了参数属性：</p><pre><code><span>class</span> Animal {\n    <span>constructor</span>(private name: string) { }<font></font>\n    move(distanceInMeters: <span>number</span>) {\n        <span>console</span>.log(<span>`<span>${this.name}</span> moved <span>${distanceInMeters}</span>m.`</span>);<font></font>\n    }<font></font>\n}<font></font>\n</code></pre><p>注意看我们是如何舍弃了<code>theName</code>，仅在构造函数里使用<code>private name: string</code>参数来创建和初始化<code>name</code>成员。 我们把声明和赋值合并至一处。</p><p>参数属性通过给构造函数参数添加一个访问限定符来声明。 使用 <code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于<code>public</code>和<code>protected</code>来说也是一样。</p><h1>存取器</h1><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>下面来看如何把一个简单的类改写成使用<code>get</code>和<code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p><pre><code><span>class</span> Employee {<font></font>\n    fullName: <span>string</span>;<font></font>\n}<font></font>\n<font></font>\n<span>let</span> employee = <span>new</span> Employee();<font></font>\nemployee.fullName = <span>\"Bob Smith\"</span>;\n<span>if</span> (employee.fullName) {\n    <span>console</span>.log(employee.fullName);<font></font>\n}<font></font>\n</code></pre><p>我们可以随意的设置<code>fullName</code>，这是非常方便的，但是这也可能会带来麻烦。</p><p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 <code>fullName</code>的直接访问改成了可以检查密码的<code>set</code>方法。 我们也加了一个 <code>get</code>方法，让上面的例子仍然可以工作。</p><pre><code><span>let</span> passcode = <span>\"secret passcode\"</span>;<font></font>\n<font></font>\n<span>class</span> Employee {\n    <span>private</span> _fullName: <span>string</span>;<font></font>\n<font></font>\n    <span>get</span> fullName(): <span>string</span> {\n        <span>return</span> <span>this</span>._fullName;<font></font>\n    }<font></font>\n<font></font>\n    <span>set</span> fullName(newName: <span>string</span>) {\n        <span>if</span> (passcode &amp;&amp; passcode == <span>\"secret passcode\"</span>) {\n            <span>this</span>._fullName = newName;<font></font>\n        }<font></font>\n        <span>else</span> {\n            <span>console</span>.log(<span>\"Error: Unauthorized update of employee!\"</span>);<font></font>\n        }<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> employee = <span>new</span> Employee();<font></font>\nemployee.fullName = <span>\"Bob Smith\"</span>;\n<span>if</span> (employee.fullName) {<font></font>\n    alert(employee.fullName);<font></font>\n}<font></font>\n</code></pre><p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p><p>对于存取器有下面几点需要注意的：</p><p>首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 <code>get</code>不带有<code>set</code>的存取器自动被推断为<code>readonly</code>。 这在从代码生成 <code>.d.ts</code>文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p><h1>静态属性</h1><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code>定义<code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code>前面加上类名。 如同在实例属性上使用 <code>this.</code>前缀来访问属性一样，这里我们使用<code>Grid.</code>来访问静态属性。</p><pre><code><span>class</span> Grid {\n    <span>static</span> origin = {x: <span>0</span>, y: <span>0</span>};<font></font>\n    calculateDistanceFromOrigin(point: {x: <span>number</span>; y: <span>number</span>;}) {\n        <span>let</span> xDist = (point.x - Grid.origin.x);\n        <span>let</span> yDist = (point.y - Grid.origin.y);\n        <span>return</span> <span>Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span>this</span>.scale;<font></font>\n    }<font></font>\n    <span>constructor</span> (public scale: number) { }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> grid1 = <span>new</span> Grid(<span>1.0</span>);  <span>// 1x scale</span>\n<span>let</span> grid2 = <span>new</span> Grid(<span>5.0</span>);  <span>// 5x scale</span><font></font>\n<font></font>\n<span>console</span>.log(grid1.calculateDistanceFromOrigin({x: <span>10</span>, y: <span>10</span>}));\n<span>console</span>.log(grid2.calculateDistanceFromOrigin({x: <span>10</span>, y: <span>10</span>}));\n</code></pre><h1>抽象类</h1><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。<code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><pre><code><span>abstract</span> <span>class</span> Animal {\n    <span>abstract</span> makeSound(): <span>void</span>;<font></font>\n    move(): <span>void</span> {\n        <span>console</span>.log(<span>'roaming the earch...'</span>);<font></font>\n    }<font></font>\n}<font></font>\n</code></pre><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code>关键字并且可以包含访问修饰符。</p><pre><code><span>abstract</span> <span>class</span> Department {<font></font>\n<font></font>\n    <span>constructor</span>(public name: string) {<font></font>\n    }<font></font>\n<font></font>\n    printName(): <span>void</span> {\n        <span>console</span>.log(<span>'Department name: '</span> + <span>this</span>.name);<font></font>\n    }<font></font>\n<font></font>\n    <span>abstract</span> printMeeting(): <span>void</span>; <span>// 必须在派生类中实现</span><font></font>\n}<font></font>\n<font></font>\n<span>class</span> AccountingDepartment extends Department {<font></font>\n<font></font>\n    <span>constructor</span>() {\n        <span>super</span>(<span>'Accounting and Auditing'</span>); <span>// constructors in derived classes must call super()</span><font></font>\n    }<font></font>\n<font></font>\n    printMeeting(): <span>void</span> {\n        <span>console</span>.log(<span>'The Accounting Department meets each Monday at 10am.'</span>);<font></font>\n    }<font></font>\n<font></font>\n    generateReports(): <span>void</span> {\n        <span>console</span>.log(<span>'Generating accounting reports...'</span>);<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> department: Department; <span>// ok to create a reference to an abstract type</span>\ndepartment = <span>new</span> Department(); <span>// error: cannot create an instance of an abstract class</span>\ndepartment = <span>new</span> AccountingDepartment(); <span>// ok to create and assign a non-abstract subclass</span><font></font>\ndepartment.printName();<font></font>\ndepartment.printMeeting();<font></font>\ndepartment.generateReports(); <span>// error: method doesn't exist on declared abstract type</span>\n</code></pre><h1>高级技巧</h1><h2>构造函数</h2><p>当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 <em>实例</em>的类型。</p><pre><code><span>class</span> Greeter {<font></font>\n    greeting: <span>string</span>;\n    <span>constructor</span>(message: string) {\n        <span>this</span>.greeting = message;<font></font>\n    }<font></font>\n    greet() {<font></font>\n        <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> greeter: Greeter;<font></font>\ngreeter = <span>new</span> Greeter(<span>\"world\"</span>);\n<span>console</span>.log(greeter.greet());\n</code></pre><p>这里，我们写了<code>let greeter: Greeter</code>，意思是<code>Greeter</code>类的实例的类型是<code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">我们也创建了一个叫做</font></font><em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">构造函数</font></font></em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">的值。这个函数会在我们使用  </font></font><code>new</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">创建类实例的时候被调用。下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</font></font></p><pre><code><span>let</span> Greeter = (<span><span>function</span> (<span></span>) </span>{\n    <span><span>function</span> <span>Greeter</span>(<span>message</span>) </span>{\n        <span>this</span>.greeting = message;<font></font>\n    }<font></font>\n    Greeter.prototype.greet = <span><span>function</span> (<span></span>) </span>{\n        <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;<font></font>\n    };<font></font>\n    <span>return</span> Greeter;<font></font>\n})();<font></font>\n<font></font>\n<span>let</span> greeter;<font></font>\ngreeter = <span>new</span> Greeter(<span>\"world\"</span>);\n<span>console</span>.log(greeter.greet());\n</code></pre><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">上面的代码里，</font></font><code>let Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">将被赋值为构造函数。我们当调用  </font></font><code>new</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性</font><font style=\"vertical-align: inherit;\">。换个角度说，我们可以认为类具有  </font></font><em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">实例部分</font></font></em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">与</font></font><em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">静态部分</font></font></em><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">这两个部分。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">让我们稍微改写一下这个例子，看看它们之前的区别：</font></font></p><pre><code><span>class</span> Greeter {\n    <span>static</span> standardGreeting = <span>\"Hello, there\"</span>;<font></font>\n    greeting: <span>string</span>;<font></font>\n    greet() {<font></font>\n        <span>if</span> (<span>this</span>.greeting) {\n            <span>return</span> <span>\"Hello, \"</span> + <span>this</span>.greeting;<font></font>\n        }<font></font>\n        <span>else</span> {\n            <span>return</span> Greeter.standardGreeting;<font></font>\n        }<font></font>\n    }<font></font>\n}<font></font>\n<font></font>\n<span>let</span> greeter1: Greeter;<font></font>\ngreeter1 = <span>new</span> Greeter();\n<span>console</span>.log(greeter1.greet());<font></font>\n<font></font>\n<span>let</span> greeterMaker: <span>typeof</span> Greeter = Greeter;<font></font>\ngreeterMaker.standardGreeting = <span>\"Hey there!\"</span>;<font></font>\n<font></font>\n<span>let</span> greeter2: Greeter = <span>new</span> greeterMaker();\n<span>console</span>.log(greeter2.greet());\n</code></pre><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">这个例子里，</font></font><code>greeter1</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">与之前看到的一样。我们实例化  </font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">类，并使用这个对象。与我们之前看到的一样。</font></font></p><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">再之后，我们直接使用类。我们创建³³了一个叫做  </font></font><code>greeterMaker</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">的变量。这个变量保存了这个类或者说保存了类构造函数</font><font style=\"vertical-align: inherit;\">。然后我们使用  </font></font><code>typeof Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">，意思是取招待员类的类型，而不是实例的类型。或者更确切的说， “我告诉  </font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">标识符的类型”，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数</font><font style=\"vertical-align: inherit;\">。之后，就和前面一样，在我们  </font></font><code>greeterMaker</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">上使用</font></font><code>new</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">，创建³³ </font></font><code>Greeter</code><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">的实例。</font></font></p><h2><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">把类当做接口使用</font></font></h2><p><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</font></font></p><pre><code><span>class</span> Point {<font></font>\n    x: <span>number</span>;<font></font>\n    y: <span>number</span>;<font></font>\n}<font></font>\n<font></font>\n<span>interface</span> Point3d <span>extends</span> Point {<font></font>\n    z: <span>number</span>;<font></font>\n}<font></font>\n<font></font>\n<span>let</span> point3d: Point3d = {x: <span>1</span>, y: <span>2</span>, z: <span>3</span>};</code></pre></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 3,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "09f9ed92beb8db11c8edd310a3224f60",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 接口",
      "chapter_level_two_url": "/typescript/typescript-interfaces.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span>TypeScript</span>接口</h1><h1>介绍</h1><p>TypeScript的核心原则之一是对值所具有的<em>shape</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><h1>接口初探</h1><p>下面通过一个简单示例来观察接口是如何工作的：</p><pre><code><span><span>function</span> <span>printLabel</span>(<span>labelledObj: { label: <span>string</span> }</span>) </span>{\n  <span>console</span>.log(labelledObj.label);\n}\n\n<span>let</span> myObj = { size: <span>10</span>, label: <span>\"Size 10 Object\"</span> };\nprintLabel(myObj);\n</code></pre><p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p><p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p><pre><code><span>interface</span> LabelledValue {\n  label: <span>string</span>;\n}\n\n<span><span>function</span> <span>printLabel</span>(<span>labelledObj: LabelledValue</span>) </span>{\n  <span>console</span>.log(labelledObj.label);\n}\n\n<span>let</span> myObj = {size: <span>10</span>, label: <span>\"Size 10 Object\"</span>};\nprintLabel(myObj);\n</code></pre><p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p><p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h1>可选属性</h1><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p><p>下面是应用了“option bags”的例子：</p><pre><code><span>interface</span> SquareConfig {\n  color?: <span>string</span>;\n  width?: <span>number</span>;\n}\n\n<span><span>function</span> <span>createSquare</span>(<span>config: SquareConfig</span>): </span>{color: <span>string</span>; area: <span>number</span>} {\n  <span>let</span> newSquare = {color: <span>\"white\"</span>, area: <span>100</span>};\n  <span>if</span> (config.color) {\n    newSquare.color = config.color;\n  }\n  <span>if</span> (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  <span>return</span> newSquare;\n}\n\n<span>let</span> mySquare = createSquare({color: <span>\"black\"</span>});\n</code></pre><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p><pre><code><span>interface</span> SquareConfig {\n  color?: <span>string</span>;\n  width?: <span>number</span>;\n}\n\n<span><span>function</span> <span>createSquare</span>(<span>config: SquareConfig</span>): </span>{ color: <span>string</span>; area: <span>number</span> } {\n  <span>let</span> newSquare = {color: <span>\"white\"</span>, area: <span>100</span>};\n  <span>if</span> (config.color) {\n    <span>// Error: Property 'collor' does not exist on type 'SquareConfig'</span>\n    newSquare.color = config.collor;  <span>// Type-checker can catch the mistyped name here</span>\n  }\n  <span>if</span> (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  <span>return</span> newSquare;\n}\n\n<span>let</span> mySquare = createSquare({color: <span>\"black\"</span>});\n</code></pre><h1>只读属性</h1><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p><pre><code><span>interface</span> Point {\n    readonly x: <span>number</span>;\n    readonly y: <span>number</span>;\n}\n</code></pre><p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， <code>x</code>和<code>y</code>再也不能被改变了。</p><pre><code><span>let</span> p1: Point = { x: <span>10</span>, y: <span>20</span> };\np1.x = <span>5</span>; <span>// error!</span>\n</code></pre><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><pre><code><span>let</span> a: <span>number</span>[] = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>];\n<span>let</span> ro: ReadonlyArray&lt;<span>number</span>&gt; = a;\nro[<span>0</span>] = <span>12</span>; <span>// error!</span>\nro.push(<span>5</span>); <span>// error!</span>\nro.length = <span>100</span>; <span>// error!</span>\na = ro; <span>// error!</span>\n</code></pre><p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><pre><code>a = ro as <span>number</span>[];\n</code></pre><h2><code>readonly</code> vs <code>const</code></h2><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p><h1>额外的属性检查</h1><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>{ size: number; label: string; }</code>到仅期望得到<code>{ label: string; }</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p><p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code>例子来说：</p><pre><code><span>interface</span> SquareConfig {\n    color?: <span>string</span>;\n    width?: <span>number</span>;\n}\n\n<span><span>function</span> <span>createSquare</span>(<span>config: SquareConfig</span>): </span>{ color: <span>string</span>; area: <span>number</span> } {\n    <span>// ...</span>\n}\n\n<span>let</span> mySquare = createSquare({ colour: <span>\"red\"</span>, width: <span>100</span> });\n</code></pre><p>注意传入<code>createSquare</code>的参数拼写为*<code>colour</code>*而不是<code>color</code>。 在JavaScript里，这会默默地失败。</p><p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p><p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 <em>额外属性检查</em>，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p><pre><code><span>// error: 'colour' not expected in type 'SquareConfig'</span>\n<span>let</span> mySquare = createSquare({ colour: <span>\"red\"</span>, width: <span>100</span> });\n</code></pre><p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p><pre><code><span>let</span> mySquare = createSquare({ width: <span>100</span>, opacity: <span>0.5</span> } as SquareConfig);\n</code></pre><p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且<em>还会</em>带有任意数量的其它属性，那么我们可以这样定义它：</p><pre><code><span>interface</span> SquareConfig {\n    color?: <span>string</span>;\n    width?: <span>number</span>;\n    [propName: <span>string</span>]: <span>any</span>;\n}\n</code></pre><p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p><p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为<code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p><pre><code><span>let</span> squareOptions = { colour: <span>\"red\"</span>, width: <span>100</span> };\n<span>let</span> mySquare = createSquare(squareOptions);\n</code></pre><p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如选择包，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p><h1>函数类型</h1><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><pre><code><span>interface</span> SearchFunc {\n  (source: <span>string</span>, subString: <span>string</span>): <span>boolean</span>;\n}\n</code></pre><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p><pre><code><span>let</span> mySearch: SearchFunc;\nmySearch = <span><span>function</span>(<span>source: <span>string</span>, subString: <span>string</span></span>) </span>{\n  <span>let</span> result = source.search(subString);\n  <span>if</span> (result == <span>-1</span>) {\n    <span>return</span> <span>false</span>;\n  }\n  <span>else</span> {\n    <span>return</span> <span>true</span>;\n  }\n}\n</code></pre><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p><pre><code><span>let</span> mySearch: SearchFunc;\nmySearch = <span><span>function</span>(<span>src: <span>string</span>, sub: <span>string</span></span>): <span>boolean</span> </span>{\n  <span>let</span> result = src.search(sub);\n  <span>if</span> (result == <span>-1</span>) {\n    <span>return</span> <span>false</span>;\n  }\n  <span>else</span> {\n    <span>return</span> <span>true</span>;\n  }\n}\n</code></pre><p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，Typescript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code>和<code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与<code>SearchFunc</code>接口中的定义不匹配。</p><pre><code><span>let</span> mySearch: SearchFunc;\nmySearch = <span><span>function</span>(<span>src, sub</span>) </span>{\n    <span>let</span> result = src.search(sub);\n    <span>if</span> (result == <span>-1</span>) {\n        <span>return</span> <span>false</span>;\n    }\n    <span>else</span> {\n        <span>return</span> <span>true</span>;\n    }\n}\n</code></pre><h1>可索引的类型</h1><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[\"daniel\"]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p><pre><code><span>interface</span> StringArray {\n  [index: <span>number</span>]: <span>string</span>;\n}\n\n<span>let</span> myArray: StringArray;\nmyArray = [<span>\"Bob\"</span>, <span>\"Fred\"</span>];\n\n<span>let</span> myStr: <span>string</span> = myArray[<span>0</span>];\n</code></pre><p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p><p>共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 <code>100</code>（一个<code>number</code>）去索引等同于使用<code>\"100\"</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p><pre><code><span>class</span> Animal {\n    name: <span>string</span>;\n}\n<span>class</span> Dog extends Animal {\n    breed: <span>string</span>;\n}\n\n<span>// Error: indexing with a 'string' will sometimes get you a Dog!</span>\n<span>interface</span> NotOkay {\n    [x: <span>number</span>]: Animal;\n    [x: <span>string</span>]: Dog;\n}\n</code></pre><p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj[\"property\"]</code>两种形式都可以。 下面的例子里， <code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p><pre><code><span>interface</span> NumberDictionary {\n  [index: <span>string</span>]: <span>number</span>;\n  length: <span>number</span>;    <span>// 可以，length是number类型</span>\n  name: <span>string</span>       <span>// 错误，`name`的类型不是索引类型的子类型</span>\n}\n</code></pre><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p><pre><code><span>interface</span> ReadonlyStringArray {\n    readonly [index: <span>number</span>]: <span>string</span>;\n}\n<span>let</span> myArray: ReadonlyStringArray = [<span>\"Alice\"</span>, <span>\"Bob\"</span>];\nmyArray[<span>2</span>] = <span>\"Mallory\"</span>; <span>// error!</span>\n</code></pre><p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p><h1>类类型</h1><h2>实现接口</h2><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p><pre><code><span>interface</span> ClockInterface {\n    currentTime: <span>Date</span>;\n}\n\n<span>class</span> Clock <span>implements</span> ClockInterface {\n    currentTime: <span>Date</span>;\n    <span>constructor</span>(h: number, m: number) { }\n}\n</code></pre><p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p><pre><code><span>interface</span> ClockInterface {\n    currentTime: <span>Date</span>;\n    setTime(d: <span>Date</span>);\n}\n\n<span>class</span> Clock <span>implements</span> ClockInterface {\n    currentTime: <span>Date</span>;\n    setTime(d: <span>Date</span>) {\n        <span>this</span>.currentTime = d;\n    }\n    <span>constructor</span>(h: number, m: number) { }\n}\n</code></pre><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p><h2>类静态部分与实例部分的区别</h2><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p><pre><code><span>interface</span> ClockConstructor {\n    <span>new</span> (hour: <span>number</span>, minute: <span>number</span>);\n}\n\n<span>class</span> Clock <span>implements</span> ClockConstructor {\n    currentTime: <span>Date</span>;\n    <span>constructor</span>(h: number, m: number) { }\n}\n</code></pre><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p><p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， <code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p><pre><code><span>interface</span> ClockConstructor {\n    <span>new</span> (hour: <span>number</span>, minute: <span>number</span>): ClockInterface;\n}\n<span>interface</span> ClockInterface {\n    tick();\n}\n\n<span><span>function</span> <span>createClock</span>(<span>ctor: ClockConstructor, hour: <span>number</span>, minute: <span>number</span></span>): <span>ClockInterface</span> </span>{\n    <span>return</span> <span>new</span> ctor(hour, minute);\n}\n\n<span>class</span> DigitalClock <span>implements</span> ClockInterface {\n    <span>constructor</span>(h: number, m: number) { }\n    tick() {\n        <span>console</span>.log(<span>\"beep beep\"</span>);\n    }\n}\n<span>class</span> AnalogClock <span>implements</span> ClockInterface {\n    <span>constructor</span>(h: number, m: number) { }\n    tick() {\n        <span>console</span>.log(<span>\"tick tock\"</span>);\n    }\n}\n\n<span>let</span> digital = createClock(DigitalClock, <span>12</span>, <span>17</span>);\n<span>let</span> analog = createClock(AnalogClock, <span>7</span>, <span>32</span>);\n</code></pre><p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p><h1>扩展接口</h1><p>和类一样，接口也可以相互扩展。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><pre><code><span>interface</span> Shape {\n    color: <span>string</span>;\n}\n\n<span>interface</span> Square <span>extends</span> Shape {\n    sideLength: <span>number</span>;\n}\n\n<span>let</span> square = &lt;Square&gt;{};\nsquare.color = <span>\"blue\"</span>;\nsquare.sideLength = <span>10</span>;\n</code></pre><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><pre><code><span>interface</span> Shape {\n    color: <span>string</span>;\n}\n\n<span>interface</span> PenStroke {\n    penWidth: <span>number</span>;\n}\n\n<span>interface</span> Square <span>extends</span> Shape, PenStroke {\n    sideLength: <span>number</span>;\n}\n\n<span>let</span> square = &lt;Square&gt;{};\nsquare.color = <span>\"blue\"</span>;\nsquare.sideLength = <span>10</span>;\nsquare.penWidth = <span>5.0</span>;\n</code></pre><h1>混合类型</h1><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p><p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p><pre><code><span>interface</span> Counter {\n    (start: <span>number</span>): <span>string</span>;\n    interval: <span>number</span>;\n    reset(): <span>void</span>;\n}\n\n<span><span>function</span> <span>getCounter</span>(<span></span>): <span>Counter</span> </span>{\n    <span>let</span> counter = &lt;Counter&gt;<span><span>function</span> (<span>start: <span>number</span></span>) </span>{ };\n    counter.interval = <span>123</span>;\n    counter.reset = <span><span>function</span> (<span></span>) </span>{ };\n    <span>return</span> counter;\n}\n\n<span>let</span> c = getCounter();\nc(<span>10</span>);\nc.reset();\nc.interval = <span>5.0</span>;\n</code></pre><p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p><h1>接口继承类</h1><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><p>这是很有用的，当你有一个很深层次的继承，但是只想你的代码只是针对拥有特定属性的子类起作用的时候。子类除了继承自基类外与基类没有任何联系。 例：</p><pre><code><span>class</span> Control {\n    <span>private</span> state: <span>any</span>;\n}\n\n<span>interface</span> SelectableControl <span>extends</span> Control {\n    select(): <span>void</span>;\n}\n\n<p>class Button extends Control implements SelectableControl {\n</p><p>    select() { }\n</p><p>}\n</p><p>class TextBox extends Control {\n</p><p>    select() { }\n</p><p>}\n</p><p>// 错误：“Image”类型缺少“state”属性。\n</p><p>class Image implements SelectableControl {\n</p><p>    select() { }\n</p><p>}\n</p><p>class Location {\n</p><p>}</p></code></pre><p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为 <code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有 <code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p><p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上，<code>SelectableControl</code>就像<code>Control</code>一样，并拥有一个<code>select</code>方法。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法），但<code>Image</code>和<code>Location</code>类并不是这样的。</p><p><br></p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    },
    {
      "teach_name": "TypeScript 教程",
      "teach_introduction": "TypeScript是JavaScript的一个超集类型编译为普通的JavaScript。TypeScript是纯面向对象与类，接口和静态类型如C＃或Java",
      "sort_index": 2,
      "parent_sort_index": 5,
      "chapter_level_one_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_one_parent_id": "0",
      "chapter_level_one_name": "TypeScript 手册指南",
      "chapter_level_one_url": "",
      "chapter_level_two_id": "a3159e18402b7d55de963bd29ea70904",
      "chapter_level_two_parent_id": "690ba896348808ab5eceb6a4b5593113",
      "chapter_level_two_name": "TypeScript 变量声明",
      "chapter_level_two_url": "/typescript/typescript-variable-declarations.html",
      "book_content": "<div class=\"content-bg\">\n<div class=\"content-intro view-box \"><h1><span style=\"line-height: 1.7; font-weight: normal;\"><span>TypeScript</span>变量声明</span><br></h1><p><code>let</code>和<code>const</code>是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， <code>let</code>在很多方面与<code>var</code>是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 <code>const</code>是对<code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p><p>因为TypeScript是JavaScript的超集，所以它本身就支持<code>let</code>和<code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p><p>如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 <code>var</code>声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p><h1><code>var</code> 声明</h1><p>一直以来我们都是通过<code>var</code>关键字定义JavaScript变量。</p><pre><code><span>var</span> a = <span>10</span>;\n</code></pre><p>大家都能理解，这里定义了一个名为<code>a</code>值为<code>10</code>的变量。</p><p>我们也可以在函数内部定义变量：</p><pre><code><span><span>function</span> <span>f</span>(<span></span>) </span>{\n    <span>var</span> message = <span>\"Hello, world!\"</span>;\n\n    <span>return</span> message;\n}\n</code></pre><p>并且我们也可以在其它函数内部访问相同的变量。</p><pre><code><span><span>function</span> <span>f</span>(<span></span>) </span>{\n    <span>var</span> a = <span>10</span>;\n    <span>return</span> <span><span>function</span> <span>g</span>(<span></span>) </span>{\n        <span>var</span> b = a + <span>1</span>;\n        <span>return</span> b;\n    }\n}\n\n<span>var</span> g = f();\ng(); <span>// returns 11;</span>\n</code></pre><p>上面的例子里，<code>g</code>可以获取到<code>f</code>函数里定义的<code>a</code>变量。 每当 <code>g</code>被调用时，它都可以访问到<code>f</code>里的<code>a</code>变量。 即使当<code>g</code>在<code>f</code>已经执行完后才被调用，它仍然可以访问及修改<code>a</code>。</p><pre><code><span><span>function</span> <span>f</span>(<span></span>) </span>{\n    <span>var</span> a = <span>1</span>;\n\n    a = <span>2</span>;\n    <span>var</span> b = g();\n    a = <span>3</span>;\n\n    <span>return</span> b;\n\n    <span><span>function</span> <span>g</span>(<span></span>) </span>{\n        <span>return</span> a;\n    }\n}\n\nf(); <span>// returns 2</span>\n</code></pre><h2>作用域规则</h2><p>对于熟悉其它语言的人来说，<code>var</code>声明有些奇怪的作用域规则。 看下面的例子：</p><pre><code><span><span>function</span> <span>f</span>(<span>shouldInitialize: <span>boolean</span></span>) </span>{\n    <span>if</span> (shouldInitialize) {\n        <span>var</span> x = <span>10</span>;\n    }\n\n    <span>return</span> x;\n}\n\nf(<span>true</span>);  <span>// returns '10'</span>\nf(<span>false</span>); <span>// returns 'undefined'</span>\n</code></pre><p>有些读者可能要多看几遍这个例子。 变量 <code>x</code>是定义在*<code>if</code>语句里面*，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* <code>var</code>作用域<em>或</em>函数作用域*。 函数参数也使用函数作用域。</p><p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p><pre><code><span><span>function</span> <span>sumMatrix</span>(<span>matrix: <span>number</span>[][]</span>) </span>{\n    <span>var</span> sum = <span>0</span>;\n    <span>for</span> (<span>var</span> i = <span>0</span>; i &lt; matrix.length; i++) {\n        <span>var</span> currentRow = matrix[i];\n        <span>for</span> (<span>var</span> i = <span>0</span>; i &lt; currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    <span>return</span> sum;\n}\n</code></pre><p>这里很容易看出一些问题，里层的<code>for</code>循环会覆盖变量<code>i</code>，因为所有<code>i</code>都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p><h2>变量获取怪异之处</h2><p>快速的猜一下下面的代码会返回什么：</p><pre><code><span>for</span> (<span>var</span> i = <span>0</span>; i &lt; <span>10</span>; i++) {\n    setTimeout(<span><span>function</span>(<span></span>) </span>{ <span>console</span>.log(i); }, <span>100</span> * i);\n}\n</code></pre><p>介绍一下，<code>setTimeout</code>会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p><p>好吧，看一下结果：</p><pre><code>10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n</code></pre><p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p><pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre><p>还记得我们上面讲的变量获取吗？</p><blockquote><p>每当<code>g</code>被调用时，它都可以访问到<code>f</code>里的<code>a</code>变量。</p></blockquote><p>让我们花点时间考虑在这个上下文里的情况。 <code>setTimeout</code>在若干毫秒后执行一个函数，并且是在<code>for</code>循环结束后。 <code>for</code>循环结束后，<code>i</code>的值为<code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>！</p><p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时<code>i</code>的值：</p><pre><code><span>for</span> (<span>var</span> i = <span>0</span>; i &lt; <span>10</span>; i++) {\n    <span>// capture the current state of 'i'</span>\n    <span>// by invoking a function with its current value</span>\n    (<span><span>function</span>(<span>i</span>) </span>{\n        setTimeout(<span><span>function</span>(<span></span>) </span>{ <span>console</span>.log(i); }, <span>100</span> * i);\n    })(i);\n}\n</code></pre><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code>会覆盖<code>for</code>循环里的<code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改<code>for</code>循环体里的代码。</p><h1><code>let</code> 声明</h1><p>现在你已经知道了<code>var</code>存在一些问题，这恰好说明了为什么用<code>let</code>语句来声明变量。 除了名字不同外， <code>let</code>与<code>var</code>的写法一致。</p><pre><code><span>let</span> hello = <span>\"Hello!\"</span>;\n</code></pre><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p><h2>块作用域</h2><p>当用<code>let</code>声明一个变量，它使用的是<em>词法作用域</em>或<em>块作用域</em>。 不同于使用 <code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或<code>for</code>循环之外是不能访问的。</p><pre><code><span><span>function</span> <span>f</span>(<span>input: <span>boolean</span></span>) </span>{\n    <span>let</span> a = <span>100</span>;\n\n    <span>if</span> (input) {\n        <span>// Still okay to reference 'a'</span>\n        <span>let</span> b = a + <span>1</span>;\n        <span>return</span> b;\n    }\n\n    <span>// Error: 'b' doesn't exist here</span>\n    <span>return</span> b;\n}\n</code></pre><p>这里我们定义了2个变量<code>a</code>和<code>b</code>。 <code>a</code>的作用域是<code>f</code>函数体内，而<code>b</code>的作用域是<code>if</code>语句块里。</p><p>在<code>catch</code>语句里声明的变量也具有同样的作用域规则。</p><pre><code><span>try</span> {\n    <span>throw</span> <span>\"oh no!\"</span>;\n}\n<span>catch</span> (e) {\n    <span>console</span>.log(<span>\"Oh well.\"</span>);\n}\n\n<span>// Error: 'e' doesn't exist here</span>\n<span>console</span>.log(e);\n</code></pre><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 <em>时间死区</em>。 它只是用来说明我们不能在 <code>let</code>语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p><pre><code>a++; <span>// illegal to use 'a' before it's declared;</span>\n<span>let</span> a;\n</code></pre><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前<em>获取</em>它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p><pre><code><span><span>function</span> <span>foo</span>(<span></span>) </span>{\n    <span>// okay to capture 'a'</span>\n    <span>return</span> a;\n}\n\n<span>// 不能在'a'被声明前调用'foo'</span>\n<span>// 运行时应该抛出错误</span>\nfoo();\n\n<span>let</span> a;\n</code></pre><p>关于<em>时间死区</em>的更多信息，查看这里<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\" rel=\"external nofollow\" target=\"_blank\">Mozilla Developer Network</a>.</p><h2>重定义及屏蔽</h2><p>我们提过使用<code>var</code>声明时，它不在乎你声明多少次；你只会得到1个。</p><pre><code><span><span>function</span> <span>f</span>(<span>x</span>) </span>{\n    <span>var</span> x;\n    <span>var</span> x;\n\n    <span>if</span> (<span>true</span>) {\n        <span>var</span> x;\n    }\n}\n</code></pre><p>在上面的例子里，所有<code>x</code>的声明实际上都引用一个<em>相同</em>的<code>x</code>，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， <code>let</code>声明就不会这么宽松了。</p><pre><code><span>let</span> x = <span>10</span>;\n<span>let</span> x = <span>20</span>; <span>// 错误，不能在1个作用域里多次声明`x`</span>\n</code></pre><p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p><pre><code><span><span>function</span> <span>f</span>(<span>x</span>) </span>{\n    <span>let</span> x = <span>100</span>; <span>// error: interferes with parameter declaration</span>\n}\n\n<span><span>function</span> <span>g</span>(<span></span>) </span>{\n    <span>let</span> x = <span>100</span>;\n    <span>var</span> x = <span>100</span>; <span>// error: can't have both declarations of 'x'</span>\n}\n</code></pre><p>并不是说块级作用域变量不能在函数作用域内声明。 而是块级作用域变量需要在不用的块里声明。</p><pre><code><span><span>function</span> <span>f</span>(<span>condition, x</span>) </span>{\n    <span>if</span> (condition) {\n        <span>let</span> x = <span>100</span>;\n        <span>return</span> x;\n    }\n\n    <span>return</span> x;\n}\n\nf(<span>false</span>, <span>0</span>); <span>// returns 0</span>\nf(<span>true</span>, <span>0</span>);  <span>// returns 100</span>\n</code></pre><p>在一个嵌套作用域里引入一个新名字的行为称做<em>屏蔽</em>。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code>重写之前的<code>sumMatrix</code>函数。</p><pre><code><span><span>function</span> <span>sumMatrix</span>(<span>matrix: <span>number</span>[][]</span>) </span>{\n    <span>let</span> sum = <span>0</span>;\n    <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; matrix.length; i++) {\n        <span>var</span> currentRow = matrix[i];\n        <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    <span>return</span> sum;\n}\n</code></pre><p>这个版本的循环能得到正确的结果，因为内层循环的<code>i</code>可以屏蔽掉外层循环的<code>i</code>。</p><p><em>通常</em>来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p><h2>块级作用域变量的获取</h2><p>在我们最初谈及获取用<code>var</code>声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 <em>环境</em>。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p><pre><code><span><span>function</span> <span>theCityThatAlwaysSleeps</span>(<span></span>) </span>{\n    <span>let</span> getCity;\n\n    <span>if</span> (<span>true</span>) {\n        <span>let</span> city = <span>\"Seattle\"</span>;\n        getCity = <span><span>function</span>(<span></span>) </span>{\n            <span>return</span> city;\n        }\n    }\n\n    <span>return</span> getCity();\n}\n</code></pre><p>因为我们已经在<code>city</code>的环境里获取到了<code>city</code>，所以就算<code>if</code>语句执行结束后我们仍然可以访问它。</p><p>回想一下前面<code>setTimeout</code>的例子，我们最后需要使用立即执行的函数表达式来获取每次<code>for</code>循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p><p>当<code>let</code>声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 <em>每次迭代</em>都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 <code>setTimeout</code>例子里我们仅使用<code>let</code>声明就可以了。</p><pre><code><span>for</span> (<span>let</span> i = <span>0</span>; i &lt; <span>10</span> ; i++) {\n    setTimeout(<span><span>function</span>(<span></span>) </span>{<span>console</span>.log(i); }, <span>100</span> * i);\n}\n</code></pre><p>会输出与预料一致的结果：</p><pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre><h1><code>const</code> 声明</h1><p><code>const</code> 声明是声明变量的另一种方式。</p><pre><code><span>const</span> numLivesForCat = <span>9</span>;\n</code></pre><p>它们与<code>let</code>声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code>相同的作用域规则，但是不能对它们重新赋值。</p><p>这很好理解，它们引用的值是<em>不可变的</em>。</p><pre><code><span>const</span> numLivesForCat = <span>9</span>;\n<span>const</span> kitty = {\n    name: <span>\"Aurora\"</span>,\n    numLives: numLivesForCat,\n}\n\n<span>// Error</span>\nkitty = {\n    name: <span>\"Danielle\"</span>,\n    numLives: numLivesForCat\n};\n\n<span>// all \"okay\"</span>\nkitty.name = <span>\"Rory\"</span>;\nkitty.name = <span>\"Kitty\"</span>;\nkitty.name = <span>\"Cat\"</span>;\nkitty.numLives--;\n</code></pre><p>除非你使用特殊的方法去避免，实际上<code>const</code>变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 <a href=\"http://www.tslang.cn/docs/handbook/Interfaces.md\" rel=\"external nofollow\" target=\"_blank\">接口</a>一章有详细说明。</p><h1><code>let</code> vs. <code>const</code></h1><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p><p>使用<a href=\"https://en.wikipedia.org/wiki/Principle_of_least_privilege\" rel=\"external nofollow\" target=\"_blank\">最小特权原则</a>，所有变量除了你计划去修改的都应该使用<code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 <code>const</code>也可以让我们更容易的推测数据的流动。</p><p>另一方面，用户很喜欢<code>let</code>的简洁性。 这个手册大部分地方都使用了 <code>let</code>。</p><p>跟据你的自己判断，如果合适的话，与团队成员商议一下。 Fortunately, TypeScript allows you to specify that members of an object are <code>readonly</code>. The <a href=\"http://www.tslang.cn/docs/handbook/Interfaces.md\" rel=\"external nofollow\" target=\"_blank\">chapter on Interfaces</a> has the details.</p><h1>解构</h1><p>Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" rel=\"external nofollow\" target=\"_blank\">the article on the Mozilla Developer Network</a>。 本章，我们将给出一个简短的概述。</p><h2>解构数组</h2><p>最简单的解构莫过于数组的解构赋值了：</p><pre><code><span>let</span> input = [<span>1</span>, <span>2</span>];\n<span>let</span> [first, second] = input;\n<span>console</span>.log(first); <span>// outputs 1</span>\n<span>console</span>.log(second); <span>// outputs 2</span>\n</code></pre><p>这创建了2个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p><pre><code>first = input[<span>0</span>];\nsecond = input[<span>1</span>];\n</code></pre><p>解构作用于已声明的变量会更好：</p><pre><code><span>// swap variables</span>\n[first, second] = [second, first];\n</code></pre><p>作用于函数参数：</p><pre><code><span><span>function</span> <span>f</span>(<span>[first, second]: [<span>number</span>, <span>number</span>]</span>) </span>{\n    <span>console</span>.log(first);\n    <span>console</span>.log(second);\n}\nf(input);\n</code></pre><p>你可以使用<code>...name</code>语法创建一个剩余变量列表：</p><pre><code><span>let</span> [first, ...rest] = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>];\n<span>console</span>.log(first); <span>// outputs 1</span>\n<span>console</span>.log(rest); <span>// outputs [ 2, 3, 4 ]</span>\n</code></pre><p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p><pre><code><span>let</span> [first] = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>];\n<span>console</span>.log(first); <span>// outputs 1</span>\n</code></pre><p>或其它元素：</p><pre><code><span>let</span> [, second, , fourth] = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>];\n</code></pre><h2>对象解构</h2><p>你也可以解构对象：</p><pre><code><span>let</span> o = {\n    a: <span>\"foo\"</span>,\n    b: <span>12</span>,\n    c: <span>\"bar\"</span>\n}\n<span>let</span> {a, b} = o;\n</code></pre><p>这通过 <code>o.a</code> and <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p><p>就像数组解构，你可以用没有声明的赋值：</p><pre><code>({a, b} = {a: <span>\"baz\"</span>, b: <span>101</span>});\n</code></pre><p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>{</code> 起始的语句解析为一个块。</p><h3>属性重命名</h3><p>你也可以给属性以不同的名字：</p><pre><code><span>let</span> {a: newName1, b: newName2} = o;\n</code></pre><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 \"<code>a</code> 作为 <code>newName1</code>\"。 方向是从左到右，好像你写成了以下样子：</p><pre><code><span>let</span> newName1 = o.a;\n<span>let</span> newName2 = o.b;\n</code></pre><p>令人困惑的是，这里的冒号<em>不是</em>指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p><pre><code><span>let</span> {a, b}: {a: <span>string</span>, b: <span>number</span>} = o;\n</code></pre><h3>默认值</h3><p>默认值可以让你在属性为 undefined 时使用缺省值：</p><pre><code><span><span>function</span> <span>keepWholeObject</span>(<span>wholeObject: {a: <span>string</span>, b?: <span>number</span>}</span>) </span>{\n    <span>let</span> {a, b = <span>1001</span>} = wholeObject;\n}\n</code></pre><p>现在，即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p><h2>函数声明</h2><p>解构也能用于函数声明。 看以下简单的情况：</p><pre><code><span>type</span> C = {a: <span>string</span>, b?: <span>number</span>}\n<span><span>function</span> <span>f</span>(<span>{a, b}: C</span>): <span>void</span> </span>{\n    <span>// ...</span>\n}\n</code></pre><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要知道在设置默认值之前设置其类型。</p><pre><code><span><span>function</span> <span>f</span>(<span>{a, b} = {a: \"\", b: 0}</span>): <span>void</span> </span>{\n    <span>// ...</span>\n}\nf(); <span>// ok, default to {a: \"\", b: 0}</span>\n</code></pre><p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p><pre><code><span><span>function</span> <span>f</span>(<span>{a, b = 0} = {a: \"\"}</span>): <span>void</span> </span>{\n    <span>// ...</span>\n}\nf({a: <span>\"yes\"</span>}) <span>// ok, default b = 0</span>\nf() <span>// ok, default to {a: \"\"}, which then defaults b = 0</span>\nf({}) <span>// error, 'a' is required if you supply an argument</span>\n</code></pre><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构也会有很多问题。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p></div>\r\n<div style=\"clear:both\"></div>\n</div>"
    }
  ]
}
